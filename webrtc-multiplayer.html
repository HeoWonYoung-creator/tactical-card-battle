<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cast Me If You Can</title>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ†</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Pretendard:wght@300;400;500;600;700&family=MedievalSharp:wght@400&family=Uncial+Antiqua&family=UnifrakturMaguntia&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Pretendard', sans-serif;
            background: 
                linear-gradient(135deg, #ffffff 0%, #f8f9fa 50%, #e9ecef 100%),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 20px,
                    rgba(0, 0, 0, 0.03) 20px,
                    rgba(0, 0, 0, 0.03) 40px
                );
            background-size: 100% 100%, 40px 40px;
            background-position: 0 0, 0 0;
            background-repeat: no-repeat, repeat;
            color: #333333;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        .font-cinzel {
            font-family: 'Cinzel Decorative', cursive;
        }
        .font-orbitron {
            font-family: 'Orbitron', monospace;
        }
        .font-exo {
            font-family: 'Pretendard', sans-serif;
        }
        .game-title {
            font-family: 'UnifrakturMaguntia', cursive;
            font-weight: 900;
            color: #333333;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            letter-spacing: 2px;
        }
        .card {
            width: 70px;
            height: 100px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            user-select: none;
            position: relative;
            overflow: hidden;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .card-back {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            color: #6c757d;
            border: 2px solid #dee2e6;
        }
        .card-back:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .card-front {
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
            color: #333333;
            border: 1px solid #dee2e6;
        }
        .card-front:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .card-pile {
             cursor: help;
             transition: transform 0.3s ease;
        }
        .card-pile:hover {
            transform: scale(1.05);
        }
        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            transition: all 0.3s ease;
            border: none;
            position: relative;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }
        
        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.4);
        }
        .btn-primary:disabled {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        .btn-secondary {
            background: transparent;
            color: #6c757d;
            border: 2px solid #6c757d;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            font-weight: 600;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: rgba(108, 117, 125, 0.1);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
        }
        
        .btn-secondary:disabled {
            background: transparent;
            color: #adb5bd;
            border-color: #adb5bd;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        .memo-button {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #6c757d;
            border: 1px solid #dee2e6;
            transition: all 0.3s ease;
            font-family: 'Pretendard', sans-serif;
            font-weight: 500;
            font-size: 0.6rem;
            min-height: 24px;
        }
        .memo-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .memo-button.active {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border-color: #dc3545;
        }
        .memo-button.active:hover {
            background: linear-gradient(135deg, #c82333 0%, #bd2130 100%);
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.4);
        }
        .game-log {
            height: 150px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-family: 'Pretendard', sans-serif;
        }
        .game-log p {
            margin: 2px 0;
            padding: 3px 8px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        .game-log p:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }
        .modal-bg {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 2px solid #dee2e6;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease-out;
            font-family: 'Pretendard', sans-serif;
            color: #333333;
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        /* ë§í’ì„  ìŠ¤íƒ€ì¼ */
        #secret-stones-tooltip::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 20px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid white;
        }
        
        #used-stones-tooltip::before {
            content: '';
            position: absolute;
            right: -8px;
            top: 20px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 8px solid white;
        }
        
        #secret-stones-tooltip::after {
            content: '';
            position: absolute;
            left: -9px;
            top: 20px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid #d1d5db;
        }
        
        #used-stones-tooltip::after {
            content: '';
            position: absolute;
            right: -9px;
            top: 20px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 8px solid #d1d5db;
        }
        .player-area-glow {
            box-shadow: 0 0 10px 4px rgba(0, 123, 255, 0.6);
            animation: glowPulse 1.5s ease-in-out infinite;
            border: 1px solid rgba(0, 123, 255, 0.7);
            border-radius: 12px;
            position: relative;
        }
        .player-area-glow.opponent-turn {
            box-shadow: 0 0 10px 4px rgba(220, 53, 69, 0.6);
            border-color: rgba(220, 53, 69, 0.7);
            border: 1px solid rgba(220, 53, 69, 0.7);
        }
        .player-area-glow.opponent-turn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, rgba(220, 53, 69, 0.05), rgba(220, 53, 69, 0.15));
            border-radius: 14px;
            z-index: -1;
            animation: backgroundPulseRed 2s ease-in-out infinite;
        }
        .player-area-glow::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, rgba(0, 123, 255, 0.05), rgba(0, 123, 255, 0.15));
            border-radius: 14px;
            z-index: -1;
            animation: backgroundPulse 2s ease-in-out infinite;
        }
        @keyframes glowPulse {
            0%, 100% { 
                box-shadow: 0 0 10px 4px rgba(0, 123, 255, 0.6);
                border-color: rgba(0, 123, 255, 0.7);
            }
            50% { 
                box-shadow: 0 0 15px 6px rgba(0, 123, 255, 0.8);
                border-color: rgba(0, 123, 255, 0.8);
            }
        }
        .player-area-glow.opponent-turn {
            animation: glowPulseRed 1.5s ease-in-out infinite;
        }
        @keyframes glowPulseRed {
            0%, 100% { 
                box-shadow: 0 0 10px 4px rgba(220, 53, 69, 0.6);
                border-color: rgba(220, 53, 69, 0.7);
            }
            50% { 
                box-shadow: 0 0 15px 6px rgba(220, 53, 69, 0.8);
                border-color: rgba(220, 53, 69, 0.8);
            }
        }
        @keyframes backgroundPulseRed {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.02);
            }
        }
        @keyframes backgroundPulse {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.02);
            }
        }
        .health-heart {
            animation: heartBeat 1s ease-in-out infinite;
        }
        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        

        

        .spell-button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            /* ë¹„í™œì„±í™”ëœ ë²„íŠ¼ë„ í•­ìƒ ë³´ì´ë„ë¡ ì„¤ì • */
            display: block !important;
            visibility: visible !important;
        }
        .spell-button:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.4);
        }
        .spell-button:active:not(:disabled) {
            transform: translateY(-1px) scale(1.02);
        }
        .success-animation {
            animation: successGlow 0.5s ease-out;
        }
        @keyframes successGlow {
            0% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.8); }
            100% { box-shadow: 0 0 0 rgba(255, 255, 255, 0); }
        }
        .failure-animation {
            animation: failureShake 0.5s ease-out;
        }
        @keyframes failureShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .turn-indicator {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            border-radius: 50%;
            animation: turnPulse 1s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 9px;
            font-weight: bold;
            box-shadow: 0 1px 4px rgba(0, 123, 255, 0.3);
            z-index: 10;
        }
        .turn-indicator.opponent-turn {
            background: linear-gradient(135deg, #dc3545, #c82333);
            box-shadow: 0 1px 4px rgba(220, 53, 69, 0.3);
            animation: turnPulseRed 1s ease-in-out infinite;
        }
        @keyframes turnPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1;
                box-shadow: 0 1px 4px rgba(0, 123, 255, 0.3);
            }
            50% { 
                transform: scale(1.2); 
                opacity: 0.9;
                box-shadow: 0 3px 10px rgba(0, 123, 255, 0.5);
            }
        }
        .turn-indicator.opponent-turn {
            animation: turnPulseRed 1s ease-in-out infinite;
        }
        @keyframes turnPulseRed {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1;
                box-shadow: 0 1px 4px rgba(220, 53, 69, 0.3);
            }
            50% { 
                transform: scale(1.2); 
                opacity: 0.9;
                box-shadow: 0 3px 10px rgba(220, 53, 69, 0.5);
            }
        }
        .card-damage {
            position: absolute;
            color: #ffffff;
            font-weight: bold;
            font-size: 1.2rem;
            animation: damageFloat 1s ease-out forwards;
            pointer-events: none;
        }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        .card-heal {
            position: absolute;
            color: #ffffff;
            font-weight: bold;
            font-size: 1.2rem;
            animation: healFloat 1s ease-out forwards;
            pointer-events: none;
        }
        

        @keyframes healFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        
        /* íŒŒí‹°í´ íš¨ê³¼ ìŠ¤íƒ€ì¼ */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 1.5rem;
            animation: particleExplode 2s ease-out forwards;
            z-index: 9999;
            will-change: transform, opacity;
            transform-origin: center;
        }
        
        @keyframes particleExplode {
            0% {
                transform: scale(1) translate(0, 0);
                opacity: 1;
            }
            40% {
                opacity: 1;
            }
            100% {
                transform: scale(0.1) translate(var(--x), var(--y));
                opacity: 0;
            }
        }
        
        /* ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #refresh-game-btn {
            transition: all 0.3s ease;
            opacity: 0.8;
        }
        #refresh-game-btn:hover {
            opacity: 1;
            transform: scale(1.02);
        }
        #refresh-game-btn:active {
            transform: scale(0.98);
        }

        /* ëª¨ë°”ì¼ ìµœì í™” ìŠ¤íƒ€ì¼ */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                font-size: 14px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ë²„íŠ¼ í¬ê¸° ìµœì í™” */
            .btn-primary, .btn-secondary {
                min-height: 44px;
                font-size: 16px;
                padding: 12px 16px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ì¹´ë“œ í¬ê¸° ì¡°ì • */
            .spell-card {
                width: 50px;
                height: 70px;
                font-size: 20px;
                margin: 0 2px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ê²Œì„ ë¡œê·¸ ìˆ¨ê¹€ */
            #game-log {
                display: none !important;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ëª¨ë‹¬ í¬ê¸° ì¡°ì • */
            .modal-content {
                max-width: 95vw;
                margin: 10px;
                padding: 15px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ì£¼ë¬¸ ë²„íŠ¼ ì»´íŒ©íŠ¸í™” */
            .spell-button {
                width: 60px;
                height: 60px;
                font-size: 24px;
                margin: 4px;
                border-radius: 8px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ í”Œë ˆì´ì–´ ì˜ì—­ ì¡°ì • */
            #player-area, #opponent-area {
                padding: 10px;
                margin: 5px 0;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ íƒ€ì´í‹€ í™”ë©´ ì¡°ì • */
            .title-content {
                padding: 20px;
            }
            
            .title-content h1 {
                font-size: 24px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ë²„íŠ¼ ê·¸ë£¹ ì¡°ì • */
            .button-group {
                gap: 8px;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ë©”ëª¨ íŒ¨ë„ ìˆ¨ê¹€ */
            #memo-panel {
                display: none !important;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ë””ë²„ê·¸ ì •ë³´ ìˆ¨ê¹€ */
            #debug-info {
                display: none !important;
            }
        }

        /* í„°ì¹˜ ìµœì í™” */
        @media (hover: none) and (pointer: coarse) {
            /* í„°ì¹˜ ë””ë°”ì´ìŠ¤ì—ì„œ í˜¸ë²„ íš¨ê³¼ ì œê±° */
            .spell-button:hover,
            .btn-primary:hover,
            .btn-secondary:hover {
                transform: none;
            }
            
            /* í„°ì¹˜ í”¼ë“œë°± */
            .spell-button:active,
            .btn-primary:active,
            .btn-secondary:active {
                transform: scale(0.95);
                transition: transform 0.1s;
            }
        }

        /* ì»´íŒ©íŠ¸ ëª¨ë“œ (ëª¨ë°”ì¼ ì „ìš©) */
        .compact-mode {
            --card-size: 40px;
            --button-size: 50px;
            --spacing: 4px;
        }
        
        .compact-mode .spell-card {
            width: var(--card-size);
            height: calc(var(--card-size) * 1.4);
            font-size: 16px;
            margin: 0 var(--spacing);
        }
        
        .compact-mode .spell-button {
            width: var(--button-size);
            height: var(--button-size);
            font-size: 20px;
            margin: var(--spacing);
        }
        
        .compact-mode #game-log,
        .compact-mode #memo-panel,
        .compact-mode #debug-info {
            display: none !important;
        }
        
        .compact-mode .player-info {
            font-size: 12px;
        }
        
        .compact-mode .health-display {
            font-size: 18px;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- íƒ€ì´í‹€ í™”ë©´ -->
    <div id="title-screen" class="w-full max-w-2xl mx-auto text-center">
        <div class="mb-6">
            <img src="magic_battle.png" alt="MAGIC FLIP íƒ€ì´í‹€" class="mx-auto max-w-xs md:max-w-sm h-auto rounded-lg">
        </div>
        <h1 class="text-5xl game-title mb-8">Cast Me If You Can</h1>
        <div class="bg-black bg-opacity-10 p-6 rounded-lg text-left mb-8 relative">
            <div class="flex justify-between items-start mb-4">
                <h3 class="text-xl font-bold text-center font-exo flex items-center justify-center"><span>ğŸ“</span><span class="ml-1">ê²Œì„ ê·œì¹™</span></h3>
                <button id="spell-cards-btn" class="px-3 py-1 rounded-lg font-bold btn-secondary text-sm whitespace-nowrap">ğŸ§™â€â™‚ï¸ ì¹´ë“œ ë³´ê¸°</button>
            </div>
            <ul class="list-disc list-inside space-y-1">
                <li>ìƒëŒ€ì˜ ë§ˆë²• ì¹´ë“œë¥¼ ë³´ê³ , ë³´ì´ì§€ ì•ŠëŠ” ìì‹ ì˜ ì¹´ë“œë¥¼ ì¶”ì¸¡í•´ ì˜ì°½í•˜ì„¸ìš”.</li>
                <li>ì˜ì°½ì— ì„±ê³µí•˜ë©´ ì¶”ê°€ë¡œ ê°™ê±°ë‚˜, ë” ë†’ì€ ìˆ«ìì˜ ì˜ì°½ì„ ì‹œì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                <li>ì˜ì°½ì— ì‹¤íŒ¨í•˜ë©´ ì²´ë ¥ì´ 1 ê°ì†Œí•˜ê³  í„´ì´ ì¢…ë£Œë©ë‹ˆë‹¤.</li>
                <li>ìƒëŒ€ì˜ ì²´ë ¥ì„ 0ìœ¼ë¡œ ë§Œë“¤ê±°ë‚˜, ë‚´ ë§ˆë²• ì¹´ë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤!</li>
            </ul>
        </div>
        <!-- ë§ˆë²•ì‚¬ ì •ë³´ ì˜ì—­ -->
        <div class="bg-black bg-opacity-10 p-4 rounded-lg mb-6">
            <div class="flex items-center justify-between mb-2">
                <label class="text-sm font-bold text-white">ë§ˆë²•ì‚¬ ì •ë³´</label>
                <span id="account-status" class="text-xs text-green-400 hidden">âœ“ ë¡œê·¸ì¸ë¨</span>
            </div>
            
            <!-- ê²ŒìŠ¤íŠ¸ ëª¨ë“œ í‘œì‹œ -->
            <div id="guest-mode-display" class="mb-4 p-3 bg-gray-700 rounded-lg">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-2">
                        <div class="text-xl">ğŸ‘¤</div>
                        <div class="flex flex-col items-start">
                            <div class="text-sm font-bold text-white">ê²ŒìŠ¤íŠ¸ ëª¨ë“œ</div>
                            <div class="text-xs text-gray-300">ëª¨ì˜ ê²°íˆ¬ë§Œ ê°€ëŠ¥í•˜ë©°, ì ìˆ˜ê°€ ì €ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤</div>
                        </div>
                    </div>
                    <button id="login-btn" class="px-4 py-2 rounded-lg font-bold btn-primary text-sm">ë¡œê·¸ì¸</button>
                </div>
            </div>
            
            <!-- ê³„ì • ëª¨ë“œ í‘œì‹œ -->
            <div id="account-mode-display" class="mb-4 p-3 bg-gray-100 rounded-lg hidden">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <div class="text-xl mr-2">ğŸ‘¤</div>
                        <div id="account-nickname" class="text-sm font-bold text-gray-800">ë‹‰ë„¤ì„</div>
                    </div>
                    <button id="logout-btn" class="px-3 py-1 rounded-lg font-bold bg-red-600 hover:bg-red-700 text-white text-sm">ë¡œê·¸ì•„ì›ƒ</button>
                </div>
            </div>
            
            <!-- ê²ŒìŠ¤íŠ¸ ì´ë¦„ ì…ë ¥ -->
            <div id="guest-name-input" class="mb-4">
                <div class="flex space-x-2">
                    <div class="flex-1 relative">
                        <div class="absolute left-3 top-1/2 transform -translate-y-1/2 text-xl pointer-events-none">ğŸ‘¤</div>
                        <input type="text" id="player-name-input" 
                               class="w-full px-3 py-2 pl-10 bg-gray-800 border border-gray-600 rounded-lg text-white focus:outline-none focus:border-blue-400"
                               placeholder="ê²ŒìŠ¤íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="15" value="">
                    </div>
                    <button id="save-name-btn" class="px-4 py-2 rounded-lg font-bold btn-primary text-sm whitespace-nowrap">ì €ì¥</button>
                </div>
            </div>
        </div>
        
        <div class="space-y-4">
            <button id="ai-battle-btn" class="w-full py-4 rounded-lg font-bold text-xl btn-primary border-2 border-white">ëª¨ì˜ ê²°íˆ¬ <span class="text-sm font-normal">(vs AI í—ˆìˆ˜ì•„ë¹„)</span></button>
            <button id="multiplayer-btn" class="w-full py-4 rounded-lg font-bold text-xl bg-red-600 hover:bg-red-700 text-white transition-all duration-300 hover:transform hover:-translate-y-0.5 hover:shadow-lg" style="box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);">ì •ì‹ ê²°íˆ¬ <span class="text-sm font-normal">(vs ë‹¤ë¥¸ ë§ˆë²•ì‚¬)</span></button>
            
            <!-- ìŠ¹ë¦¬ì˜ ì¦í‘œ í‘œì‹œ ì˜ì—­ -->
            <div id="trophy-display" class="flex justify-center items-center space-x-4 mb-4 hidden">
                <div class="text-2xl">ğŸ…</div>
                <div class="flex items-center space-x-2">
                    <div class="text-sm font-bold text-yellow-300">ëª¨ì˜ ê²°íˆ¬</div>
                    <div id="ai-trophy-count" class="text-lg font-bold text-yellow-200">0</div>
                </div>
                <div class="text-gray-400">|</div>
                <div class="flex items-center space-x-2">
                    <div class="text-sm font-bold text-red-300">ì •ì‹ ê²°íˆ¬</div>
                    <div id="multiplayer-trophy-count" class="text-lg font-bold text-red-200">0</div>
                </div>
            </div>
            
            <div class="flex justify-center space-x-2">
                <button id="profile-btn" class="w-1/2 py-2 rounded-lg font-bold text-base btn-secondary hidden">ğŸ‘¤ ë‚´ ì •ë³´</button>
                <button id="ranking-btn" class="w-1/2 py-2 rounded-lg font-bold text-base btn-secondary hidden">ğŸ† ë­í‚¹ ë³´ê¸°</button>
            </div>
        </div>
        
        <!-- AI ë‚œì´ë„ ì„ íƒ ëª¨ë‹¬ -->
        <div id="ai-difficulty-modal" class="fixed inset-0 flex items-center justify-center hidden modal-bg z-50">
            <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                <div class="text-center">
                                         <div class="text-4xl mb-4">ğŸ­</div>
                                         <h3 class="text-xl font-bold mb-4">ë‚œì´ë„ ì„ íƒ</h3>
                     <p class="text-gray-300 mb-6">ì–´ë–¤ í—ˆìˆ˜ì•„ë¹„ë¥¼ í˜¼ì­ë‚´ì‹œê² ìŠµë‹ˆê¹Œ?<br>ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
                    <div class="space-y-3">
                        <button id="easy-ai-btn" class="w-full py-3 rounded-lg font-bold btn-primary text-green-400 hover:text-green-300">
                            ì‰¬ì›€
                            <div class="text-xs text-green-300 mt-1">(ë©ì²­í•¨, ì‹œê°„ ì œí•œ ì—†ìŒ)</div>
                        </button>
                        <button id="normal-ai-btn" class="w-full py-3 rounded-lg font-bold btn-primary text-yellow-400 hover:text-yellow-300">
                            ë³´í†µ
                            <div class="text-xs text-yellow-300 mt-1">(ë˜‘ë˜‘í•¨, ì‹œê°„ ì œí•œ 30ì´ˆ)</div>
                        </button>
                        <button id="hard-ai-btn" class="w-full py-3 rounded-lg font-bold btn-primary text-red-400 hover:text-red-300">
                            ì–´ë ¤ì›€
                            <div class="text-xs text-red-300 mt-1">(ëŒ€ë‹¨í•¨, ì‹œê°„ ì œí•œ 20ì´ˆ)</div>
                        </button>
                        <button id="cancel-difficulty-btn" class="w-full py-2 rounded-lg font-bold btn-secondary">ì·¨ì†Œ</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ë¡œê·¸ì¸/íšŒì›ê°€ì… ëª¨ë‹¬ -->
        <div id="auth-modal" class="fixed inset-0 flex items-center justify-center hidden modal-bg z-50">
            <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                <div class="text-center mb-6">
                    <div class="text-4xl mb-4">ğŸ”</div>
                    <h3 id="auth-title" class="text-xl font-bold mb-2">ë¡œê·¸ì¸</h3>
                    <p id="auth-subtitle" class="text-gray-600">ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì—¬ ì ìˆ˜ë¥¼ ì €ì¥í•˜ì„¸ìš”</p>
                </div>
                
                <!-- ë¡œê·¸ì¸ í¼ -->
                <form id="login-form" class="space-y-4">
                    <div>
                        <label class="block text-sm font-bold text-gray-700 mb-2">ì•„ì´ë””</label>
                        <input type="text" id="login-username" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500"
                               placeholder="ì•„ì´ë””ë¥¼ ì…ë ¥í•˜ì„¸ìš”" required>
                    </div>
                    <div>
                        <label class="block text-sm font-bold text-gray-700 mb-2">ë¹„ë°€ë²ˆí˜¸</label>
                        <input type="password" id="login-password" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500"
                               placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”" required>
                    </div>
                    <div class="flex space-x-2">
                        <button type="submit" class="flex-1 py-2 rounded-lg font-bold btn-primary">ë¡œê·¸ì¸</button>
                        <button type="button" id="switch-to-register" class="flex-1 py-2 rounded-lg font-bold btn-secondary">íšŒì›ê°€ì…</button>
                    </div>
                </form>
                
                <!-- íšŒì›ê°€ì… í¼ -->
                <form id="register-form" class="space-y-4 hidden">
                    <div>
                        <label class="block text-sm font-bold text-gray-700 mb-2">ì•„ì´ë””</label>
                        <input type="text" id="register-username" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500"
                               placeholder="3-20ì ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´" required>
                    </div>
                    <div>
                        <label class="block text-sm font-bold text-gray-700 mb-2">ë¹„ë°€ë²ˆí˜¸</label>
                        <input type="password" id="register-password" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500"
                               placeholder="6ì ì´ìƒ" required>
                    </div>
                    <div>
                        <label class="block text-sm font-bold text-gray-700 mb-2">ë‹‰ë„¤ì„</label>
                        <input type="text" id="register-nickname" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500"
                               placeholder="2-15ì" required>
                    </div>
                    <div class="flex space-x-2">
                        <button type="submit" class="flex-1 py-2 rounded-lg font-bold btn-primary">íšŒì›ê°€ì…</button>
                        <button type="button" id="switch-to-login" class="flex-1 py-2 rounded-lg font-bold btn-secondary">ë¡œê·¸ì¸</button>
                    </div>
                </form>
                
                <div class="text-center mt-4">
                    <button id="close-auth-btn" class="px-4 py-2 rounded-lg font-bold btn-secondary">ì·¨ì†Œ</button>
                </div>
            </div>
        </div>
        
        <!-- ë§ˆë²• ì¹´ë“œ ì •ë³´ ëª¨ë‹¬ -->
        <div id="spell-cards-modal" class="fixed inset-0 flex items-center justify-center hidden modal-bg z-50">
            <div class="modal-content p-6 rounded-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                <div class="text-center">
                    <div class="text-4xl mb-4">ğŸ§™â€â™‚ï¸</div>
                    <h3 class="text-xl font-bold mb-4 text-gray-800">ë§ˆë²• ì¹´ë“œ ì •ë³´</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div class="bg-gradient-to-br from-purple-100 to-purple-200 border-2 border-purple-300 p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                            <div class="flex items-center space-x-3 mb-2">
                                <div class="text-2xl">ğŸ”®</div>
                                <div class="font-bold text-purple-800">1: ìš´ëª… ë³€í™˜</div>
                            </div>
                            <div class="text-sm text-purple-700 text-left">ë¹„ë°€ ì£¼ë¬¸ 3ê°œë¥¼ ë‚˜ì—ê²Œë§Œ ê³µê°œ</div>
                        </div>
                        <div class="bg-gradient-to-br from-yellow-100 to-yellow-200 border-2 border-yellow-300 p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                            <div class="flex items-center space-x-3 mb-2">
                                <div class="text-2xl">ğŸ’«</div>
                                <div class="font-bold text-yellow-800">2: ë§ˆë ¥ ì°©ì·¨</div>
                            </div>
                            <div class="text-sm text-yellow-700 text-left">í”¼í•´ 1, íšŒë³µ 1</div>
                        </div>
                        <div class="bg-gradient-to-br from-blue-100 to-blue-200 border-2 border-blue-300 p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                            <div class="flex items-center space-x-3 mb-2">
                                <div class="text-2xl">ğŸŒ€</div>
                                <div class="font-bold text-blue-800">3: ì •ì‹  êµë€</div>
                            </div>
                            <div class="text-sm text-blue-700 text-left">ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸ í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…</div>
                        </div>
                        <div class="bg-gradient-to-br from-red-100 to-red-200 border-2 border-red-300 p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                            <div class="flex items-center space-x-3 mb-2">
                                <div class="text-2xl">ğŸ”¥</div>
                                <div class="font-bold text-red-800">4: í™”ì—¼ í™”ì‚´</div>
                            </div>
                            <div class="text-sm text-red-700 text-left">í”¼í•´ 1</div>
                        </div>
                        <div class="bg-gradient-to-br from-green-100 to-green-200 border-2 border-green-300 p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                            <div class="flex items-center space-x-3 mb-2">
                                <div class="text-2xl">ğŸ§ª</div>
                                <div class="font-bold text-green-800">5: ìƒëª… ë¬¼ì•½</div>
                            </div>
                            <div class="text-sm text-green-700 text-left">íšŒë³µ 1</div>
                        </div>
                        <div class="bg-gradient-to-br from-indigo-100 to-indigo-200 border-2 border-indigo-300 p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                            <div class="flex items-center space-x-3 mb-2">
                                <div class="text-2xl">ğŸ’¤</div>
                                <div class="font-bold text-indigo-800">6: ëª…ìƒ</div>
                            </div>
                            <div class="text-sm text-indigo-700 text-left">ë¹„ë°€ ì£¼ë¬¸ 1ê°œë¥¼ ì „ì²´ ê³µê°œ</div>
                        </div>
                    </div>
                    <div class="bg-gradient-to-br from-gray-100 to-gray-200 border-2 border-gray-300 p-4 rounded-lg mb-6 shadow-md">
                        <h4 class="font-bold text-gray-800 mb-2">ğŸ“Š ë± êµ¬ì„±</h4>
                        <p class="text-sm text-gray-700">
                            ê²Œì„ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë§ˆë²• ì¹´ë“œëŠ” ì´ 21ì¥ì´ë©°, ê°ê° ì£¼ë¬¸ì— ì íŒ ìˆ«ìë§Œí¼ ì¡´ì¬í•©ë‹ˆë‹¤.<br>
                            <span class="text-purple-600 font-semibold">1ë²ˆ ì£¼ë¬¸: 1ì¥</span> | 
                            <span class="text-yellow-600 font-semibold">2ë²ˆ ì£¼ë¬¸: 2ì¥</span> | 
                            <span class="text-blue-600 font-semibold">3ë²ˆ ì£¼ë¬¸: 3ì¥</span> | 
                            <span class="text-red-600 font-semibold">4ë²ˆ ì£¼ë¬¸: 4ì¥</span> | 
                            <span class="text-green-600 font-semibold">5ë²ˆ ì£¼ë¬¸: 5ì¥</span> | 
                            <span class="text-indigo-600 font-semibold">6ë²ˆ ì£¼ë¬¸: 6ì¥</span>
                        </p>
                    </div>
                    <button id="close-spell-cards-btn" class="px-6 py-2 rounded-lg btn-primary">í™•ì¸</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ê²Œì„ í™”ë©´ -->
    <div id="game-screen" class="w-full max-w-4xl mx-auto space-y-2 hidden">
        <!-- ìƒëŒ€ ì˜ì—­ (í•­ìƒ ìƒë‹¨) -->
        <div id="opponent-area" class="p-4 border-2 border-red-400 rounded-lg transition-all duration-500 relative">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-red-300">ìƒëŒ€</h2>
                <div id="opponent-health" class="flex items-center space-x-1 text-2xl"></div>
            </div>
            <div id="opponent-hand" class="flex justify-center space-x-2"></div>
            <div id="opponent-turn-indicator" class="turn-indicator hidden">ìƒëŒ€ í„´!</div>
        </div>

                <!-- ì¤‘ì•™ ì˜ì—­ -->
        <div class="flex justify-between items-center p-4 h-48">
            <div id="secret-stones-pile" class="flex flex-col items-center space-y-1 card-pile relative z-20">
                <div class="card card-back flex flex-col items-center justify-center" 
                     ontouchstart="startLongPress('secret')" ontouchend="hideTooltips()" 
                     onmousedown="startLongPress('secret')" onmouseup="hideTooltips()" onmouseleave="hideTooltips()"
                     onmouseenter="showSecretStonesTooltip()" onmouseleave="hideTooltips()">
                    <div class="text-2xl mb-1">â“</div>
                    <div class="text-sm font-bold">?</div>
                </div>
                <div class="font-bold">ë¹„ë°€ ì£¼ë¬¸</div>
                <div id="secret-stones-count" class="text-lg"></div>
                
                <!-- ë¹„ë°€ ì£¼ë¬¸ ë§í’ì„  íŒì—… -->
                <div id="secret-stones-tooltip" class="absolute right-0 top-0 transform translate-x-full ml-12 bg-white border border-gray-200 rounded-lg p-3 shadow-lg hidden z-[60] min-w-[280px] max-w-[380px]">
                    <div class="text-center font-bold mb-3 text-sm text-gray-800 border-b border-gray-200 pb-2">ë¹„ë°€ ì£¼ë¬¸ ëª©ë¡</div>
                    
                    <!-- ë‚˜ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ -->
                    <div id="personal-revealed-section" class="mb-3 hidden">
                        <div class="text-xs font-bold text-blue-600 mb-2 flex items-center">
                            <span class="mr-1">ğŸ‘ï¸</span>
                            <span>ë‚˜ì—ê²Œë§Œ ê³µê°œ</span>
                            <span class="ml-auto text-xs text-blue-500">(${state.personalRevealedStones ? state.personalRevealedStones.length : 0}ê°œ)</span>
                        </div>
                        <div id="personal-revealed-list" class="text-xs text-blue-700 space-y-1 bg-blue-50 p-2 rounded"></div>
                    </div>
                    
                    <!-- ìƒëŒ€ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ -->
                    <div id="opponent-personal-revealed-section" class="mb-3 hidden">
                        <div class="text-xs font-bold text-orange-600 mb-2 flex items-center">
                            <span class="mr-1">ğŸ‘¤</span>
                            <span>ìƒëŒ€ì—ê²Œë§Œ ê³µê°œ</span>
                            <span class="ml-auto text-xs text-orange-500">(${state.opponentPersonalRevealedStones ? state.opponentPersonalRevealedStones.length : 0}ê°œ)</span>
                        </div>
                        <div id="opponent-personal-revealed-list" class="text-xs text-orange-700 space-y-1 bg-orange-50 p-2 rounded"></div>
                    </div>
                    
                    <!-- ì „ì²´ ê³µê°œëœ ì£¼ë¬¸ -->
                    <div id="publicly-revealed-section" class="mb-3 hidden">
                        <div class="text-xs font-bold text-green-600 mb-2 flex items-center">
                            <span class="mr-1">ğŸŒ</span>
                            <span>ì „ì²´ ê³µê°œ</span>
                            <span class="ml-auto text-xs text-green-500">(${state.publiclyRevealedSecretStones ? state.publiclyRevealedSecretStones.length : 0}ê°œ)</span>
                        </div>
                        <div id="publicly-revealed-list" class="text-xs text-green-700 space-y-1 bg-green-50 p-2 rounded"></div>
                    </div>
                    
                    <!-- ë¹„ë°€ ì£¼ë¬¸ -->
                    <div id="secret-stones-section">
                        <div class="text-xs font-bold text-gray-600 mb-2 flex items-center">
                            <span class="mr-1">ğŸ”’</span>
                            <span>ë¹„ë°€ ì£¼ë¬¸</span>
                            <span class="ml-auto text-xs text-gray-500">(${state.secretStones ? state.secretStones.length : 0}ê°œ)</span>
                        </div>
                        <div id="secret-stones-list" class="text-xs text-gray-700 space-y-1 bg-gray-50 p-2 rounded"></div>
                    </div>
                </div>
            </div>
            <div class="flex-grow mx-4">
                <div id="game-log" class="game-log p-2 rounded-lg overflow-y-auto flex flex-col-reverse relative z-0"></div>
            </div>
            <div id="used-stones-pile" class="flex flex-col items-center space-y-1 card-pile relative z-20">
                <div class="card card-back flex flex-col items-center justify-center"
                     ontouchstart="startLongPress('used')" ontouchend="hideTooltips()" 
                     onmousedown="startLongPress('used')" onmouseup="hideTooltips()" onmouseleave="hideTooltips()"
                     onmouseenter="showUsedStonesTooltip()" onmouseleave="hideTooltips()">
                    <div class="text-2xl mb-1">ğŸ—‘ï¸</div>
                    <div class="text-sm font-bold">X</div>
                </div>
                <div class="font-bold">ì‚¬ìš©í•œ ì£¼ë¬¸</div>
                <div id="used-stones-count" class="text-lg"></div>
                
                <!-- ì‚¬ìš©í•œ ì£¼ë¬¸ ë§í’ì„  íŒì—… -->
                <div id="used-stones-tooltip" class="absolute left-0 top-0 transform -translate-x-full mr-12 bg-white border border-gray-200 rounded-lg p-3 shadow-lg hidden z-[60] min-w-[200px] max-w-[300px]">
                    <div class="text-center font-bold mb-2 text-sm text-gray-800">ì‚¬ìš©í•œ ì£¼ë¬¸ ëª©ë¡</div>
                    <div id="used-stones-list" class="text-xs text-gray-700 space-y-1"></div>
                </div>
            </div>
        </div>

        <!-- ë‚´ ì˜ì—­ (í•­ìƒ í•˜ë‹¨) -->
        <div id="my-area" class="p-4 border-2 border-blue-400 rounded-lg transition-all duration-500 relative">
            <div id="my-hand" class="flex justify-center space-x-2 mb-4"></div>
            <div class="flex justify-between items-center">
                <div id="my-health" class="flex items-center space-x-1 text-2xl"></div>
                <h2 id="my-title" class="text-xl font-bold text-blue-300">ë‚˜</h2>
            </div>
            <div id="my-turn-indicator" class="turn-indicator hidden">ë‚´ í„´!</div>
        </div>

        <!-- ì»¨íŠ¸ë¡¤ ì˜ì—­ -->
        <div class="p-4 bg-black bg-opacity-20 rounded-lg">
            <div id="spell-buttons" class="relative mb-4">
                <!-- ê²Œì´ì§€ë°” ë°°ê²½ -->
                <div class="absolute inset-0 bg-gray-800 bg-opacity-30 rounded-lg border border-gray-600"></div>
                
                <!-- ê²Œì´ì§€ë°” -->
                <div id="turn-gauge" class="absolute inset-0 rounded-lg overflow-hidden">
                    <div id="blue-gauge" class="absolute left-0 top-0 h-full bg-blue-500 bg-opacity-30 transition-all duration-50 ease-out" style="width: 0%"></div>
                    <div id="red-gauge" class="absolute right-0 top-0 h-full bg-red-500 bg-opacity-30 transition-all duration-50 ease-out" style="width: 0%"></div>
                </div>
                
                <!-- ì˜ì°½ ë²„íŠ¼ë“¤ -->
                <div id="spell-buttons-container" class="relative grid grid-cols-6 gap-2 p-4"></div>
            </div>
            <div id="memo-buttons" class="grid grid-cols-6 gap-2 mb-4"></div>
            <button id="end-turn-btn" class="w-full py-3 rounded-lg font-bold text-lg btn-primary">í„´ ì¢…ë£Œ</button>
        </div>
        
        <!-- í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ -->
        <div class="flex justify-between items-center p-2">
            <button id="surrender-btn" class="px-6 py-2 rounded-lg font-bold btn-secondary text-sm whitespace-nowrap">ë„ë§</button>
            
            <div class="relative">
                <button id="help-btn" class="px-6 py-2 rounded-lg font-bold btn-secondary text-sm whitespace-nowrap min-w-[100px]" 
                        onmousedown="showHelpTooltip()" onmouseup="hideHelpTooltip()" onmouseleave="hideHelpTooltip()"
                        ontouchstart="showHelpTooltip()" ontouchend="hideHelpTooltip()">ğŸ“ ê²Œì„ ê·œì¹™</button>
                <div id="help-tooltip" class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 p-4 bg-white border border-gray-200 rounded-lg text-sm w-80 hidden z-50 shadow-lg">
                    <div class="text-center font-bold mb-3 text-base text-gray-800">ê²Œì„ ê·œì¹™</div>
                    <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                        <li>ìƒëŒ€ì˜ ë§ˆë²• ì£¼ë¬¸ì„ ë³´ê³ , ë³´ì´ì§€ ì•ŠëŠ” ìì‹ ì˜ ì£¼ë¬¸ì„ ì¶”ì¸¡í•´ ì˜ì°½í•˜ì„¸ìš”.</li>
                        <li>ì˜ì°½ì— ì„±ê³µí•˜ë©´ ì¶”ê°€ë¡œ ê°™ê±°ë‚˜, ë” ë†’ì€ ìˆ«ìì˜ ì˜ì°½ì„ ì‹œì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li>ì˜ì°½ì— ì‹¤íŒ¨í•˜ë©´ ì²´ë ¥ì´ 1 ê°ì†Œí•˜ê³  í„´ì´ ì¢…ë£Œë©ë‹ˆë‹¤.</li>
                        <li>ìƒëŒ€ì˜ ì²´ë ¥ì„ 0ìœ¼ë¡œ ë§Œë“¤ê±°ë‚˜, ë‚´ ë§ˆë²• ì£¼ë¬¸ì„ ëª¨ë‘ ì‚¬ìš©í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤!</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- ë””ë²„ê·¸ íŒ¨ë„ (ê°œë°œììš©) -->
        <div id="debug-panel" class="p-4 bg-red-900 bg-opacity-20 rounded-lg border border-red-400 hidden">
            <h3 class="text-lg font-bold text-red-300 mb-2">ğŸ”§ ë””ë²„ê·¸ íŒ¨ë„</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                <button id="debug-show-state" class="px-2 py-1 bg-blue-600 rounded text-white">ê²Œì„ ìƒíƒœ ì¶œë ¥</button>
                <button id="debug-show-player-hand" class="px-2 py-1 bg-green-600 rounded text-white">í”Œë ˆì´ì–´ ì†íŒ¨ ë³´ê¸°</button>
                <button id="debug-show-ai-hand" class="px-2 py-1 bg-yellow-600 rounded text-white">AI ì†íŒ¨ ë³´ê¸°</button>
                <button id="debug-reset-game" class="px-2 py-1 bg-red-600 rounded text-white">ê²Œì„ ë¦¬ì…‹</button>
                <button id="debug-player-win" class="px-2 py-1 bg-purple-600 rounded text-white">í”Œë ˆì´ì–´ ìŠ¹ë¦¬</button>
                <button id="debug-ai-win" class="px-2 py-1 bg-orange-600 rounded text-white">AI ìŠ¹ë¦¬</button>
                <button id="debug-add-player-health" class="px-2 py-1 bg-green-600 rounded text-white">í”Œë ˆì´ì–´ ì²´ë ¥ +1</button>
                <button id="debug-add-ai-health" class="px-2 py-1 bg-yellow-600 rounded text-white">AI ì²´ë ¥ +1</button>
            </div>
            <div id="debug-info" class="mt-2 p-2 bg-black bg-opacity-30 rounded text-xs font-mono"></div>
        </div>
    </div>

    <!-- ëª¨ë‹¬ -->
    <div id="modal" class="fixed inset-0 items-center justify-center hidden modal-bg z-50">
        <div class="modal-content p-8 rounded-lg text-center max-w-lg w-full">
            <h3 id="modal-title" class="text-2xl font-bold mb-4"></h3>
            <div id="modal-body" class="mb-6"></div>
            <button id="modal-close-btn" class="px-6 py-2 rounded-lg btn-primary">í™•ì¸</button>
        </div>
    </div>
    
    <!-- í† ìŠ¤íŠ¸ ë©”ì‹œì§€ -->
    <div id="toast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
        <span id="toast-message"></span>
    </div>
    
    <!-- ë§¤ì¹­ ëª¨ë‹¬ -->
    <div id="matching-modal" class="fixed inset-0 flex items-center justify-center hidden modal-bg z-50">
        <div class="modal-content p-8 rounded-lg text-center max-w-md w-full mx-4">
            <div class="text-4xl mb-4">ğŸ”</div>
                            <h3 class="text-xl font-bold mb-4">ê²°íˆ¬ ìƒëŒ€ë¥¼ ë§¤ì¹­ ì¤‘ì…ë‹ˆë‹¤</h3>
            <div class="flex justify-center space-x-2 mb-6">
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
            </div>
            <p class="text-sm text-gray-300 mb-4" id="matching-message">ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘ì…ë‹ˆë‹¤...</p>
            <p class="text-xs text-gray-400 mb-4">ì„œë²„ ì—°ê²°ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <button id="cancel-matching-btn" class="px-6 py-2 rounded-lg btn-primary">ë§¤ì¹­ ì·¨ì†Œ</button>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // ì‚¬ìš´ë“œ íš¨ê³¼ (Web Audio API ì‚¬ìš©)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // AudioContext í™œì„±í™” í•¨ìˆ˜
        function activateAudioContext() {
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('ğŸ”Š AudioContext í™œì„±í™” ì™„ë£Œ');
                }).catch(err => {
                    console.error('âŒ AudioContext í™œì„±í™” ì‹¤íŒ¨:', err);
                });
            }
        }
        
        // ì‚¬ìš´ë“œ ì„¤ì • ê°ì²´
        const SOUNDS = {
            card: { freq: 150, dur: 0.1, type: 'square', sequence: [[200, 0.1, 'square', 50]] },
            success: { freq: 523.25, dur: 0.2, type: 'sine', sequence: [
                [659.25, 0.2, 'sine', 100], [783.99, 0.3, 'sine', 200]
            ]},
            failure: { freq: 220, dur: 0.3, type: 'sawtooth', sequence: [
                [196, 0.3, 'sawtooth', 150]
            ]},
            damage: { freq: 100, dur: 0.2, type: 'square', sequence: [
                [80, 0.2, 'square', 100], [60, 0.3, 'square', 200]
            ]},
            heal: { freq: 660, dur: 0.2, type: 'triangle', sequence: [
                [880, 0.2, 'triangle', 100], [1108.73, 0.3, 'triangle', 200]
            ]},
            gameStart: { freq: 523.25, dur: 0.15, type: 'sine', sequence: [
                [659.25, 0.15, 'sine', 50], [783.99, 0.2, 'sine', 150], [1046.50, 0.3, 'sine', 300], [1318.51, 0.4, 'sine', 500]
            ]},
            gameWin: { freq: 523.25, dur: 0.3, type: 'sine', sequence: [
                [659.25, 0.3, 'sine', 200], [783.99, 0.3, 'sine', 400], [1046.50, 0.4, 'sine', 600]
            ]},
            gameLose: { freq: 220, dur: 0.4, type: 'sawtooth', sequence: [
                [196, 0.4, 'sawtooth', 300], [174.61, 0.5, 'sawtooth', 600]
            ]}
        };
        
        function playSound(frequency, duration, type = 'sine') {
            // AudioContextê°€ ì¼ì‹œ ì¤‘ë‹¨ ìƒíƒœë©´ í™œì„±í™” ì‹œë„
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('ğŸ”Š AudioContext í™œì„±í™”ë¨ - ì‚¬ìš´ë“œ ì¬ìƒ');
                    playSoundInternal(frequency, duration, type);
                }).catch(err => {
                    console.error('âŒ AudioContext í™œì„±í™” ì‹¤íŒ¨:', err);
                });
            } else {
                playSoundInternal(frequency, duration, type);
            }
        }
        
        function playSoundInternal(frequency, duration, type = 'sine') {
            try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
                
                console.log(`ğŸ”Š ì‚¬ìš´ë“œ ì¬ìƒ: ${frequency}Hz, ${duration}s, ${type}`);
            } catch (error) {
                console.error('âŒ ì‚¬ìš´ë“œ ì¬ìƒ ì‹¤íŒ¨:', error);
            }
        }
        
        function playSoundEffect(type) {
            console.log(`ğŸµ íš¨ê³¼ìŒ ì¬ìƒ ì‹œë„: ${type}`);
            const sound = SOUNDS[type];
            if (!sound) {
                console.error(`âŒ ì•Œ ìˆ˜ ì—†ëŠ” íš¨ê³¼ìŒ íƒ€ì…: ${type}`);
                return;
            }
            
            console.log(`ğŸµ íš¨ê³¼ìŒ ì •ë³´:`, sound);
            playSound(sound.freq, sound.dur, sound.type);
            
            // ì‹œí€€ìŠ¤ ì‚¬ìš´ë“œ ì¬ìƒ
            sound.sequence?.forEach(([freq, dur, type, delay], index) => {
                console.log(`ğŸµ ì‹œí€€ìŠ¤ ${index + 1}: ${freq}Hz, ${dur}s, ${type}, ${delay}ms í›„`);
                setTimeout(() => playSound(freq, dur, type), delay);
            });
        }
        
        // ê¸°ì¡´ í•¨ìˆ˜ëª… í˜¸í™˜ì„± ìœ ì§€
        const playCardSound = () => playSoundEffect('card');
        const playSuccessSound = () => playSoundEffect('success');
        const playFailureSound = () => playSoundEffect('failure');
        const playDamageSound = () => playSoundEffect('damage');
        const playHealSound = () => playSoundEffect('heal');
        const playGameStartSound = () => playSoundEffect('gameStart');
        const playGameOverSound = (isWin) => playSoundEffect(isWin ? 'gameWin' : 'gameLose');

        /**
         * DOM ìš”ì†Œ ìºì‹œ ë° ê´€ë¦¬ ì‹œìŠ¤í…œ
         * ì„±ëŠ¥ í–¥ìƒê³¼ ì½”ë“œ ê°€ë…ì„±ì„ ìœ„í•œ DOM ì ‘ê·¼ ìµœì í™”
         */
        const DOM = {
            elements: {},
            
            /**
             * DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° (ìºì‹œ í™œìš©)
             * @param {string} id - ìš”ì†Œ ID
             * @returns {HTMLElement|null} DOM ìš”ì†Œ
             */
            get(id) {
                if (!this.elements[id]) {
                    this.elements[id] = document.getElementById(id);
                }
                return this.elements[id];
            },
            
            /**
             * ì—¬ëŸ¬ DOM ìš”ì†Œë¥¼ í•œ ë²ˆì— ê°€ì ¸ì˜¤ê¸°
             * @param {string[]} ids - ìš”ì†Œ ID ë°°ì—´
             * @returns {Object} IDë³„ DOM ìš”ì†Œ ê°ì²´
             */
            getMultiple(ids) {
                const elements = {};
                ids.forEach(id => {
                    elements[id] = this.get(id);
                });
                return elements;
            },
            
            /**
             * ìì£¼ ì‚¬ìš©ë˜ëŠ” ìš”ì†Œë“¤ ë¯¸ë¦¬ ìºì‹œ
             * ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•œ ì´ˆê¸°í™”
             */
            init() {
                const commonElements = [
                    'title-screen', 'game-screen', 'start-game-btn',
                    'my-area', 'opponent-area', 'my-health', 'opponent-health',
                    'my-hand', 'opponent-hand', 'secret-stones-pile', 'used-stones-pile',
                    'secret-stones-count', 'used-stones-count', 'game-log',
                    'spell-buttons-container', 'end-turn-btn', 'modal',
                    'modal-title', 'modal-body', 'modal-close-btn',
                    'debug-panel', 'debug-info', 'memo-buttons', 'my-title',
                    'help-tooltip', 'matching-modal', 'matching-message',
                    'ai-difficulty-modal', 'toast', 'toast-message',
                    'player-name-input', 'save-name-btn', 'name-save-status',
                    'my-turn-indicator', 'opponent-turn-indicator',
                    'ai-trophy-count', 'multiplayer-trophy-count'
                ];
                
                commonElements.forEach(id => this.get(id));
                // DOM ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ
            }
        };

        // DOM ìš”ì†Œ (ê¸°ì¡´ ë³€ìˆ˜ëª… í˜¸í™˜ì„± ìœ ì§€)
        const titleScreen = DOM.get('title-screen');
        const gameScreen = DOM.get('game-screen');
        const startGameBtn = DOM.get('start-game-btn');
        const myArea = DOM.get('my-area');
        const opponentArea = DOM.get('opponent-area');
        const myHealthEl = DOM.get('my-health');
        const opponentHealthEl = DOM.get('opponent-health');
        const myHandEl = DOM.get('my-hand');
        const opponentHandEl = DOM.get('opponent-hand');
        const secretStonesPile = DOM.get('secret-stones-pile');
        const usedStonesPile = DOM.get('used-stones-pile');
        const secretStonesCountEl = DOM.get('secret-stones-count');
        const usedStonesCountEl = DOM.get('used-stones-count');
        const gameLogEl = DOM.get('game-log');
        const spellButtonsContainer = DOM.get('spell-buttons-container');
        const endTurnBtn = DOM.get('end-turn-btn');
        const modal = DOM.get('modal');
        const modalTitle = DOM.get('modal-title');
        const modalBody = DOM.get('modal-body');
        const modalCloseBtn = DOM.get('modal-close-btn');
        
        // ë””ë²„ê·¸ íŒ¨ë„ ìš”ì†Œë“¤
        const debugPanel = DOM.get('debug-panel');
        const debugInfo = DOM.get('debug-info');



        /**
         * ê²Œì„ ìƒíƒœ ê´€ë¦¬
         */
        let state = {};
        let previousMyHealth = 4; // ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
        let previousOpponentHealth = 4; // ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
        
        // í„´ íƒ€ì´ë¨¸ ê´€ë ¨ ë³€ìˆ˜
        let turnTimer = null;
        let turnTimeLeft = 30; // ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
        let TURN_DURATION = 30; // ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
        
        // ì—°ìŠ¹ ê´€ë ¨ ë³€ìˆ˜
        let currentWinStreak = parseInt(localStorage.getItem('currentWinStreak')) || 0;
        let maxWinStreak = parseInt(localStorage.getItem('maxWinStreak')) || 0;
        
        // ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™” ìƒíƒœ
        let spellButtonsDisabled = false;
        
        // ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™” í•¨ìˆ˜
        function disableSpellButtons() {
            spellButtonsDisabled = true;
            const spellButtons = spellButtonsContainer.querySelectorAll('button');
            spellButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
            // ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™”ë¨
        }
        
        // ì£¼ë¬¸ ë²„íŠ¼ í™œì„±í™” í•¨ìˆ˜
        function enableSpellButtons() {
            spellButtonsDisabled = false;
            const spellButtons = spellButtonsContainer.querySelectorAll('button');
            spellButtons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            });
            // ì£¼ë¬¸ ë²„íŠ¼ í™œì„±í™”ë¨
        }
        
        // ë””ë²„ê·¸: ë³€ìˆ˜ ì´ˆê¸°í™” í™•ì¸
        // ë³€ìˆ˜ ì´ˆê¸°í™” ì™„ë£Œ

        /**
         * ê²Œì„ ì„¤ì • ì´ˆê¸°í™” í•¨ìˆ˜
         * GAME_CONFIGê°€ ì •ì˜ëœ í›„ í˜¸ì¶œë˜ì–´ì•¼ í•¨
         */
        function initializeGameConfig() {
            if (typeof GAME_CONFIG !== 'undefined') {
                previousMyHealth = GAME_CONFIG.maxHealth;
                previousOpponentHealth = GAME_CONFIG.maxHealth;
                turnTimeLeft = GAME_CONFIG.turnDuration.normal;
                TURN_DURATION = GAME_CONFIG.turnDuration.normal;
            }
        }

        // AI ë‚œì´ë„ë³„ ì‹œê°„ ì œí•œ ì„¤ì •
        function setTurnDurationByDifficulty() {
            if (multiplayerMode) {
                TURN_DURATION = GAME_CONFIG.turnDuration.multiplayer;
            } else {
                TURN_DURATION = GAME_CONFIG.turnDuration[aiDifficulty] || GAME_CONFIG.turnDuration.normal;
            }
            console.log(`â° AI ë‚œì´ë„: ${aiDifficulty}, ì‹œê°„ ì œí•œ: ${TURN_DURATION === Infinity ? 'ë¬´ì œí•œ' : TURN_DURATION + 'ì´ˆ'}`);
        }

        // í„´ íƒ€ì´ë¨¸ ê´€ë ¨ í•¨ìˆ˜ë“¤
        function startTurnTimer() {
            if (turnTimer) {
                clearInterval(turnTimer);
            }
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ íƒ€ì´ë¨¸ ì‹œì‘ ì¤‘ë‹¨
            if (!state || !state.players || state.players.length < 2) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ íƒ€ì´ë¨¸ ì‹œì‘ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            // AI ë‚œì´ë„ë³„ ì‹œê°„ ì œí•œ ì„¤ì •
            setTurnDurationByDifficulty();
            console.log(`â° ì‹œê°„ ì œí•œ ì„¤ì • ì™„ë£Œ - TURN_DURATION: ${TURN_DURATION}ì´ˆ`);
            
            // ì‹œê°„ ì œí•œì´ ì—†ìœ¼ë©´ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•˜ì§€ ì•ŠìŒ
            if (TURN_DURATION === Infinity) {
                console.log('â° ì‹œê°„ ì œí•œ ì—†ìŒ - íƒ€ì´ë¨¸ ë¹„í™œì„±í™”');
                updateTurnGauge(); // ê²Œì´ì§€ ì´ˆê¸°í™”ë§Œ
                return;
            }
            
            turnTimeLeft = TURN_DURATION;
            
            // ì²« í„´ ì‹œì‘ ì‹œ ê²Œì´ì§€ë¥¼ ì¦‰ì‹œ í‘œì‹œ
            updateTurnGauge();
            
            console.log(`â° íƒ€ì´ë¨¸ ì‹œì‘ - í˜„ì¬í”Œë ˆì´ì–´: ${state.currentPlayerId}, ë‚´í„´: ${state.isPlayerTurn}, ì œí•œì‹œê°„: ${TURN_DURATION}ì´ˆ, ë‚¨ì€ì‹œê°„: ${turnTimeLeft}ì´ˆ`);
            
            // ë” ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´ 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
            turnTimer = setInterval(() => {
                turnTimeLeft -= 0.1; // 0.1ì´ˆì”© ê°ì†Œ
                updateTurnGauge();
                
                if (turnTimeLeft <= 0) {
                    clearInterval(turnTimer);
                    turnTimer = null;
                    console.log('â° í„´ ì‹œê°„ ì´ˆê³¼! ìë™ í„´ ì¢…ë£Œ');
                    addLog(Messages.timeOut());
                    endTurn();
                }
            }, 100); // 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
        }
        
        function stopTurnTimer() {
            if (turnTimer) {
                clearInterval(turnTimer);
                turnTimer = null;
            }
        }
        
        function resetTurnTimer() {
            if (turnTimer) {
                clearInterval(turnTimer);
                turnTimer = null;
            }
            turnTimeLeft = TURN_DURATION;
            updateTurnGauge();
            console.log('â° íƒ€ì´ë¨¸ ì´ˆê¸°í™” ì™„ë£Œ');
            
            // ìƒˆë¡œìš´ íƒ€ì´ë¨¸ ì‹œì‘
            if (TURN_DURATION !== Infinity) {
                turnTimer = setInterval(() => {
                    turnTimeLeft -= 0.1; // 0.1ì´ˆì”© ê°ì†Œ
                    updateTurnGauge();
                    
                    if (turnTimeLeft <= 0) {
                        clearInterval(turnTimer);
                        turnTimer = null;
                        console.log('â° í„´ ì‹œê°„ ì´ˆê³¼! ìë™ í„´ ì¢…ë£Œ');
                        addLog(Messages.timeOut());
                        endTurn();
                    }
                }, 100); // 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
            }
        }
        
        function resetTurnGauge() {
            const blueGauge = DOM.get('blue-gauge');
            const redGauge = DOM.get('red-gauge');
            
            if (blueGauge && redGauge) {
                blueGauge.style.width = '0%';
                redGauge.style.width = '0%';
                console.log('ğŸ”„ ê²Œì´ì§€ ì´ˆê¸°í™” ì™„ë£Œ');
            }
        }
        
        function updateTurnGauge() {
            const blueGauge = DOM.get('blue-gauge');
            const redGauge = DOM.get('red-gauge');
            
            if (!blueGauge || !redGauge) return;
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ê²Œì´ì§€ ì´ˆê¸°í™”ë§Œ
            if (!state || !state.players || state.players.length < 2) {
                blueGauge.style.width = '0%';
                redGauge.style.width = '0%';
                return;
            }
            
            // ì‹œê°„ ì œí•œì´ ì—†ìœ¼ë©´ ê²Œì´ì§€ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ
            if (TURN_DURATION === Infinity) {
                blueGauge.style.width = '0%';
                redGauge.style.width = '0%';
                return;
            }
            
            // ì²« í„´ ì‹œì‘ ì‹œì—ë„ ê²Œì´ì§€ê°€ í‘œì‹œë˜ë„ë¡ ìˆ˜ì •
            let progress;
            if (turnTimeLeft === TURN_DURATION) {
                // ì²« í„´ ì‹œì‘ ì‹œ - ê²Œì´ì§€ê°€ 0%ì—ì„œ ì‹œì‘í•˜ë„ë¡
                progress = 0;
            } else {
                progress = turnTimeLeft >= 0 ? (TURN_DURATION - turnTimeLeft) / TURN_DURATION : 0;
            }
            const gaugeWidth = Math.min(progress * 100, 100);
            
            // ë””ë²„ê·¸: ê²Œì´ì§€ ê³„ì‚° ë¡œê·¸ (ì²« í„´ ì‹œì‘ ì‹œì—ë§Œ)
            if (turnTimeLeft === TURN_DURATION) {
                console.log(`ğŸ¯ ì²« í„´ ê²Œì´ì§€ ê³„ì‚° - TURN_DURATION: ${TURN_DURATION}, turnTimeLeft: ${turnTimeLeft}, progress: ${progress}, gaugeWidth: ${gaugeWidth}%`);
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ë‚´ í„´ì¸ì§€ í™•ì¸
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const isMyTurn = (state.currentPlayerId === myPlayerId);
            
            // AI ëª¨ë“œì—ì„œëŠ” í”Œë ˆì´ì–´ 1ì´ í•­ìƒ ë‚´ í„´
            if (multiplayerMode) {
                if (isMyTurn) {
                    // ë‚´ í„´ - íŒŒë€ìƒ‰ ê²Œì´ì§€ (ì™¼ìª½ë¶€í„°)
                    blueGauge.style.width = `${gaugeWidth}%`;
                    redGauge.style.width = '0%';
                } else {
                    // ìƒëŒ€ í„´ - ë¹¨ê°„ìƒ‰ ê²Œì´ì§€ (ì˜¤ë¥¸ìª½ë¶€í„°)
                    blueGauge.style.width = '0%';
                    redGauge.style.width = `${gaugeWidth}%`;
                }
            } else {
                // AI ëª¨ë“œ
                if (state.currentPlayerId === 1) {
                    // ë‚´ í„´ - íŒŒë€ìƒ‰ ê²Œì´ì§€ (ì™¼ìª½ë¶€í„°)
                    blueGauge.style.width = `${gaugeWidth}%`;
                    redGauge.style.width = '0%';
                } else {
                    // AI í„´ - ë¹¨ê°„ìƒ‰ ê²Œì´ì§€ (ì˜¤ë¥¸ìª½ë¶€í„°)
                    blueGauge.style.width = '0%';
                    redGauge.style.width = `${gaugeWidth}%`;
                }
            }
        }
        
        // ì‹œê°ì  í”¼ë“œë°± í•¨ìˆ˜ë“¤
        function showDamageEffect(element, amount) {
            const damageEl = document.createElement('div');
            damageEl.className = 'card-damage';
            damageEl.textContent = `-${amount}`;
            element.appendChild(damageEl);
            
            setTimeout(() => {
                element.removeChild(damageEl);
            }, 1000);
        }
        
        // íŒŒí‹°í´ íš¨ê³¼ ìƒì„± í•¨ìˆ˜
        function createSpellParticles(spellNumber, element) {
            const spellIcon = getSpellIcon(spellNumber);
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // íŒŒí‹°í´ ê°œìˆ˜ (8-12ê°œ)
            const particleCount = Math.floor(Math.random() * 5) + 8;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = spellIcon;
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                
                // ëœë¤ ë°©í–¥ê³¼ ê±°ë¦¬
                const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
                const distance = 80 + Math.random() * 40;
                const x = Math.cos(angle) * distance;
                const y = Math.sin(angle) * distance;
                
                particle.style.setProperty('--x', x + 'px');
                particle.style.setProperty('--y', y + 'px');
                
                // ëœë¤ ìƒ‰ìƒ ë³€í™”
                const hue = Math.random() * 60 + 30; // ë…¸ë€ìƒ‰-ì£¼í™©ìƒ‰ ë²”ìœ„
                particle.style.filter = `hue-rotate(${hue}deg) brightness(1.2)`;
                
                document.body.appendChild(particle);
                
                // íŒŒí‹°í´ ì œê±°
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 1000);
            }
            
            console.log(`ğŸ† íŒŒí‹°í´ íš¨ê³¼ ìƒì„±: ${spellIcon} (${particleCount}ê°œ)`);
        }
        
        // í™”ë©´ ì „ì²´ì— ëœë¤ íŒŒí‹°í´ íš¨ê³¼ ìƒì„± í•¨ìˆ˜
        function createModalParticles(spellNumber) {
            const spellIcon = getSpellIcon(spellNumber);
            
            // í™”ë©´ í¬ê¸° ê°€ì ¸ì˜¤ê¸° (ìŠ¤í¬ë¡¤ë°” ê³ ë ¤)
            const screenWidth = window.innerWidth || document.documentElement.clientWidth;
            const screenHeight = window.innerHeight || document.documentElement.clientHeight;
            
            // íŒŒí‹°í´ ê°œìˆ˜ (15-20ê°œë¡œ ì¦ê°€)
            const particleCount = Math.floor(Math.random() * 6) + 15;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = spellIcon;
                
                // í™”ë©´ ì „ì²´ì—ì„œ ëœë¤í•œ ì‹œì‘ ìœ„ì¹˜ (ì•ˆì „í•œ ë²”ìœ„ ë‚´ì—ì„œ)
                const safeMargin = 50; // í™”ë©´ ê°€ì¥ìë¦¬ì—ì„œ 50px ì—¬ìœ  ê³µê°„
                const startX = safeMargin + Math.random() * (screenWidth - 2 * safeMargin);
                const startY = safeMargin + Math.random() * (screenHeight - 2 * safeMargin);
                
                particle.style.left = startX + 'px';
                particle.style.top = startY + 'px';
                particle.style.zIndex = '9999'; // ìµœìƒìœ„ ë ˆì´ì–´
                
                // ëœë¤í•œ ë°©í–¥ìœ¼ë¡œ í„°ì§€ë„ë¡ ì„¤ì •
                const angle = Math.random() * Math.PI * 2;
                const distance = 100 + Math.random() * 150; // ë‹¤ì–‘í•œ ê±°ë¦¬ë¡œ í„°ì§
                const x = Math.cos(angle) * distance;
                const y = Math.sin(angle) * distance;
                
                particle.style.setProperty('--x', x + 'px');
                particle.style.setProperty('--y', y + 'px');
                
                // ì›ë˜ ì•„ì´ì½˜ ìƒ‰ìƒê³¼ ë°ê¸° ê·¸ëŒ€ë¡œ ì‚¬ìš©
                // ëœë¤í•œ í¬ê¸° ë³€í™”
                const scale = 0.8 + Math.random() * 0.4;
                particle.style.fontSize = (1.5 * scale) + 'rem';
                
                document.body.appendChild(particle);
                
                // íŒŒí‹°í´ ì œê±° (ì‹œê°„ì„ 2ì´ˆë¡œ ì—°ì¥)
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 2000);
            }
            
            console.log(`ğŸ† í™”ë©´ ì „ì²´ íŒŒí‹°í´ íš¨ê³¼ ìƒì„±: ${spellIcon} (${particleCount}ê°œ)`);
        }
        
        function showHealEffect(element, amount) {
            const healEl = document.createElement('div');
            healEl.className = 'card-heal';
            healEl.textContent = `+${amount}`;
            element.appendChild(healEl);
            
            setTimeout(() => {
                element.removeChild(healEl);
            }, 1000);
        }
        
        function addSuccessAnimation(element) {
            element.classList.add('success-animation');
            setTimeout(() => {
                element.classList.remove('success-animation');
            }, 500);
        }
        
        function addFailureAnimation(element) {
            element.classList.add('failure-animation');
            setTimeout(() => {
                element.classList.remove('failure-animation');
            }, 500);
        }





        // ë””ë²„ê·¸ íŒ¨ë„ í† ê¸€ (Ctrl+D)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                debugPanel.classList.toggle('hidden');
                console.log('ğŸ”§ ë””ë²„ê·¸ íŒ¨ë„ í† ê¸€ë¨');
            }
        });

        // ì¹˜íŠ¸: ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” (Ctrl+Alt+P)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.altKey && e.key === 'p') {
                e.preventDefault();
                if (confirm('ì •ë§ ëª¨ë“  ì„œë²„ì˜ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    console.log('ğŸ§¹ ì¹˜íŠ¸: ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ìš”ì²­');
                    if (socket) {
                        socket.emit('resetAllServerData');
                    }
                }
            }
        });

        // ëœë¤ ì´ë¦„ ìƒì„± í•¨ìˆ˜
        function generateRandomName() {
            const alphabetChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const numericChars = '0123456789';
            let randomName = '';
            
            // ì•ŒíŒŒë²³ 3ê°œ ìƒì„±
            for (let charIndex = 0; charIndex < 3; charIndex++) {
                randomName += alphabetChars.charAt(Math.floor(Math.random() * alphabetChars.length));
            }
            
            // ìˆ«ì 3ê°œ ìƒì„±
            for (let charIndex = 0; charIndex < 3; charIndex++) {
                randomName += numericChars.charAt(Math.floor(Math.random() * numericChars.length));
            }
            
            return randomName;
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ê¸°ë³¸ ì´ë¦„ ì„¤ì •
        function initializePlayerName() {
            let playerName = localStorage.getItem('playerName');
            
            // ì´ë¦„ì´ ì—†ìœ¼ë©´ ëœë¤ ì´ë¦„ ìƒì„±
            if (!playerName) {
                playerName = generateRandomName();
                localStorage.setItem('playerName', playerName);
                console.log(`ğŸ² ëœë¤ ì´ë¦„ ìƒì„±: ${playerName}`);
            }
            
            return playerName;
        }

        // ì¹˜íŠ¸: ìì‹ ì˜ ë°ì´í„°ë§Œ ì´ˆê¸°í™” (Ctrl+P)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && !e.shiftKey && e.key === 'p') {
                e.preventDefault();
                const playerName = localStorage.getItem('playerName') || 'Player';
                if (confirm('ì •ë§ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    console.log('ğŸ§¹ ì¹˜íŠ¸: ê°œì¸ ë°ì´í„° ì´ˆê¸°í™” ìš”ì²­');
                    if (socket) {
                        socket.emit('resetMyData', { playerName: playerName });
                    }
                }
            }
        });
        
        // ë©”ëª¨ íŒ¨ë„ í† ê¸€ (M í‚¤) - ë¹„í™œì„±í™” (í•­ìƒ í‘œì‹œ)
        // document.addEventListener('keydown', (e) => {
        //     if (e.key.toLowerCase() === 'm' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
        //         e.preventDefault();
        //         if (!state.isGameOver && state.isPlayerTurn) {
        //             toggleMemoPanel();
        //         }
        //     }
        // });

        function initGame() {
            console.log('ğŸ® ê²Œì„ ì´ˆê¸°í™” ì‹œì‘');
            
            // ì—°ìŠ¹ ë³€ìˆ˜ ì´ˆê¸°í™” (ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ)
            currentWinStreak = parseInt(localStorage.getItem('currentWinStreak')) || 0;
            maxWinStreak = parseInt(localStorage.getItem('maxWinStreak')) || 0;
            console.log(`ğŸ“Š ì—°ìŠ¹ ì´ˆê¸°í™”: í˜„ì¬ ${currentWinStreak}ì—°ìŠ¹, ìµœê³  ${maxWinStreak}ì—°ìŠ¹`);
            
            // ë­í‚¹ ì´ˆê¸°í™” (ê²Œì„ ì‹œì‘ ì‹œ í”Œë ˆì´ì–´ë¥¼ ë­í‚¹ì— ë“±ë¡)
            const playerName = localStorage.getItem('playerName') || 'Player';
            const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
            const trophies = TrophySystem.loadTrophies();
            
            if (socket) {
                // ëª¨ì˜ ê²°íˆ¬ ì ìˆ˜ ë“±ë¡
                socket.emit('updateRanking', {
                    category: 'mock',
                    playerName: playerName,
                    score: trophies.ai,
                    icon: playerIcon
                });
                
                // ì •ì‹ ê²°íˆ¬ ì ìˆ˜ ë“±ë¡
                socket.emit('updateRanking', {
                    category: 'formal',
                    playerName: playerName,
                    score: trophies.multiplayer,
                    icon: playerIcon
                });
                
                console.log(`ğŸ“Š ë­í‚¹ ì´ˆê¸°í™”: ${playerName} (ëª¨ì˜: ${trophies.ai}ì , ì •ì‹: ${trophies.multiplayer}ì , ì•„ì´ì½˜: ${playerIcon})`);
            }
            
            let deck = [];
            for (let spellNumber = 1; spellNumber <= GAME_CONFIG.deckStructure.maxSpell; spellNumber++) {
                for (let cardCount = 0; cardCount < GAME_CONFIG.deckStructure.cardsPerSpell(spellNumber); cardCount++) {
                    deck.push(spellNumber);
                }
            }
            console.log('ğŸ“¦ ì´ˆê¸° ë± ìƒì„±:', deck);
            
            for (let currentIndex = deck.length - 1; currentIndex > 0; currentIndex--) {
                const randomIndex = Math.floor(Math.random() * (currentIndex + 1));
                [deck[currentIndex], deck[randomIndex]] = [deck[randomIndex], deck[currentIndex]];
            }
            console.log('ğŸ”„ ë± ì…”í”Œ ì™„ë£Œ');
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ì„ ê²°ì •í•˜ê³  ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
            let firstPlayer;
            if (multiplayerMode && isHost) {
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer}`);
                
                // ìƒëŒ€ë°©ì—ê²Œ ì²« ë²ˆì§¸ í„´ ì •ë³´ ì „ì†¡
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'firstTurn',
                        firstPlayer: firstPlayer
                    }));
                }
            } else if (multiplayerMode && !isHost) {
                // ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦¼
                console.log('â³ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì • ëŒ€ê¸° ì¤‘...');
                return; // í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦° í›„ ë‹¤ì‹œ í˜¸ì¶œë¨
            } else {
                // AI ëª¨ë“œì—ì„œëŠ” ëœë¤ ê²°ì •
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ AI ëª¨ë“œ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer}`);
            }
            
            const aiName = aiDifficulty === 'easy' ? 'ğŸ¤– ì‰¬ì›€ í—ˆìˆ˜ì•„ë¹„' : aiDifficulty === 'normal' ? 'ğŸ¤– ë³´í†µ í—ˆìˆ˜ì•„ë¹„' : 'ğŸ¤– ì–´ë ¤ì›€ í—ˆìˆ˜ì•„ë¹„';
            state = {
                players: [
                                    { id: 1, name: 'Player', health: GAME_CONFIG.maxHealth, hand: deck.slice(0, 6).sort((a, b) => a - b), knownSecretStones: [] },
                { id: 2, name: multiplayerMode ? 'Opponent' : aiName, health: GAME_CONFIG.maxHealth, hand: deck.slice(6, 12).sort((a, b) => a - b), knownSecretStones: [] }
                ],
                secretStones: deck.slice(12),
                usedStones: [],
                publiclyRevealedSecretStones: [], // ì „ì²´ ê³µê°œëœ ì£¼ë¬¸ (6ë²ˆ ì£¼ë¬¸)
                personalRevealedStones: [], // ë‚˜ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ (ë‚´ê°€ 1ë²ˆ ì£¼ë¬¸ ì‚¬ìš©)
                opponentPersonalRevealedStones: [], // ìƒëŒ€ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ (ìƒëŒ€ê°€ 1ë²ˆ ì£¼ë¬¸ ì‚¬ìš©)
                currentPlayerId: firstPlayer,
                lastSuccessfulSpell: 0,
                spellFailed: false, // ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì´ˆê¸°í™”
                isPlayerTurn: firstPlayer === 1,
                turnInProgress: false,
                gameLog: [`ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ${firstPlayer === 1 ? playerName : (multiplayerMode ? opponentName : aiName)}ê°€ ë¨¼ì € ì‹œì‘í•©ë‹ˆë‹¤.`],
                isGameOver: false,
            };
            
            console.log('ğŸ¯ ì´ˆê¸° ê²Œì„ ìƒíƒœ ì„¤ì • ì™„ë£Œ');
            
            createSpellButtons();
            updatePlayerName();
            render();
            updateDebugInfo();
            
            // ë©”ëª¨ íŒ¨ë„ í‘œì‹œ
            showMemoPanel();
            
            // ê²Œì„ ì‹œì‘ ì‚¬ìš´ë“œ (AI ëª¨ë“œì—ì„œë§Œ ì¬ìƒ)
            if (!multiplayerMode) {
            playGameStartSound();
            }
        }

        // ë„ë§ ì²˜ë¦¬
        async function handleSurrender(surrenderingPlayerId) {
            console.log('ğŸ³ï¸ ìƒëŒ€ë°© ë„ë§ ì²˜ë¦¬');
            
            // ìŠ¹ë¦¬ íš¨ê³¼ìŒ ì¬ìƒ
            activateAudioContext();
            playGameOverSound(true);
            
            // ìŠ¹ë¦¬ ì²˜ë¦¬ (ìƒëŒ€ë°©ì´ ë„ë§ì³¤ìœ¼ë¯€ë¡œ ë‚´ê°€ ìŠ¹ë¦¬)
            updateStats(true, true);
            
            // ìŠ¹ë¦¬ì˜ ì¦í‘œ ì¶”ê°€ (ë©€í‹°í”Œë ˆì´ì–´ ìŠ¹ë¦¬)
            TrophySystem.addVictoryTrophy('multiplayer');
            
            // ì „ì  ì—…ë°ì´íŠ¸ (ì—°ìŠ¹ ì²˜ë¦¬ í¬í•¨)
            updateStats(true, true); // ìŠ¹ë¦¬, ë©€í‹°í”Œë ˆì´ì–´
            
            // ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            if (socket && socket.connected) {
                const playerName = localStorage.getItem('playerName') || 'Player';
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                const trophies = TrophySystem.loadTrophies();
                
                socket.emit('updateRanking', {
                    category: 'formal',
                    playerName: playerName,
                    score: trophies.multiplayer,
                    icon: playerIcon
                });
                
                console.log(`ğŸ”„ ìƒëŒ€ë°© ë„ë§ í›„ ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸: ${playerName}`);
            }
            
            let message = 'ìƒëŒ€ê°€ ë„ë§ì³ì„œ ìŠ¹ë¦¬í•˜ì˜€ìŠµë‹ˆë‹¤!';
            
            // 2ì—°ìŠ¹ ì´ìƒì¼ ë•Œ ì—°ìŠ¹ ë©”ì‹œì§€ ì¶”ê°€
            if (currentWinStreak >= 2) {
                message += `\n\n${Messages.streak(currentWinStreak)}`;
            }
            
            message += '\n\nğŸ… ìŠ¹ì  +3';
            
            addLog('ìƒëŒ€ë°©ì´ ë„ë§ì³¤ìŠµë‹ˆë‹¤.');
            addLog('ìŠ¹ë¦¬ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
            state = {
                gameStarted: false,
                isGameOver: true,
                players: [],
                secretStones: [],
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: null,
                isPlayerTurn: false,
                lastSuccessfulSpell: 0,
                spellFailed: false, // ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì´ˆê¸°í™”
                turnInProgress: false,
                gameLog: []
            };
            
            // ìŠ¹ë¦¬í•œ í”Œë ˆì´ì–´ì—ê²Œ ë©”ì‹œì§€ í‘œì‹œ
            await showModal('ê²Œì„ ì¢…ë£Œ', message, true);
            
            // íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            showTitleScreen();
        }

        // ìŠ¹ë¦¬ì˜ ì¦í‘œ ì‹œìŠ¤í…œ
        const TrophySystem = {
            // ì¦í‘œ ë°ì´í„° ë¡œë“œ
            loadTrophies() {
                const aiTrophies = localStorage.getItem('aiTrophies') || '0';
                const multiplayerTrophies = localStorage.getItem('multiplayerTrophies') || '0';
                return {
                    ai: Math.max(0, parseInt(aiTrophies)),
                    multiplayer: Math.max(0, parseInt(multiplayerTrophies))
                };
            },
            
            // ì¦í‘œ ë°ì´í„° ì €ì¥
            saveTrophies(trophies) {
                localStorage.setItem('aiTrophies', trophies.ai.toString());
                localStorage.setItem('multiplayerTrophies', trophies.multiplayer.toString());
            },
            
            // ì¦í‘œ ì—…ë°ì´íŠ¸
            updateTrophy(type, change) {
                const trophies = this.loadTrophies();
                trophies[type] = Math.max(0, trophies[type] + change);
                this.saveTrophies(trophies);
                this.displayTrophies(trophies);
                return trophies[type];
            },
            
            // ì¦í‘œ í‘œì‹œ
            displayTrophies(trophies) {
                const aiCount = DOM.get('ai-trophy-count');
                const multiplayerCount = DOM.get('multiplayer-trophy-count');
                
                if (aiCount) aiCount.textContent = `${trophies.ai}ì `;
                if (multiplayerCount) multiplayerCount.textContent = `${trophies.multiplayer}ì `;
            },
            
            // ìŠ¹ë¦¬ ì‹œ ì¦í‘œ ì¶”ê°€
            addVictoryTrophy(type) {
                console.log(`ğŸ† addVictoryTrophy í˜¸ì¶œ: íƒ€ì…=${type}`);
                const newCount = this.updateTrophy(type, 3);
                showToast(`ğŸ‰ ìŠ¹ë¦¬ì˜ ì¦í‘œ +3 íšë“! (${type === 'ai' ? 'ëª¨ì˜ ê²°íˆ¬' : 'ì •ì‹ ê²°íˆ¬'} ì ìˆ˜: ${newCount})`, 'success', 3000);
            },
            
            // íŒ¨ë°° ì‹œ ì¦í‘œ ê°ì†Œ
            addDefeatTrophy(type) {
                const newCount = this.updateTrophy(type, -1);
                showToast(`ğŸ’” íŒ¨ë°°ë¡œ ì ìˆ˜ -1... (${type === 'ai' ? 'ëª¨ì˜ ê²°íˆ¬' : 'ì •ì‹ ê²°íˆ¬'} ì ìˆ˜: ${newCount})`, 'warning', 3000);
            },
            
            // ì´ˆê¸°í™”
            init() {
                const trophies = this.loadTrophies();
                this.displayTrophies(trophies);
            }
        };

        // í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì •ìœ¼ë¡œ ê²Œì„ ì´ˆê¸°í™”
        function resetGameWithFirstPlayer(firstPlayer) {
            console.log('ğŸ”„ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì •ìœ¼ë¡œ ê²Œì„ ì´ˆê¸°í™”');
            
            // ê²Œì„ ì‹œì‘ íš¨ê³¼ìŒ ì¬ìƒ (ê²ŒìŠ¤íŠ¸ê°€ í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ë°›ì•˜ì„ ë•Œ)
            activateAudioContext();
            playGameStartSound();
            
            // ë¡œì»¬ ë©”ëª¨ ìƒíƒœ ì´ˆê¸°í™”
            localMemoNotes = {};
            localMemoPanelActive = false;
            
            // ê²Œì„ ì‹œì‘ ì‹œ íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
            stopTurnTimer();
            resetTurnGauge();
            
            // ì˜¬ë°”ë¥¸ ë± ìƒì„± (1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ, 3ë²ˆì€ 3ê°œ...)
            let deck = [];
            for (let spellNumber = 1; spellNumber <= GAME_CONFIG.deckStructure.maxSpell; spellNumber++) {
                for (let cardCount = 0; cardCount < GAME_CONFIG.deckStructure.cardsPerSpell(spellNumber); cardCount++) {
                    deck.push(spellNumber);
                }
            }
            console.log('ğŸ“¦ ì´ˆê¸° ë± ìƒì„±:', deck);
            
            // ë± ì…”í”Œ
            shuffleArray(deck);
            console.log('ğŸ”„ ë± ì…”í”Œ ì™„ë£Œ');
            
            const playerName = getPlayerDisplayName();
            const opponentName = multiplayerMode ? (opponentName || 'Player2') : 'AI';
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            
            state = {
                players: [
                                    { id: 1, name: playerName, health: GAME_CONFIG.maxHealth, hand: deck.slice(0, GAME_CONFIG.maxHandSize).sort((a, b) => a - b), knownSecretStones: [] },
                { id: 2, name: opponentName, health: GAME_CONFIG.maxHealth, hand: deck.slice(GAME_CONFIG.maxHandSize, GAME_CONFIG.maxHandSize * 2).sort((a, b) => a - b), knownSecretStones: [] }
                ],
                secretStones: deck.slice(14),
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: firstPlayer,
                isPlayerTurn: multiplayerMode ? (firstPlayer === myPlayerId) : (firstPlayer === 1),
                lastSuccessfulSpell: 0,
                spellFailed: false, // ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì´ˆê¸°í™”
                turnInProgress: false,
                isGameOver: false,
                gameStarted: true,
                gameLog: [Messages.gameStart(firstPlayer === 1 ? playerName : opponentName)]
            };
            
            console.log('ğŸ¯ ê²ŒìŠ¤íŠ¸ ì´ˆê¸° ê²Œì„ ìƒíƒœ:', {
                playerHand: state.players[0].hand,
                opponentHand: state.players[1].hand,
                secretStones: state.secretStones,
                playerHealth: state.players[0].health,
                opponentHealth: state.players[1].health,
                firstPlayer: firstPlayer
            });
            
            createSpellButtons();
            updatePlayerName();
            render();
            updateButtons();
            
            // ë©”ëª¨ íŒ¨ë„ í‘œì‹œ
            showMemoPanel();
            
            // ê²Œì„ ì‹œì‘ ì‚¬ìš´ë“œ (ì´ë¯¸ startMultiplayerGameì—ì„œ ì¬ìƒë¨)
            // playGameStartSound();
            
            // ë””ë²„ê·¸: UI ìƒíƒœ í™•ì¸
            console.log('ğŸ® ê²Œì„ UI ë Œë”ë§ ì™„ë£Œ');
            console.log('ğŸ“Š í˜„ì¬ ìƒíƒœ:', {
                isPlayerTurn: state.isPlayerTurn,
                currentPlayerId: state.currentPlayerId,
                gameStarted: state.gameStarted,
                isGameOver: state.isGameOver
            });
            
            // ì²« ë²ˆì§¸ í„´ íƒ€ì´ë¨¸ ì‹œì‘
            setTimeout(() => {
                startTurnTimer();
            }, 1000);
            
            // ê²Œì„ ìƒíƒœ ì•ˆì „ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰
            setTimeout(() => {
                safeRefreshGameState();
            }, 500);
        }

        function updateDebugInfo() {
            if (!debugPanel.classList.contains('hidden')) {
                const player = state.players[0];
                const ai = state.players[1];
                debugInfo.innerHTML = `
                                    <div>í„´: ${state.currentPlayerId === 1 ? state.players[0].name : state.players[1].name}</div>
                <div>${state.players[0].name} ì²´ë ¥: ${player.health} | ${state.players[1].name} ì²´ë ¥: ${ai.health}</div>
                <div>${state.players[0].name} ì†íŒ¨: [${player.hand.join(', ')}]</div>
                    <div>${state.players[1].name} ì†íŒ¨: [${ai.hand.join(', ')}]</div>
                    <div>ë¹„ë°€ì˜ ëŒ: ${state.secretStones.length}ê°œ</div>
                    <div>ì‚¬ìš©í•œ ëŒ: ${state.usedStones.length}ê°œ</div>
                    <div>ë§ˆì§€ë§‰ ì„±ê³µ ì˜ì°½: ${state.lastSuccessfulSpell} ${state.lastSuccessfulSpell > 0 ? `(ì—°ì† ì˜ì°½: ${state.lastSuccessfulSpell}ë²ˆ ì´ìƒ)` : '(ì—°ì† ì˜ì°½ ì—†ìŒ)'}</div>
                    <div>ê²Œì„ ì¢…ë£Œ: ${state.isGameOver}</div>
                `;
            }
        }

        function render() {
            // ë©”ëª¨ íŒ¨ë„ ìƒíƒœ ë³µì›
            if (localMemoPanelActive) {
                const memoButtons = DOM.get('memo-buttons');
                memoButtons.classList.remove('hidden');
            }
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ë Œë”ë§ ì¤‘ë‹¨
            if (!state || !state.players || state.players.length < 2) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            // í”Œë ˆì´ì–´ ê°ì²´ë“¤ì´ ìœ íš¨í•œì§€ ì¶”ê°€ ê²€ì‚¬
            if (!state.players[0] || !state.players[1]) {
                console.log('âš ï¸ í”Œë ˆì´ì–´ ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const player = state.players[0];
            const opponent = state.players[1];
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ í”Œë ˆì´ì–´ 1, ê²ŒìŠ¤íŠ¸ê°€ í”Œë ˆì´ì–´ 2
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const myPlayer = state.players[myPlayerId - 1];
            const opponentPlayer = state.players[2 - myPlayerId]; // ìƒëŒ€ëŠ” ë‚˜ë¨¸ì§€ í”Œë ˆì´ì–´
            
            // í•˜íŠ¸ ë³€í™” ê°ì§€ (í•˜íŠ¸ ì—…ë°ì´íŠ¸ ì „ì—)
            const currentMyHealth = myPlayer.health;
            const currentOpponentHealth = opponentPlayer.health;
            
            console.log(`ğŸ” í•˜íŠ¸ ë³€í™” ì²´í¬ - ë‚´: ${previousMyHealth} â†’ ${currentMyHealth}, ìƒëŒ€: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            
            // í•˜íŠ¸ ë³€í™” ê°ì§€ (ë¡œê¹…ë§Œ)
            if (currentMyHealth < previousMyHealth) {
                console.log(`ğŸ’” ë‚´ í•˜íŠ¸ ì†ì‹¤: ${previousMyHealth} â†’ ${currentMyHealth}`);
            }
            if (currentMyHealth > previousMyHealth) {
                console.log(`ğŸ’š ë‚´ í•˜íŠ¸ íšŒë³µ: ${previousMyHealth} â†’ ${currentMyHealth}`);
            }
            if (currentOpponentHealth < previousOpponentHealth) {
                console.log(`ğŸ’” ìƒëŒ€ í•˜íŠ¸ ì†ì‹¤: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            }
            if (currentOpponentHealth > previousOpponentHealth) {
                console.log(`ğŸ’š ìƒëŒ€ í•˜íŠ¸ íšŒë³µ: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            }
            
            // í˜„ì¬ í•˜íŠ¸ ìƒíƒœ ì €ì¥
            previousMyHealth = currentMyHealth;
            previousOpponentHealth = currentOpponentHealth;
            
            // ì²´ë ¥ í‘œì‹œ ì—…ë°ì´íŠ¸ (íŒŒí‹°í´ ìƒì„± í›„)
            myHealthEl.innerHTML = '<span class="health-heart">â¤ï¸</span>'.repeat(Math.max(0, myPlayer.health));
            opponentHealthEl.innerHTML = '<span class="health-heart">â¤ï¸</span>'.repeat(Math.max(0, opponentPlayer.health));
            
            // ì²´ë ¥ í•˜íŠ¸ì— ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
            const hearts = myHealthEl.querySelectorAll('span');
            hearts.forEach(heart => heart.classList.add('health-heart'));
            
            // ë””ë²„ê·¸: í•˜íŠ¸ ë³€í™” ë¡œê·¸
            console.log(`ğŸ’” í•˜íŠ¸ ë³€í™” ê°ì§€ - ë‚´ í•˜íŠ¸: ${previousMyHealth} â†’ ${currentMyHealth}, ìƒëŒ€ í•˜íŠ¸: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            
            // ë‚´ ì†íŒ¨ í‘œì‹œ (ì¹˜íŠ¸í‚¤ ëª¨ë“œì—ì„œëŠ” ì•ë©´, ì¼ë°˜ ëª¨ë“œì—ì„œëŠ” ë’·ë©´)
            if (cheatMode) {
                myHandEl.innerHTML = myPlayer.hand.map(stone => `
                    <div class="card card-front flex flex-col items-center justify-center">
                        <div class="text-2xl mb-1">${getSpellIcon(stone)}</div>
                        <div class="text-sm font-bold">${stone}</div>
                    </div>
                `).join('');
            } else {
            myHandEl.innerHTML = myPlayer.hand.map(() => `<div class="card card-back"></div>`).join('');
            }
            
            // ìƒëŒ€ ì†íŒ¨ (ì•ë©´) - í•­ìƒ ìƒë‹¨ì— í‘œì‹œ, ìƒëŒ€ì˜ íŒ¨ë¥¼ ë³¼ ìˆ˜ ìˆì–´ì•¼ í•¨
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ìƒëŒ€ë°©ì˜ ì‹¤ì œ íŒ¨ë¥¼ í‘œì‹œ
            opponentHandEl.innerHTML = opponentPlayer.hand.map(stone => `
                <div class="card card-front flex flex-col items-center justify-center">
                    <div class="text-2xl mb-1">${getSpellIcon(stone)}</div>
                    <div class="text-sm font-bold">${stone}</div>
                </div>
            `).join('');
            
            secretStonesCountEl.textContent = `${state.secretStones.length}ê°œ`;
            usedStonesCountEl.textContent = `${state.usedStones.length}ê°œ`;
            
            // ê²Œì„ ë¡œê·¸ì— ìŠ¤íƒ€ì¼ë§ ì¶”ê°€
            gameLogEl.innerHTML = state.gameLog.map(log => {
                const isSuccess = log.includes('âœ…');
                const isFailure = log.includes('âŒ');
                const isTurn = log.includes('í„´');
                const isGameEnd = log.includes('ê²Œì„ ì¢…ë£Œ');
                
                let className = '';
                if (isSuccess) className = 'text-green-400';
                else if (isFailure) className = 'text-red-400';
                else if (isTurn) className = 'text-blue-400 font-bold';
                else if (isGameEnd) className = 'text-purple-400 font-bold';
                
                return `<p class="${className}">${log}</p>`;
            }).join('');
            
            // í˜„ì¬ í„´ì— ë”°ë¼ ì˜ì—­ í•˜ì´ë¼ì´íŠ¸ ë° ìƒ‰ìƒ êµ¬ë¶„
            // í—ˆìˆ˜ì•„ë¹„ ëª¨ë“œì—ì„œëŠ” myPlayerIdë¥¼ ì‚¬ìš©, ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸/ê²ŒìŠ¤íŠ¸ êµ¬ë¶„
            const isMyTurn = (state.currentPlayerId === myPlayerId);
            
            // ê¸€ë¡œìš° íš¨ê³¼: í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì—ê²Œë§Œ í‘œì‹œ
            myArea.classList.toggle('player-area-glow', isMyTurn && !state.isGameOver);
            opponentArea.classList.toggle('player-area-glow', !isMyTurn && !state.isGameOver);
            opponentArea.classList.toggle('opponent-turn', !isMyTurn && !state.isGameOver);
            
            // í„´ ì¸ë””ì¼€ì´í„°: í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì—ê²Œë§Œ í‘œì‹œ
            const myTurnIndicator = DOM.get('my-turn-indicator');
            const opponentTurnIndicator = DOM.get('opponent-turn-indicator');
            
            if (myTurnIndicator && opponentTurnIndicator) {
                // ë‚´ í„´ ì¸ë””ì¼€ì´í„°: ë‚´ í„´ì¼ ë•Œë§Œ í‘œì‹œ
                myTurnIndicator.classList.toggle('hidden', !isMyTurn || state.isGameOver);
                
                // ìƒëŒ€ í„´ ì¸ë””ì¼€ì´í„°: ìƒëŒ€ í„´ì¼ ë•Œë§Œ í‘œì‹œ (ë¹¨ê°„ìƒ‰)
                opponentTurnIndicator.classList.toggle('hidden', isMyTurn || state.isGameOver);
                opponentTurnIndicator.classList.toggle('opponent-turn', !isMyTurn && !state.isGameOver);
            }
            
            // ë²„íŠ¼ë“¤ì´ í•­ìƒ ë³´ì´ë„ë¡ ê°•ì œ ì„¤ì •
            const spellButtons = spellButtonsContainer.querySelectorAll('button');
            spellButtons.forEach(btn => {
                btn.style.display = 'block';
                btn.style.visibility = 'visible';
            });
            
            updateButtons();
            updateDebugInfo();
            
            // ë©”ëª¨ íŒ¨ë„ì„ í•­ìƒ í‘œì‹œ
            if (state.gameStarted && !state.isGameOver) {
                showMemoPanel();
            }
            
            // ê²Œì„ ìƒíƒœê°€ ì´ìƒí•œ ê²½ìš° ìë™ ë³µêµ¬
            if (multiplayerMode && (!state.players || state.players.length < 2)) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœ ì´ìƒ ê°ì§€, ìë™ ë³µêµ¬ ì‹œë„');
                setTimeout(() => {
                    safeRefreshGameState();
                }, 1000);
            }
            
            // í„´ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë° ë™ê¸°í™”
            if (multiplayerMode && state.players && state.players.length >= 2) {
                const myPlayerId = isHost ? 1 : 2;
                const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                if (state.isPlayerTurn !== shouldBeMyTurn) {
                    console.log(`âš ï¸ í„´ ìƒíƒœ ë¶ˆì¼ì¹˜ ê°ì§€ - ë‚´ í„´: ${state.isPlayerTurn}, ì‹¤ì œ í„´: ${shouldBeMyTurn}`);
                    state.isPlayerTurn = shouldBeMyTurn;
                    console.log(`ğŸ”„ í„´ ìƒíƒœ ìë™ ë™ê¸°í™”: ${state.isPlayerTurn} â†’ ${shouldBeMyTurn}`);
                }
            }
        }

        function createSpellButtons() {
            console.log('ğŸ”˜ ì˜ì°½ ë²„íŠ¼ ìƒì„±');
            spellButtonsContainer.innerHTML = '';
            
            const spellDescriptions = [
                { number: 1, name: 'ìš´ëª… ë³€í™˜', icon: 'ğŸ”®', desc: 'ë¹„ë°€ ì£¼ë¬¸ 3ê°œë¥¼<br>ë‚˜ì—ê²Œë§Œ ê³µê°œ' },
                { number: 2, name: 'ë§ˆë ¥ ì°©ì·¨', icon: 'ğŸ’«', desc: 'í”¼í•´ 1, íšŒë³µ 1' },
                { number: 3, name: 'ì •ì‹  êµë€', icon: 'ğŸŒ€', desc: 'ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸<br>í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…' },
                { number: 4, name: 'í™”ì—¼ í™”ì‚´', icon: 'ğŸ”¥', desc: 'í”¼í•´ 1' },
                { number: 5, name: 'ìƒëª… ë¬¼ì•½', icon: 'ğŸ§ª', desc: 'íšŒë³µ 1' },
                { number: 6, name: 'ëª…ìƒ', icon: 'ğŸ’¤', desc: 'ë¹„ë°€ ì£¼ë¬¸ 1ê°œë¥¼<br>ì „ì²´ ê³µê°œ' }
            ];
            
            spellDescriptions.forEach(spell => {
                const button = document.createElement('button');
                
                // ëª¨ë°”ì¼ì—ì„œëŠ” ì•„ì´ì½˜ë§Œ, ë°ìŠ¤í¬í†±ì—ì„œëŠ” ì „ì²´ ì •ë³´
                const isMobile = window.innerWidth <= 768;
                button.innerHTML = isMobile ? 
                    `<div class="text-2xl">${spell.icon}</div>` :
                    `<div class="text-lg">${spell.icon}</div>
                     <div class="text-xs font-bold">${spell.number}: ${spell.name}</div>
                     <div class="text-xs opacity-75">${spell.desc}</div>`;
                
                button.classList.add('py-3', 'rounded-lg', 'font-bold', 'btn-primary', 'spell-button', 'flex', 'flex-col', 'items-center', 'justify-center', 'h-24');
                button.dataset.spell = spell.number;
                button.addEventListener('click', () => handleSpellCast(spell.number));
                
                // ë²„íŠ¼ì´ í•­ìƒ ë³´ì´ë„ë¡ ê°•ì œ ì„¤ì •
                button.style.display = 'block';
                button.style.visibility = 'visible';
                
                spellButtonsContainer.appendChild(button);
                console.log(`ğŸ”˜ ì˜ì°½ ${spell.number} ë²„íŠ¼ ìƒì„± ì™„ë£Œ`);
            });
            
            createMemoButtons();
        }
        
        function createMemoButtons() {
            console.log('ğŸ“ ë©”ëª¨ ë²„íŠ¼ ìƒì„±');
            const memoButtonsContainer = DOM.get('memo-buttons');
            memoButtonsContainer.innerHTML = '';
            
            const spellDescriptions = [
                { number: 1, name: 'ìš´ëª… ë³€í™˜' },
                { number: 2, name: 'ë§ˆë ¥ ì°©ì·¨' },
                { number: 3, name: 'ì •ì‹  êµë€' },
                { number: 4, name: 'í™”ì—¼ í™”ì‚´' },
                { number: 5, name: 'ìƒëª… ë¬¼ì•½' },
                { number: 6, name: 'ëª…ìƒ' }
            ];
            
            spellDescriptions.forEach(spell => {
                const button = document.createElement('button');
                button.innerHTML = `
                    <div class="text-xs">âŒ</div>
                `;
                button.classList.add('py-1', 'px-2', 'rounded-lg', 'font-bold', 'memo-button', 'flex', 'flex-col', 'items-center', 'justify-center', 'h-8');
                button.dataset.spell = spell.number;
                button.addEventListener('click', () => toggleMemo(spell.number));
                memoButtonsContainer.appendChild(button);
            });
            
            // ë©”ëª¨ ë²„íŠ¼ ìƒì„± í›„ ê¸°ì¡´ ë©”ëª¨ ìƒíƒœ ë³µì›
            updateMemoButtons();
        }
        
        function toggleMemo(spellNumber) {
            // í† ê¸€: í˜„ì¬ ìƒíƒœì˜ ë°˜ëŒ€ë¡œ ë³€ê²½
            const currentState = localMemoNotes[spellNumber] || false;
            localMemoNotes[spellNumber] = !currentState;
            
            console.log(`ğŸ“ ë©”ëª¨ í† ê¸€: ì˜ì°½ ${spellNumber} - ${localMemoNotes[spellNumber] ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
            
            updateMemoButtons();
            playCardSound();
        }
        
        function updateMemoButtons() {
            const memoButtons = document.querySelectorAll('.memo-button');
            memoButtons.forEach(button => {
                const spellNumber = parseInt(button.dataset.spell);
                const isActive = localMemoNotes[spellNumber];
                
                if (isActive) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }
        
        function toggleMemoPanel() {
            const memoButtons = DOM.get('memo-buttons');
            const isVisible = !memoButtons.classList.contains('hidden');
            
            if (isVisible) {
                memoButtons.classList.add('hidden');
                localMemoPanelActive = false;
                console.log('ğŸ“ ë©”ëª¨ íŒ¨ë„ ë¹„í™œì„±í™”');
            } else {
                memoButtons.classList.remove('hidden');
                localMemoPanelActive = true;
                console.log('ğŸ“ ë©”ëª¨ íŒ¨ë„ í™œì„±í™”');
            }
            
            playCardSound();
        }
        
        // ë©”ëª¨ íŒ¨ë„ì„ í•­ìƒ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
        function showMemoPanel() {
            const memoButtons = DOM.get('memo-buttons');
            memoButtons.classList.remove('hidden');
            localMemoPanelActive = true;
            console.log('ğŸ“ ë©”ëª¨ íŒ¨ë„ í•­ìƒ í‘œì‹œ');
        }

        // ê²Œì„ ìƒíƒœ ì•ˆì „ ìƒˆë¡œê³ ì¹¨ í•¨ìˆ˜
        function safeRefreshGameState() {
            try {
                // ê²Œì„ ìƒíƒœ ìœ íš¨ì„± ê²€ì‚¬
                if (!GameConditions.isGameValid()) {
                    console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ - ê¸°ë³¸ ìƒíƒœë¡œ ë³µêµ¬');
                    resetGame();
                    return;
                }
                
                // ì²´ë ¥ ìŒìˆ˜ ë°©ì§€
                state.players.forEach(player => {
                    if (player.health < 0) {
                        console.log(`âš ï¸ í”Œë ˆì´ì–´ ${player.name} ì²´ë ¥ ìŒìˆ˜ ë°©ì§€: ${player.health} â†’ 0`);
                        player.health = 0;
                    }
                });
                
                // í˜„ì¬ ê²Œì„ ìƒíƒœ ë°±ì—…
                const currentState = { ...state };
                const currentPlayerName = localStorage.getItem('playerName') || 'Player';
                
                // ìƒëŒ€ë°© ì´ë¦„ì„ ë” ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°
                let currentOpponentName = 'Player2';
                if (opponentName) {
                    currentOpponentName = opponentName;
                } else if (state.players && state.players.length >= 2) {
                    // ê²Œì„ ìƒíƒœì—ì„œ ìƒëŒ€ë°© ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                    const myPlayerId = isHost ? 1 : 2;
                    const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
                    if (opponentPlayer && opponentPlayer.name) {
                        currentOpponentName = opponentPlayer.name;
                    }
                }
                
                // ê¸°ë³¸ UI ìš”ì†Œë“¤ ê°•ì œ ìƒˆë¡œê³ ì¹¨
                createSpellButtons();
                
                // ë‚´ ì´ë¦„ë§Œ ì—…ë°ì´íŠ¸ (ìƒëŒ€ë°© ì´ë¦„ì€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ)
                const myTitle = DOM.get('my-title');
                if (myTitle) {
                    myTitle.textContent = `ë‚˜ (${currentPlayerName})`;
                }
                
                // ìƒëŒ€ë°© ì´ë¦„ë„ ì•ˆì „í•˜ê²Œ ì—…ë°ì´íŠ¸
                updateOpponentName();
                
                // ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸
                const opponentArea = DOM.get('opponent-area');
                const opponentTitle = opponentArea.querySelector('h2');
                if (opponentTitle) {
                    // í˜„ì¬ í‘œì‹œëœ ì´ë¦„ì´ ìˆìœ¼ë©´ ìœ ì§€, ì—†ìœ¼ë©´ ìƒˆë¡œ ì„¤ì •
                    const currentDisplayName = opponentTitle.textContent;
                    if (currentDisplayName && currentDisplayName !== 'ìƒëŒ€') {
                        // ì´ë¯¸ í‘œì‹œëœ ì´ë¦„ì´ ìˆìœ¼ë©´ ìœ ì§€
                    } else {
                        opponentTitle.textContent = `ìƒëŒ€ (${currentOpponentName})`;
                    }
                }
                
                // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•œì§€ í™•ì¸í•˜ê³  ë³µêµ¬
                if (!GameConditions.isGameValid() || !state.players[0] || !state.players[1]) {
                    // ê¸°ë³¸ ê²Œì„ ìƒíƒœë¡œ ë³µêµ¬
                    if (multiplayerMode) {
                        const myPlayerId = isHost ? 1 : 2;
                        state = {
                            players: [
                                                { id: 1, name: currentPlayerName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] },
                { id: 2, name: currentOpponentName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] }
                            ],
                            secretStones: [],
                            usedStones: [],
                            publiclyRevealedSecretStones: [],
                            currentPlayerId: 1,
                            isPlayerTurn: (myPlayerId === 1),
                            lastSuccessfulSpell: 0,
                            turnInProgress: false,
                            isGameOver: false,
                            gameStarted: true,
                            gameLog: ['ê²Œì„ ìƒíƒœê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.']
                        };
                    }
                } else {
                    // ê²Œì„ ìƒíƒœëŠ” ìœ íš¨í•˜ì§€ë§Œ í„´ ìƒíƒœë¥¼ ì¬í™•ì¸
                    if (multiplayerMode) {
                        const myPlayerId = isHost ? 1 : 2;
                        const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                        if (state.isPlayerTurn !== shouldBeMyTurn) {
                            state.isPlayerTurn = shouldBeMyTurn;
                        }
                    }
                }
                
                // UI ê°•ì œ ìƒˆë¡œê³ ì¹¨
                render();
                updateButtons();
                updateDebugInfo();
                
                // ë©”ëª¨ íŒ¨ë„ í‘œì‹œ
                showMemoPanel();
                
            } catch (error) {
                console.error('âŒ ê²Œì„ ìƒíƒœ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', error);
                addLog('âŒ ê²Œì„ ìƒíƒœ ìƒˆë¡œê³ ì¹¨ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        function updateButtons() {
            const buttons = spellButtonsContainer.querySelectorAll('button');
            const isMyTurn = GameConditions.isMyTurn();
            
            // í„´ ìƒíƒœ ë™ê¸°í™” (ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ)
            if (multiplayerMode && state.isPlayerTurn !== isMyTurn) {
                    console.log(`ğŸ”„ í„´ ìƒíƒœ ë™ê¸°í™”: isPlayerTurn ${state.isPlayerTurn} â†’ ${isMyTurn}`);
                    state.isPlayerTurn = isMyTurn;
            }
            
            // í„´ ì§„í–‰ ìƒíƒœ ê°•ì œ ì´ˆê¸°í™” (ë‚´ í„´ì´ê³  í„´ ì§„í–‰ì¤‘ì´ë©´ ì´ˆê¸°í™”)
            if (isMyTurn && state.turnInProgress) {
                console.log('âš ï¸ í„´ ì§„í–‰ ìƒíƒœ ê°•ì œ ì´ˆê¸°í™”');
                state.turnInProgress = false;
            }
            
            // ë‚´ í„´ì´ê³  í„´ ì§„í–‰ ì¤‘ì´ ì•„ë‹ ë•Œ ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™” í”Œë˜ê·¸ ì´ˆê¸°í™”
            // ë‹¨, ì˜ì°½ ì‹¤íŒ¨ í›„ì—ëŠ” ê°•ì œë¡œ ë¹„í™œì„±í™” ìƒíƒœ ìœ ì§€
            if (isMyTurn && !state.turnInProgress && !state.isGameOver && !state.spellFailed) {
                if (spellButtonsDisabled) {
                    console.log('ğŸ”„ ë‚´ í„´ ì‹œì‘ - ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™” í”Œë˜ê·¸ ì´ˆê¸°í™”');
                    spellButtonsDisabled = false;
                }
            }
            
            // ì˜ì°½ ì‹¤íŒ¨ í›„ì—ëŠ” ë¬´ì¡°ê±´ ë²„íŠ¼ ë¹„í™œì„±í™” ìœ ì§€
            if (state.spellFailed) {
                spellButtonsDisabled = true;
                console.log('ğŸ”’ ì˜ì°½ ì‹¤íŒ¨ ìƒíƒœ - ë²„íŠ¼ ë¹„í™œì„±í™” ìœ ì§€');
            }
            
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            console.log(`ğŸ® ë²„íŠ¼ ì—…ë°ì´íŠ¸ - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${isMyTurn}, í„´ ì§„í–‰ì¤‘: ${state.turnInProgress}, ê²Œì„ì¢…ë£Œ: ${state.isGameOver}`);
            
            buttons.forEach(btn => {
                const spellNumber = parseInt(btn.dataset.spell);
                const isDisabled = !GameConditions.canPlaySpell() || (state.lastSuccessfulSpell > 0 && spellNumber < state.lastSuccessfulSpell) || spellButtonsDisabled;
                
                // ë²„íŠ¼ì„ ì™„ì „íˆ ìˆ¨ê¸°ì§€ ë§ê³  ë¹„í™œì„±í™”ë§Œ í•˜ê¸°
                btn.disabled = isDisabled;
                
                // ë¹„í™œì„±í™”ëœ ë²„íŠ¼ë„ ì‹œê°ì ìœ¼ë¡œ ë³´ì´ë„ë¡ ìŠ¤íƒ€ì¼ ì¡°ì •
                if (isDisabled) {
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                    // ì—°ì† ì˜ì°½ ê·œì¹™ ìœ„ë°˜ ì‹œ ì¶”ê°€ ì‹œê°ì  í‘œì‹œ
                    if (state.lastSuccessfulSpell > 0 && spellNumber < state.lastSuccessfulSpell) {
                        btn.style.border = '2px solid #dc3545';
                        btn.style.color = '#dc3545';
                        // ì—°ì† ì˜ì°½ ê·œì¹™ ìœ„ë°˜ ì‹œ ì¶”ê°€ í…ìŠ¤íŠ¸ í‘œì‹œ (ë” ê°„ë‹¨í•˜ê²Œ)
                        const descElement = btn.querySelector('.text-xs.opacity-75');
                        if (descElement) {
                            descElement.innerHTML = `${state.lastSuccessfulSpell}ë²ˆ ì´ìƒ`;
                        }
                    } else {
                        btn.style.border = '';
                        btn.style.color = '';
                        // ì›ë˜ ì„¤ëª… ë³µì›
                        const descElement = btn.querySelector('.text-xs.opacity-75');
                        if (descElement) {
                        const spellDescriptions = [
                                { number: 1, desc: 'ë¹„ë°€ ì£¼ë¬¸ 3ê°œë¥¼<br>ë‚˜ì—ê²Œë§Œ ê³µê°œ' },
                                { number: 2, desc: 'í”¼í•´ 1, íšŒë³µ 1' },
                                { number: 3, desc: 'ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸<br>í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…' },
                                { number: 4, desc: 'í”¼í•´ 1' },
                                { number: 5, desc: 'íšŒë³µ 1' },
                                { number: 6, desc: 'ë¹„ë°€ ì£¼ë¬¸ 1ê°œë¥¼<br>ì „ì²´ ê³µê°œ' }
                            ];
                        const spell = spellDescriptions.find(s => s.number === spellNumber);
                            if (spell) {
                                descElement.innerHTML = spell.desc;
                            }
                        }
                    }
                } else {
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                    btn.style.border = '';
                    btn.style.color = '';
                    // ì›ë˜ ì„¤ëª… ë³µì›
                    const descElement = btn.querySelector('.text-xs.opacity-75');
                    if (descElement) {
                        const spellDescriptions = [
                            { number: 1, desc: 'ë¹„ë°€ ì£¼ë¬¸ 3ê°œë¥¼<br>ë‚˜ì—ê²Œë§Œ ê³µê°œ' },
                            { number: 2, desc: 'í”¼í•´ 1, íšŒë³µ 1' },
                            { number: 3, desc: 'ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸<br>í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…' },
                            { number: 4, desc: 'í”¼í•´ 1' },
                            { number: 5, desc: 'íšŒë³µ 1' },
                            { number: 6, desc: 'ë¹„ë°€ ì£¼ë¬¸ 1ê°œë¥¼<br>ì „ì²´ ê³µê°œ' }
                        ];
                        const spell = spellDescriptions.find(s => s.number === spellNumber);
                        if (spell) {
                            descElement.innerHTML = spell.desc;
                        }
                    }
                }
                
                // ë””ë²„ê·¸ìš©: ë²„íŠ¼ ìƒíƒœ ë¡œê·¸
                console.log(`ğŸ”˜ ì˜ì°½ ${spellNumber} ë²„íŠ¼ - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${isMyTurn}, í„´ ì§„í–‰ì¤‘: ${state.turnInProgress}, ë§ˆì§€ë§‰ ì„±ê³µ: ${state.lastSuccessfulSpell}, ê²Œì„ì¢…ë£Œ: ${state.isGameOver}, ë²„íŠ¼ë¹„í™œì„±í™”: ${spellButtonsDisabled}, ë¹„í™œì„±í™”: ${isDisabled}`);
            });
            
            endTurnBtn.disabled = !isMyTurn || state.turnInProgress || state.isGameOver || state.spellFailed;
            
            // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ì‹œê°ì ìœ¼ë¡œ ë³´ì´ë„ë¡ ì¡°ì •
            if (endTurnBtn.disabled) {
                endTurnBtn.style.opacity = '0.5';
                endTurnBtn.style.cursor = 'not-allowed';
            } else {
                endTurnBtn.style.opacity = '1';
                endTurnBtn.style.cursor = 'pointer';
            }
            
            console.log(`ğŸ”„ í„´ ì¢…ë£Œ ë²„íŠ¼ - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${isMyTurn}, í„´ ì§„í–‰ì¤‘: ${state.turnInProgress}, ê²Œì„ì¢…ë£Œ: ${state.isGameOver}, ì˜ì°½ì‹¤íŒ¨: ${state.spellFailed}, ë¹„í™œì„±í™”: ${endTurnBtn.disabled}`);
        }

        async function handleSpellCast(spellNumber) {
            console.log(`ğŸ¯ ì˜ì°½ ì‹œë„: ${spellNumber}ë²ˆ`);
            
            // ì´ë¯¸ ì˜ì°½ ì§„í–‰ ì¤‘ì´ê±°ë‚˜ ë²„íŠ¼ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì¤‘ë‹¨
            if (state.turnInProgress || spellButtonsDisabled) {
                console.log('âŒ ì˜ì°½ ì§„í–‰ ì¤‘ ë˜ëŠ” ë²„íŠ¼ ë¹„í™œì„±í™” - ì¤‘ë³µ í´ë¦­ ë°©ì§€');
                return;
            }
            
            // ì—°ì† ì˜ì°½ ê·œì¹™ ê²€ì¦ (ê°•í™”ëœ ê²€ì¦)
            if (state.lastSuccessfulSpell > 0 && spellNumber < state.lastSuccessfulSpell) {
                console.log(`âŒ ì—°ì† ì˜ì°½ ê·œì¹™ ìœ„ë°˜: ${spellNumber} < ${state.lastSuccessfulSpell}`);
                return;
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ í„´ì¼ ë•Œë§Œ í™œì„±í™”
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” currentPlayerIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ í„´ íŒë‹¨
            let isMyTurn;
            if (multiplayerMode) {
                isMyTurn = (state.currentPlayerId === myPlayerId);
                // state.isPlayerTurnê³¼ currentPlayerIdê°€ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë™ê¸°í™”
                if (state.isPlayerTurn !== isMyTurn) {
                    state.isPlayerTurn = isMyTurn;
                }
            } else {
                isMyTurn = state.isPlayerTurn;
            }
            
            if (!isMyTurn || state.turnInProgress || state.isGameOver) {
                console.log('âŒ ì˜ì°½ ì‹œë„ ì‹¤íŒ¨ - ì¡°ê±´ ë¶ˆë§Œì¡±');
                return;
            }
            
            // ì£¼ë¬¸ ë²„íŠ¼ ì¦‰ì‹œ ë¹„í™œì„±í™”
            disableSpellButtons();
            state.turnInProgress = true;
            updateButtons();
            
            // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ë¹„í™œì„±í™”
            endTurnBtn.disabled = true;
            endTurnBtn.style.opacity = '0.5';
            endTurnBtn.style.cursor = 'not-allowed';
            
            // í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ ì°¾ê¸°
            const currentPlayer = state.players.find(p => p.id === state.currentPlayerId);
            
            // í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì˜ íŒ¨ì—ì„œ ì¹´ë“œ ì°¾ê¸°
            const handIndex = currentPlayer.hand.indexOf(spellNumber);
            
            console.log(`ğŸ” ì†íŒ¨ì—ì„œ ${spellNumber} ì°¾ê¸°:`, {
                playerId: currentPlayer.id,
                hand: currentPlayer.hand,
                foundIndex: handIndex,
                hasCard: handIndex > -1
            });
            
            if (handIndex > -1) {
                const castedStone = currentPlayer.hand.splice(handIndex, 1)[0];
                state.usedStones.push(castedStone);
                console.log(`âœ… ì˜ì°½ ì„±ê³µ! ì‚¬ìš©ëœ ì£¼ë¬¸: ${castedStone}`);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    const myPlayerId = isHost ? 1 : 2;
                    dataChannel.send(JSON.stringify({
                        type: 'cardPlayed',
                        card: spellNumber,
                        playerId: myPlayerId,
                        gameState: state
                    }));
                }
                
                // ì„±ê³µ íš¨ê³¼
                playSuccessSound();
                addSuccessAnimation(myArea);
                
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                addLog(Messages.spellSuccess(state.players[myPlayerId - 1].name, spellNumber));
                
                // ë¨¼ì € lastSuccessfulSpell ì—…ë°ì´íŠ¸
                state.lastSuccessfulSpell = spellNumber;
                console.log(`ğŸ“Š ì—°ì† ì˜ì°½ ì—…ë°ì´íŠ¸: ${spellNumber}ë²ˆ (ì´ì œ ${spellNumber}ë²ˆ ì´ìƒë§Œ ì‚¬ìš© ê°€ëŠ¥)`);
                
                render();
                
                await executeSpellEffect(myPlayerId, spellNumber);
                
                // ì„±ê³µí•œ ê²½ìš° ì—°ì† ì˜ì°½ ê°€ëŠ¥í•˜ë„ë¡ í„´ ìœ ì§€
                state.turnInProgress = false;
                
                // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                updateButtons();
                
                // ì—°ì† ì˜ì°½ ì‹œ íƒ€ì´ë¨¸ ê³„ì† ìœ ì§€ (ì¬ì‹œì‘í•˜ì§€ ì•ŠìŒ)
                console.log('ğŸ’¡ ì—°ì† ì˜ì°½ ì„±ê³µ - íƒ€ì´ë¨¸ ê³„ì† ìœ ì§€');
                
                // ì—°ì† ì˜ì°½ ì•ˆë‚´ ë©”ì‹œì§€
                                    addLog(`ğŸ’¡ ${spellNumber}ë²ˆ ì´ìƒ ì—°ì† ì˜ì°½ ê°€ëŠ¥`);
                return;
            } else {
                // í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì˜ ì²´ë ¥ ê°ì†Œ
                const currentPlayer = state.players.find(p => p.id === state.currentPlayerId);
                currentPlayer.health--;
                console.log(`âŒ ì˜ì°½ ì‹¤íŒ¨! í”Œë ˆì´ì–´ ${currentPlayer.id} ì²´ë ¥ ê°ì†Œ: ${currentPlayer.health}`);
                
                // ì‹¤íŒ¨ íš¨ê³¼
                playFailureSound();
                addFailureAnimation(myArea);
                showDamageEffect(myArea, 1);
                
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                
                // ì˜ì°½ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™”
                spellButtonsDisabled = true;
                state.spellFailed = true; // ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì„¤ì •
                disableSpellButtons();
                
                // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ì¦‰ì‹œ ë¹„í™œì„±í™”
                endTurnBtn.disabled = true;
                endTurnBtn.style.opacity = '0.5';
                endTurnBtn.style.cursor = 'not-allowed';
                
                // ì˜ì°½ ì‹¤íŒ¨ íŒì—… í‘œì‹œ
                await showModal('ì˜ì°½ ì‹¤íŒ¨', `${spellNumber}ë²ˆ ì£¼ë¬¸ ì˜ì°½ ì‹¤íŒ¨<br>ì²´ë ¥ -1 (í˜„ì¬: ${currentPlayer.health})`);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ì‹¤íŒ¨ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'spellFailed',
                        spell: spellNumber,
                        playerId: myPlayerId,
                        gameState: state
                    }));
                }
                
                addLog(Messages.spellFailure(state.players[myPlayerId - 1].name, spellNumber));
                
                // ì²´ë ¥ ê°ì†Œ í›„ ë°”ë¡œ ê²Œì„ ì¢…ë£Œ ì²´í¬
                if (checkGameOver()) return;
                
                // ê²Œì„ ë¡œê·¸ë§Œ ì—…ë°ì´íŠ¸í•˜ê³  ë²„íŠ¼ ìƒíƒœëŠ” ìœ ì§€
                const gameLogEl = DOM.get('game-log');
                if (gameLogEl) {
                    gameLogEl.innerHTML = state.gameLog.map(log => {
                        const isSuccess = log.includes('âœ…');
                        const isFailure = log.includes('âŒ');
                        const isTurn = log.includes('í„´');
                        const isGameEnd = log.includes('ê²Œì„ ì¢…ë£Œ');
                        
                        let className = '';
                        if (isSuccess) className = 'text-green-400';
                        else if (isFailure) className = 'text-red-400';
                        else if (isTurn) className = 'text-blue-400 font-bold';
                        else if (isGameEnd) className = 'text-purple-400 font-bold';
                        
                        return `<p class="${className}">${log}</p>`;
                    }).join('');
                }
                
                await sleep(1000);
                endTurn();
                return;
            }
        }

        // í„´ ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function switchToNextPlayer() {
            const currentPlayerName = state.currentPlayerId === 1 ? state.players[0].name : (multiplayerMode ? state.players[1].name : 'AI');
            addLog(Messages.turnEnd(currentPlayerName));
            state.lastSuccessfulSpell = 0;
            // ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì´ˆê¸°í™”
            state.spellFailed = false;
            state.currentPlayerId = state.currentPlayerId === 1 ? 2 : 1;
            
            if (multiplayerMode) {
                const myPlayerId = isHost ? 1 : 2;
                state.isPlayerTurn = (state.currentPlayerId === myPlayerId);
            } else {
                state.isPlayerTurn = !state.isPlayerTurn;
            }
            }
            
        function sendTurnEndToOpponent() {
            if (GameConditions.isMultiplayerConnected()) {
                console.log('ğŸ“¤ í„´ ì¢…ë£Œ ë©”ì‹œì§€ ì „ì†¡');
                dataChannel.send(JSON.stringify({
                    type: 'turnEnd',
                    gameState: state,
                    currentPlayerId: state.currentPlayerId,
                    isPlayerTurn: state.isPlayerTurn
                }));
            }
        }

        function startNextTurn() {
            // í„´ ì§„í–‰ ì¤‘ í”Œë˜ê·¸ ì´ˆê¸°í™”
            state.turnInProgress = false;
            
            if (!state.isPlayerTurn && !multiplayerMode) {
                startTurnTimer();
                aiTurn();
            } else if (!state.isPlayerTurn && multiplayerMode) {
                const opponentName = state.players[1].name;
                addLog(Messages.turnStart(opponentName));
                startTurnTimer();
            } else if (state.isPlayerTurn) {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                const myName = state.players[myPlayerId - 1].name;
                addLog(Messages.turnStart(myName));
                startTurnTimer();
                
                // ìƒˆë¡œìš´ í„´ ì‹œì‘ ì‹œ ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì´ˆê¸°í™”
                state.spellFailed = false;
                
                // í”Œë ˆì´ì–´ í„´ ì‹œì‘ ì‹œ ëª¨ë“  ë²„íŠ¼ í™œì„±í™”
                spellButtonsDisabled = false;
                enableSpellButtons();
                
                if (multiplayerMode) {
                    console.log('ğŸ¯ ë‚´ í„´ ì‹œì‘ - ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
                    setTimeout(() => {
                        safeRefreshGameState();
                    }, 500);
                }
            }
        }

        function endTurn() {
            console.log('ğŸ”„ í„´ ì¢…ë£Œ');
            if (state.isGameOver) return;
            
            if (!GameConditions.isGameValid()) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ í„´ ì¢…ë£Œë¥¼ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            // í„´ ì¢…ë£Œ ì§„í–‰ ì¤‘ í”Œë˜ê·¸ ì„¤ì •ìœ¼ë¡œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            if (state.turnInProgress) {
                console.log('âš ï¸ í„´ ì¢…ë£Œê°€ ì´ë¯¸ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤');
                return;
            }
            
            state.turnInProgress = true;
            
            stopTurnTimer();
            switchToNextPlayer();
            sendTurnEndToOpponent();
            
            render();
            updateButtons();
            
            if (checkGameOver()) return;
            startNextTurn();
        }

        // ì£¼ë¬¸ íš¨ê³¼ í•¨ìˆ˜ë“¤
        async function executeMeditation(player, opponent) {
            console.log('ğŸ’¤ ëª…ìƒ íš¨ê³¼ ì‹¤í–‰');
                    if (state.secretStones.length > 0) {
                        const revealedStone = state.secretStones.splice(0, 1)[0];
                
                // ëª¨ë‘ì—ê²Œ ê³µê°œë˜ëŠ” ë¹„ë°€ ì£¼ë¬¸ìœ¼ë¡œ ì¶”ê°€
                if (!state.publiclyRevealedSecretStones) {
                    state.publiclyRevealedSecretStones = [];
                }
                        state.publiclyRevealedSecretStones.push(revealedStone);
                
                console.log(`ğŸ’¤ ì „ì²´ ê³µê°œëœ ì£¼ë¬¸: ${revealedStone}`);
                addLog(Messages.meditate(revealedStone) + ' (ì „ì²´ ê³µê°œ)');
                
                        const icon = SpellIcons[revealedStone] || 'â“';
                        await showModal('ğŸ’¤ ëª…ìƒ', `ë¹„ë°€ ì£¼ë¬¸ [${icon}${revealedStone}]${getJosa(revealedStone.toString(), 'ì´/ê°€')} ì „ì²´ ê³µê°œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    } else {
                        const message = 'ëª…ìƒ ì¢…ë£Œ: ë” ì´ìƒ ê³µê°œí•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.';
                console.log('ğŸ’¤ ë” ì´ìƒ ê³µê°œí•  ë¹„ë°€ ì£¼ë¬¸ ì—†ìŒ');
                        addLog(message);
                        await showModal('ğŸ’¤ ëª…ìƒ', message);
                    }
        }

        async function executeHealPotion(player, opponent) {
                    console.log('ğŸ§ª ìƒëª… ë¬¼ì•½ íš¨ê³¼ ì‹¤í–‰');
            if (player.health < GAME_CONFIG.maxHealth) player.health++;
                    console.log(`ğŸ’š ìƒëª… ë¬¼ì•½ íšŒë³µ: ${player.name} ì²´ë ¥ ${player.health}`);
                    playHealSound();
                    showHealEffect(player.id === 1 ? myArea : opponentArea, 1);
            addLog(Messages.heal(player.name, 1));
            
            // ìƒëª… ë¬¼ì•½ ê²°ê³¼ íŒì—… í‘œì‹œ
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            if (player.id === myPlayerId) {
                await showModal('ğŸ§ª ìƒëª… ë¬¼ì•½', `ì²´ë ¥ì´ 1 íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.<br>í˜„ì¬ ì²´ë ¥: ${player.health}`);
            } else {
                await showModal('ğŸ§ª ìƒëª… ë¬¼ì•½', `${player.name}ì˜ ì²´ë ¥ì´ 1 íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.<br>í˜„ì¬ ì²´ë ¥: ${player.health}`);
            }
        }

        async function executeFireArrow(player, opponent) {
                    opponent.health--;
                    console.log(`ğŸ”¥ í™”ì—¼ í™”ì‚´: í”¼í•´ 1`);
                    playDamageSound();
                    showDamageEffect(opponent.id === 1 ? myArea : opponentArea, 1);
            addLog(Messages.damage(opponent.name, 1));
            
            // í™”ì—¼ í™”ì‚´ ê²°ê³¼ íŒì—… í‘œì‹œ
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            if (opponent.id === myPlayerId) {
                await showModal('ğŸ”¥ í™”ì—¼ í™”ì‚´', `ì²´ë ¥ì´ 1 ê°ì†Œí–ˆìŠµë‹ˆë‹¤.<br>í˜„ì¬ ì²´ë ¥: ${opponent.health}`);
            } else {
                await showModal('ğŸ”¥ í™”ì—¼ í™”ì‚´', `${opponent.name}ì˜ ì²´ë ¥ì´ 1 ê°ì†Œí–ˆìŠµë‹ˆë‹¤.<br>í˜„ì¬ ì²´ë ¥: ${opponent.health}`);
            }
        }

        async function executeMindControl(player, opponent, playerId) {
                    console.log('ğŸŒ€ ì •ì‹  êµë€ íš¨ê³¼ ì‹¤í–‰');
                    if (state.secretStones.length > 0) {
                        const spyStone = state.secretStones.splice(0, 1)[0];
                        opponent.hand.push(spyStone);
                        opponent.hand.sort((a, b) => a - b);
                        console.log(`ğŸŒ€ ì •ì‹  êµë€ íˆ¬ì…: ${spyStone}ì„(ë¥¼) ${opponent.name}ì˜ íŒ¨ì— íˆ¬ì…`);
                        playCardSound();
                        
                        const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                addLog(Messages.spy(player.name));
                
                        if (playerId === myPlayerId) {
                            await showModal('ğŸŒ€ ì •ì‹  êµë€', `ë¹„ë°€ ì£¼ë¬¸ í•˜ë‚˜ë¥¼ ìƒëŒ€ì˜ íŒ¨ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
                        } else {
                            await showModal('ğŸŒ€ ì •ì‹  êµë€', `ë¹„ë°€ ì£¼ë¬¸ í•˜ë‚˜ê°€ íŒ¨ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        }
                    } else {
                        console.log('âŒ íˆ¬ì…í•  ë¹„ë°€ ì£¼ë¬¸ ì—†ìŒ');
                        addLog(`ì •ì‹  êµë€ ì¢…ë£Œ: íˆ¬ì…í•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.`);
                        await showModal('ğŸŒ€ ì •ì‹  êµë€', 'íˆ¬ì…í•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
        }

        async function executeManaDrain(player, opponent) {
                    opponent.health--;
            if (player.health < GAME_CONFIG.maxHealth) player.health++;
                    console.log(`ğŸ’« ë§ˆë ¥ ì°©ì·¨: ${opponent.name} ì²´ë ¥ ${opponent.health}, ${player.name} ì²´ë ¥ ${player.health}`);
                    playDamageSound();
                    playHealSound();
                    showDamageEffect(opponent.id === 1 ? myArea : opponentArea, 1);
                    showHealEffect(player.id === 1 ? myArea : opponentArea, 1);
            addLog(Messages.damage(opponent.name, 1) + ' + ' + Messages.heal(player.name, 1));
            
            // ë§ˆë ¥ ì°©ì·¨ ê²°ê³¼ íŒì—… í‘œì‹œ
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            if (player.id === myPlayerId) {
                await showModal('ğŸ’« ë§ˆë ¥ ì°©ì·¨', `ìƒëŒ€ì˜ ì²´ë ¥ì„ í¡ìˆ˜í•˜ì—¬ íšŒë³µí–ˆìŠµë‹ˆë‹¤.<br>ìƒëŒ€ ì²´ë ¥: ${opponent.health}<br>ë‚´ ì²´ë ¥: ${player.health}`);
            } else if (opponent.id === myPlayerId) {
                await showModal('ğŸ’« ë§ˆë ¥ ì°©ì·¨', `ì²´ë ¥ì´ í¡ìˆ˜ë˜ì–´ ê°ì†Œí–ˆìŠµë‹ˆë‹¤.<br>í˜„ì¬ ì²´ë ¥: ${opponent.health}`);
            } else {
                await showModal('ğŸ’« ë§ˆë ¥ ì°©ì·¨', `${opponent.name}ì˜ ì²´ë ¥ì´ 1 ê°ì†Œí•˜ê³ , ${player.name}ì˜ ì²´ë ¥ì´ 1 íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.`);
            }
        }

        async function executeDestinyChange(player, opponent) {
                    console.log('ğŸ”® ìš´ëª… ë³€í™˜ íš¨ê³¼ ì‹¤í–‰');
                    const toRevealCount = Math.min(3, state.secretStones.length);
                    if (toRevealCount > 0) {
                        const revealedStones = state.secretStones.splice(0, toRevealCount);
                
                // í”Œë ˆì´ì–´ë³„ ê°œì¸ ê³µê°œ ì£¼ë¬¸ìœ¼ë¡œ ì¶”ê°€
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                if (player.id === myPlayerId) {
                    // ë‚´ê°€ ì‚¬ìš©í•œ ê²½ìš° - ë‚˜ì—ê²Œë§Œ ê³µê°œ
                    if (!state.personalRevealedStones) {
                        state.personalRevealedStones = [];
                    }
                    state.personalRevealedStones.push(...revealedStones);
                    console.log(`ğŸ”® ë‚˜ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸: [${revealedStones.join(', ')}]`);
                    addLog(Messages.reveal(revealedStones) + ' (ë‚˜ì—ê²Œë§Œ ê³µê°œ)');
                        
                        // ê³µê°œëœ ì£¼ë¬¸ë“¤ì˜ ì•„ì´ì½˜ê³¼ í•¨ê»˜ íŒì—… í‘œì‹œ
                        const revealedIcons = revealedStones.map(stone => `${SpellIcons[stone] || 'â“'}${stone}`).join(', ');
                    await showModal('ğŸ”® ìš´ëª… ë³€í™˜', `ë¹„ë°€ ì£¼ë¬¸ [${revealedIcons}]${getJosa(revealedStones.length.toString(), 'ì´/ê°€')} ë‚˜ì—ê²Œë§Œ ê³µê°œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                } else {
                    // ìƒëŒ€ê°€ ì‚¬ìš©í•œ ê²½ìš° - ìƒëŒ€ì—ê²Œë§Œ ê³µê°œ (ë‚˜ëŠ” ì •ë³´ë¥¼ ë³¼ ìˆ˜ ì—†ìŒ)
                    if (!state.opponentPersonalRevealedStones) {
                        state.opponentPersonalRevealedStones = [];
                    }
                    state.opponentPersonalRevealedStones.push(...revealedStones);
                    console.log(`ğŸ”® ìƒëŒ€ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸: [${revealedStones.join(', ')}]`);
                    addLog(Messages.reveal(revealedStones) + ' (ìƒëŒ€ì—ê²Œë§Œ ê³µê°œ)');
                    
                    await showModal('ğŸ”® ìš´ëª… ë³€í™˜', `ìƒëŒ€ê°€ ë¹„ë°€ ì£¼ë¬¸ ${revealedStones.length}ê°œë¥¼ ë‚˜ì—ê²Œë§Œ ê³µê°œí–ˆìŠµë‹ˆë‹¤.`);
                }
                
                // íƒ€ì´ë¨¸ ì´ˆê¸°í™” ê¸°ëŠ¥ ì œê±°ë¨
                    } else {
                        await showModal('ğŸ”® ìš´ëª… ë³€í™˜', 'ê³µê°œí•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
        }

        // ì£¼ë¬¸ íš¨ê³¼ ì‹¤í–‰ í•¨ìˆ˜
        async function executeSpellEffect(playerId, spellNumber) {
            console.log(`âœ¨ ì˜ì°½ íš¨ê³¼ ì‹¤í–‰: í”Œë ˆì´ì–´ ${playerId}, ì˜ì°½ ${spellNumber}`);
            
            if (!GameConditions.isGameValid()) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ì˜ì°½ íš¨ê³¼ ì‹¤í–‰ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const player = state.players.find(p => p.id === playerId);
            const opponent = state.players.find(p => p.id !== playerId);
            
            if (!player || !opponent) {
                console.log('âš ï¸ í”Œë ˆì´ì–´ ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ì˜ì°½ íš¨ê³¼ ì‹¤í–‰ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const spellEffects = {
                6: () => executeMeditation(player, opponent),
                5: () => executeHealPotion(player, opponent),
                4: () => executeFireArrow(player, opponent),
                3: () => executeMindControl(player, opponent, playerId),
                2: () => executeManaDrain(player, opponent),
                1: () => executeDestinyChange(player, opponent)
            };
            
            const effect = spellEffects[spellNumber];
            if (effect) {
                await effect();
            }
            
            render();
            await sleep(1000);
            checkGameOver();
            
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            if (state.currentPlayerId === myPlayerId && state.isPlayerTurn) {
                setTimeout(() => {
                    enableSpellButtons();
                }, 500);
            }
        }

        // AI í„´ ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function getAIName() {
            return multiplayerMode ? state.players[1].name : 
                   (aiDifficulty === 'easy' ? 'ğŸ¤– ì‰¬ì›€ í—ˆìˆ˜ì•„ë¹„' : 
                    aiDifficulty === 'normal' ? 'ğŸ¤– ë³´í†µ í—ˆìˆ˜ì•„ë¹„' : 'ğŸ¤– ì–´ë ¤ì›€ í—ˆìˆ˜ì•„ë¹„');
        }

        function getCastableSpells(ai) {
            if (!ai || !ai.hand) {
                console.warn('âš ï¸ getCastableSpells: ai ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ');
                return [];
            }
            return ai.hand.filter(s => s >= state.lastSuccessfulSpell);
        }

        /**
         * AI í„´ ì‹¤í–‰ (ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜)
         * @param {Object} ai - AI í”Œë ˆì´ì–´ ì •ë³´
         * @param {Object} player - ì¸ê°„ í”Œë ˆì´ì–´ ì •ë³´
         * @returns {Promise<boolean>} í„´ ì‹¤í–‰ ê²°ê³¼
         */
        async function executeAITurn(ai, player) {
            const opponentName = getAIName();
            console.log(`ğŸ¤– ${opponentName} í„´ ì‹œì‘`);
            
            // AI ì£¼ë¬¸ ì„ íƒ (ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜)
            const castableSpells = getCastableSpells(ai);
            if (castableSpells.length === 0) {
                console.log(`âŒ ${opponentName} ì‹œì „ ê°€ëŠ¥í•œ ì£¼ë¬¸ì´ ì—†ìŒ`);
                return false;
            }
            
            // ìƒˆë¡œìš´ ì§€ëŠ¥ì  AI ì£¼ë¬¸ ì„ íƒ ì‹œìŠ¤í…œ ì‚¬ìš©
            const chosenSpell = chooseAISpell(castableSpells, ai, player);
            console.log(`ğŸ¯ ${opponentName} ì„ íƒí•œ ì£¼ë¬¸: ${chosenSpell}ë²ˆ`);
            
            // AI ì˜ì°½ ì‹¤í–‰
            return await executeAISpell(ai, player, chosenSpell, opponentName);
        }

        async function executeAISpell(ai, player, chosenSpell, opponentName) {
            // ìƒˆë¡œìš´ AI ì˜ì°½ ì‹œìŠ¤í…œ
            const successRate = getAISuccessRate();
            const randomValue = Math.random();
            const isSuccess = randomValue < successRate;
            
            console.log(`ğŸ¤– AI ì˜ì°½ ì‹œìŠ¤í…œ: ì„ íƒì£¼ë¬¸=${chosenSpell}, ì†íŒ¨=${ai.hand}, ì„±ê³µë¥ =${(successRate * 100).toFixed(1)}%, ëœë¤ê°’=${randomValue.toFixed(3)}, ì„±ê³µì—¬ë¶€=${isSuccess}`);
            
            if (isSuccess) {
                // ì„±ê³µ ì‹œ: ì†íŒ¨ì—ì„œ í•´ë‹¹ ì£¼ë¬¸ì„ ì‹¤ì œë¡œ ì˜ì°½
                const handIndex = ai.hand.indexOf(chosenSpell);
                if (handIndex > -1) {
                    return await handleAISpellSuccess(ai, chosenSpell, opponentName);
                } else {
                    // ì†íŒ¨ì— í•´ë‹¹ ì£¼ë¬¸ì´ ì—†ëŠ” ê²½ìš° (ì´ë¡ ì ìœ¼ë¡œëŠ” ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨)
                    console.log(`âš ï¸ AI ì„±ê³µí–ˆì§€ë§Œ ì†íŒ¨ì— ${chosenSpell}ë²ˆì´ ì—†ìŒ - ì‹¤íŒ¨ ì²˜ë¦¬`);
                    return await handleAISpellFailure(ai, chosenSpell, opponentName);
                }
            } else {
                // ì‹¤íŒ¨ ì‹œ: ì†íŒ¨ì— ì—†ëŠ” ì£¼ë¬¸ì„ ì˜ì°½í•˜ë ¤ê³  ì‹œë„
                const availableSpells = [1, 2, 3, 4, 5, 6];
                const missingSpells = availableSpells.filter(spell => !ai.hand.includes(spell));
                
                if (missingSpells.length > 0) {
                    // ì†íŒ¨ì— ì—†ëŠ” ì£¼ë¬¸ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒ
                    const failedSpell = missingSpells[Math.floor(Math.random() * missingSpells.length)];
                    console.log(`âŒ AI ì‹¤íŒ¨: ${chosenSpell}ë²ˆ ëŒ€ì‹  ${failedSpell}ë²ˆì„ ì˜ì°½í•˜ë ¤ê³  ì‹œë„ (ì†íŒ¨ì— ì—†ìŒ)`);
                    return await handleAISpellFailure(ai, failedSpell, opponentName);
                } else {
                    // ëª¨ë“  ì£¼ë¬¸ì´ ì†íŒ¨ì— ìˆëŠ” ê²½ìš° (ì´ë¡ ì ìœ¼ë¡œëŠ” 100% ì„±ê³µí•´ì•¼ í•¨)
                    console.log(`âš ï¸ AI ì†íŒ¨ì— ëª¨ë“  ì£¼ë¬¸ì´ ìˆìŒ - ì„±ê³µ ì²˜ë¦¬`);
                    return await handleAISpellSuccess(ai, chosenSpell, opponentName);
                }
            }
        }

        async function handleAISpellSuccess(ai, chosenSpell, opponentName) {
            const castedStone = ai.hand.splice(ai.hand.indexOf(chosenSpell), 1)[0];
                    state.usedStones.push(castedStone);
                    console.log(`âœ… ${opponentName} ì˜ì°½ ì„±ê³µ: ${chosenSpell}ë²ˆ (ì‚¬ìš©ëœ ì£¼ë¬¸: ${castedStone})`);
                    
                    playSuccessSound();
                    addSuccessAnimation(opponentArea);
                    
                    // AI ì˜ì°½ ì„±ê³µ íŒŒí‹°í´ íš¨ê³¼
                    createModalParticles(chosenSpell);
                    
            addLog(Messages.spellSuccess(opponentName, chosenSpell));
                    render();
            
                    await executeSpellEffect(2, chosenSpell);
                    state.lastSuccessfulSpell = chosenSpell;
                    
            if (GameConditions.isMultiplayerConnected()) {
                        dataChannel.send(JSON.stringify({
                            type: 'cardPlayed',
                            card: chosenSpell,
                            playerId: 2,
                            gameState: state
                        }));
                    }
                    
            return true;
        }

        async function handleAISpellFailure(ai, chosenSpell, opponentName) {
                    const currentPlayer = state.players.find(p => p.id === state.currentPlayerId);
                    currentPlayer.health--;
                    console.log(`âŒ ${opponentName} ì˜ì°½ ì‹¤íŒ¨: ${chosenSpell}ë²ˆ (í”Œë ˆì´ì–´ ${currentPlayer.id} ì²´ë ¥: ${currentPlayer.health})`);
                    
                    playFailureSound();
                    addFailureAnimation(opponentArea);
                    showDamageEffect(opponentArea, 1);
                    
                    // AI ì˜ì°½ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™”
                    spellButtonsDisabled = true;
                    state.spellFailed = true; // ì˜ì°½ ì‹¤íŒ¨ í”Œë˜ê·¸ ì„¤ì •
                    disableSpellButtons();
                    
                    // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ì¦‰ì‹œ ë¹„í™œì„±í™”
                    endTurnBtn.disabled = true;
                    endTurnBtn.style.opacity = '0.5';
                    endTurnBtn.style.cursor = 'not-allowed';
                    
                    // AI ì˜ì°½ ì‹¤íŒ¨ íŒì—… í‘œì‹œ
                    await showModal('ì˜ì°½ ì‹¤íŒ¨', `${opponentName} ${chosenSpell}ë²ˆ ì£¼ë¬¸ ì˜ì°½ ì‹¤íŒ¨<br>ì²´ë ¥ -1 (í˜„ì¬: ${currentPlayer.health})`);
                    
                    addLog(Messages.spellFailure(opponentName, chosenSpell));
                    
                    // ê²Œì„ ë¡œê·¸ë§Œ ì—…ë°ì´íŠ¸í•˜ê³  ë²„íŠ¼ ìƒíƒœëŠ” ìœ ì§€
                    const gameLogEl = DOM.get('game-log');
                    if (gameLogEl) {
                        gameLogEl.innerHTML = state.gameLog.map(log => {
                            const isSuccess = log.includes('âœ…');
                            const isFailure = log.includes('âŒ');
                            const isTurn = log.includes('í„´');
                            const isGameEnd = log.includes('ê²Œì„ ì¢…ë£Œ');
                            
                            let className = '';
                            if (isSuccess) className = 'text-green-400';
                            else if (isFailure) className = 'text-red-400';
                            else if (isTurn) className = 'text-blue-400 font-bold';
                            else if (isGameEnd) className = 'text-purple-400 font-bold';
                            
                            return `<p class="${className}">${log}</p>`;
                        }).join('');
                    }
                    
            if (GameConditions.isMultiplayerConnected()) {
                        dataChannel.send(JSON.stringify({
                            type: 'spellPlayed',
                            spell: chosenSpell,
                            playerId: 2,
                            gameState: state
                        }));
                    }
                    
            return false;
        }

        /**
         * AI ì—°ì† ì˜ì°½ ê²°ì • (ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜)
         * @param {Object} ai - AI í”Œë ˆì´ì–´ ì •ë³´
         * @param {string} opponentName - AI ì´ë¦„
         * @returns {boolean} ì—°ì† ì˜ì°½ ì—¬ë¶€
         */
        function shouldAIContinue(ai, opponentName) {
            const gameState = AIAnalysis.analyzeGameState();
            if (!gameState) {
                // ë¶„ì„ ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ê¸°ë³¸ ë¡œì§ ì‚¬ìš©
            const continueTurn = ai.hand.length > 0 && Math.random() < getAIContinueRate();
                console.log(`ğŸ¤– ${opponentName} ì—°ì† ì˜ì°½ ê²°ì • (ê¸°ë³¸): ${continueTurn ? 'ê³„ì†' : 'ì¤‘ë‹¨'}`);
            if (!continueTurn) {
                addLog(`${opponentName}${getJosa(opponentName, 'ì´/ê°€')} ì—°ì† ì˜ì°½ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.`);
            }
                return continueTurn;
            }
            
            // ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜ ì—°ì† ì˜ì°½ ê²°ì •
            const baseContinueRate = getAIContinueRate();
            const analysisRate = AIAnalysis.evaluateSpellCastability(
                Math.max(...ai.hand.filter(s => s > state.lastSuccessfulSpell)), 
                gameState
            );
            
            // ë‚œì´ë„ë³„ ê°€ì¤‘ì¹˜ ì ìš©
            const weights = {
                easy: 0.3,    // ì‰¬ì›€: ê¸°ë³¸ í™•ë¥  70%, ë¶„ì„ 30%
                normal: 0.6,  // ë³´í†µ: ê¸°ë³¸ í™•ë¥  40%, ë¶„ì„ 60%
                hard: 0.8     // ì–´ë ¤ì›€: ê¸°ë³¸ í™•ë¥  20%, ë¶„ì„ 80%
            };
            
            const weight = weights[aiDifficulty] || 0.6;
            const finalRate = baseContinueRate * (1 - weight) + analysisRate * weight;
            
            const continueTurn = ai.hand.length > 0 && Math.random() < finalRate;
            
            console.log(`ğŸ¤– ${opponentName} ì—°ì† ì˜ì°½ ê²°ì • (ì§€ëŠ¥ì ): ${continueTurn ? 'ê³„ì†' : 'ì¤‘ë‹¨'} (ê¸°ë³¸: ${(baseContinueRate * 100).toFixed(1)}%, ë¶„ì„: ${(analysisRate * 100).toFixed(1)}%, ìµœì¢…: ${(finalRate * 100).toFixed(1)}%)`);
            
            if (!continueTurn) {
                addLog(`${opponentName}${getJosa(opponentName, 'ì´/ê°€')} ì—°ì† ì˜ì°½ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.`);
            }
            
            return continueTurn;
        }

        async function aiTurn() {
            if (!GameConditions.isGameValid()) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ AI í„´ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const ai = state.players[1];
            const player = state.players[0];
            const opponentName = getAIName();
            
            // AI ë¶„ì„ ì •ë³´ ì¶œë ¥
            const gameState = AIAnalysis.analyzeGameState();
            if (gameState) {
                console.log(`ğŸ§  ${opponentName} ë¶„ì„ ì •ë³´:`, {
                    ë‚œì´ë„: aiDifficulty,
                    AIì†íŒ¨: ai.hand,
                    í”Œë ˆì´ì–´ì†íŒ¨: gameState.humanHand,
                    ê³µê°œëœë¹„ë°€ì£¼ë¬¸: gameState.secretStones,
                    ì‚¬ìš©ëœì£¼ë¬¸: gameState.usedStones,
                    AIì²´ë ¥: gameState.aiHealth,
                    í”Œë ˆì´ì–´ì²´ë ¥: gameState.humanHealth,
                    ë§ˆì§€ë§‰ì„±ê³µì£¼ë¬¸: gameState.lastSuccessfulSpell
                });
            }
            
            console.log(`ğŸ¤– ${opponentName} í„´ ì‹œì‘ (ë‚œì´ë„: ${aiDifficulty}, ì†íŒ¨: ${ai.hand})`);
            addLog(Messages.turnStart(opponentName));
            state.turnInProgress = true;
            updateButtons();

            let continueTurn = true;
            while(continueTurn && !state.isGameOver) {
                await sleep(1500);
                
                const castableSpells = getCastableSpells(ai);
                
                console.log(`ğŸ¤– AI ê°€ëŠ¥í•œ ì˜ì°½: [${castableSpells.join(', ')}] (ë§ˆì§€ë§‰ ì„±ê³µ: ${state.lastSuccessfulSpell})`);

                if (castableSpells.length === 0) {
                    console.log(`ğŸ¤– ${opponentName} ì‹¤í–‰ ê°€ëŠ¥í•œ ì˜ì°½ ì—†ìŒ`);
                    addLog(`${opponentName}${getJosa(opponentName, 'ì´/ê°€')} ì‹œì „í•  ìˆ˜ ìˆëŠ” ì˜ì°½ì´ ì—†ìŠµë‹ˆë‹¤.`);
                    break;
                }

                const chosenSpell = chooseAISpell(castableSpells, ai, player);
                console.log(`ğŸ¤– AI ì„ íƒí•œ ì˜ì°½: ${chosenSpell} (í”Œë ˆì´ì–´ ì²´ë ¥: ${player.health}, AI ì²´ë ¥: ${ai.health})`);
                
                const success = await executeAISpell(ai, player, chosenSpell, opponentName);
                
                if (checkGameOver()) break;
                
                if (success) {
                    continueTurn = shouldAIContinue(ai, opponentName);
                } else {
                    continueTurn = false;
                }
            }
            
            state.turnInProgress = false;
            endTurn();
        }
        
        // AI ì˜ì°½ ì„ íƒ í•¨ìˆ˜ (ë‚œì´ë„ë³„)
        function chooseAISpell(castableSpells, ai, player) {
            const aiStrategies = {
                easy: chooseEasyAISpell,
                normal: chooseNormalAISpell,
                hard: chooseHardAISpell
            };
            
            const strategy = aiStrategies[aiDifficulty] || chooseNormalAISpell;
            return strategy(castableSpells, ai, player);
        }
        
        // ì‰¬ìš´ AI ì˜ì°½ ì„ íƒ
        function chooseEasyAISpell(castableSpells, ai, player) {
            // ëœë¤í•˜ê²Œ ì„ íƒí•˜ê±°ë‚˜ ê°„ë‹¨í•œ ê·œì¹™ë§Œ ì‚¬ìš©
            if (Math.random() < 0.3) {
                return castableSpells[Math.floor(Math.random() * castableSpells.length)];
            }
            
            // ê¸°ë³¸ì ì¸ ê·œì¹™ë§Œ ì ìš©
            if (castableSpells.includes(4) && player.health <= 1) return 4;
            if (castableSpells.includes(5) && ai.health <= 2) return 5;
            
            return Math.max(...castableSpells);
        }
        
        // ë³´í†µ AI ì˜ì°½ ì„ íƒ (ê¸°ì¡´ ë¡œì§)
        function chooseNormalAISpell(castableSpells, ai, player) {
            if (castableSpells.includes(4) && player.health <= (state.lastSuccessfulSpell > 0 ? 2 : 1)) return 4;
            if (castableSpells.includes(2) && player.health <= 1) return 2;
            if (castableSpells.includes(5) && player.health <= 1) return 5;
            if (ai.health <= 2 && castableSpells.includes(1)) return 1;
            if (ai.health <= 2 && castableSpells.includes(2)) return 2;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            return Math.max(...castableSpells);
        }
        
        /**
         * AI ì£¼ë¬¸ ì„ íƒ ì‹œìŠ¤í…œ (ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜)
         * @param {Array} castableSpells - ì‹œì „ ê°€ëŠ¥í•œ ì£¼ë¬¸ë“¤
         * @param {Object} ai - AI í”Œë ˆì´ì–´ ì •ë³´
         * @param {Object} player - ì¸ê°„ í”Œë ˆì´ì–´ ì •ë³´
         * @returns {number} ì„ íƒëœ ì£¼ë¬¸ ë²ˆí˜¸
         */
        function chooseAISpell(castableSpells, ai, player) {
            const gameState = AIAnalysis.analyzeGameState();
            if (!gameState) {
                // ë¶„ì„ ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ê¸°ë³¸ ë¡œì§ ì‚¬ìš©
                return chooseBasicAISpell(castableSpells, ai, player);
            }
            
            // ë‚œì´ë„ë³„ ì „ëµ ì ìš©
            switch (aiDifficulty) {
                case 'easy':
                    return chooseEasyAISpell(castableSpells, ai, player, gameState);
                case 'normal':
                    return chooseNormalAISpell(castableSpells, ai, player, gameState);
                case 'hard':
                    return chooseHardAISpell(castableSpells, ai, player, gameState);
                default:
                    return chooseNormalAISpell(castableSpells, ai, player, gameState);
            }
        }
        
        /**
         * ì‰¬ìš´ AI ì£¼ë¬¸ ì„ íƒ (ê¸°ë³¸ ë¡œì§ + ì•½ê°„ì˜ ë¶„ì„)
         */
        function chooseEasyAISpell(castableSpells, ai, player, gameState) {
            // ê¸°ë³¸ ì „ëµ (ì²´ë ¥ ê¸°ë°˜)
            if (player.health <= 2 && castableSpells.includes(4)) return 4;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            // ì•½ê°„ì˜ ë¶„ì„ ì ìš© (30% í™•ë¥ ë¡œ)
            if (Math.random() < 0.3) {
                const bestSpell = findBestSpellByAnalysis(castableSpells, gameState);
                if (bestSpell) return bestSpell;
            }
            
            // ê¸°ë³¸ì ìœ¼ë¡œ ëœë¤ ì„ íƒ
            return castableSpells[Math.floor(Math.random() * castableSpells.length)];
        }
        
        /**
         * ë³´í†µ AI ì£¼ë¬¸ ì„ íƒ (ë¶„ì„ + ì „ëµ)
         */
        function chooseNormalAISpell(castableSpells, ai, player, gameState) {
            // ì²´ë ¥ ê¸°ë°˜ ì „ëµ
            if (player.health <= 2 && castableSpells.includes(4)) return 4;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            // ì •ë³´ ìˆ˜ì§‘ (ë¹„ë°€ ì£¼ë¬¸ì´ ë§ì„ ë•Œ)
            if (castableSpells.includes(6) && gameState.secretStones.length > 2) return 6;
            
            // ë¶„ì„ ê¸°ë°˜ ì„ íƒ (70% í™•ë¥ )
            if (Math.random() < 0.7) {
                const bestSpell = findBestSpellByAnalysis(castableSpells, gameState);
                if (bestSpell) return bestSpell;
            }
            
            // ì „ëµì  ì„ íƒ
            return chooseStrategicSpell(castableSpells, ai, player);
        }
        
        /**
         * ì–´ë ¤ìš´ AI ì£¼ë¬¸ ì„ íƒ (ì •í™•í•œ ë¶„ì„ + ê³ ê¸‰ ì „ëµ)
         */
        function chooseHardAISpell(castableSpells, ai, player, gameState) {
            // ì²´ë ¥ ê¸°ë°˜ ì „ëµ
            if (player.health <= 2 && castableSpells.includes(4)) return 4;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            // ì •ë³´ ìˆ˜ì§‘ (í•­ìƒ ìš°ì„ )
            if (castableSpells.includes(6) && gameState.secretStones.length > 0) return 6;
            
            // ì •í™•í•œ ë¶„ì„ ê¸°ë°˜ ì„ íƒ (90% í™•ë¥ )
            if (Math.random() < 0.9) {
                const bestSpell = findBestSpellByAnalysis(castableSpells, gameState);
                if (bestSpell) return bestSpell;
            }
            
            // ê³ ê¸‰ ì „ëµ
            return chooseAdvancedStrategicSpell(castableSpells, ai, player, gameState);
        }
        
        /**
         * ë¶„ì„ ê¸°ë°˜ ìµœì  ì£¼ë¬¸ ì°¾ê¸°
         */
        function findBestSpellByAnalysis(castableSpells, gameState) {
            let bestSpell = null;
            let bestScore = -1;
            
            for (const spell of castableSpells) {
                const probability = AIAnalysis.evaluateSpellCastability(spell, gameState);
                const strategicScore = calculateStrategicScore(spell, gameState);
                const totalScore = probability * 0.7 + strategicScore * 0.3;
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestSpell = spell;
                }
            }
            
            return bestSpell;
        }
        
        /**
         * ì£¼ë¬¸ì˜ ì „ëµì  ì ìˆ˜ ê³„ì‚°
         */
        function calculateStrategicScore(spell, gameState) {
            const { aiHealth, humanHealth } = gameState;
            
            switch (spell) {
                case 1: // ìš´ëª… ë³€í™˜ - ì •ë³´ ìˆ˜ì§‘
                    return gameState.secretStones.length > 2 ? 0.8 : 0.3;
                case 2: // ë§ˆë ¥ ì°©ì·¨ - ê· í˜•
                    return (humanHealth > aiHealth) ? 0.9 : 0.5;
                case 3: // ì •ì‹  êµë€ - êµë€
                    return gameState.secretStones.length > 0 ? 0.7 : 0.2;
                case 4: // í™”ì—¼ í™”ì‚´ - ê³µê²©
                    return humanHealth <= 2 ? 0.9 : 0.6;
                case 5: // ìƒëª… ë¬¼ì•½ - íšŒë³µ
                    return aiHealth <= 2 ? 0.9 : 0.4;
                case 6: // ëª…ìƒ - ì •ë³´
                    return gameState.secretStones.length > 0 ? 0.8 : 0.3;
                default:
                    return 0.5;
            }
        }
        
        /**
         * ê¸°ë³¸ ì „ëµì  ì£¼ë¬¸ ì„ íƒ
         */
        function chooseStrategicSpell(castableSpells, ai, player) {
            // ê³µê²© ìš°ì„ 
            if (castableSpells.includes(4) && player.health <= 2) return 4;
            if (castableSpells.includes(2) && player.health <= 2) return 2;
            
            // íšŒë³µ ìš°ì„ 
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            // ì •ë³´ ìˆ˜ì§‘
            if (castableSpells.includes(6) && state.secretStones.length > 0) return 6;
            
            // êµë€
            if (castableSpells.includes(3) && state.secretStones.length > 0) return 3;
            
            return Math.max(...castableSpells);
        }
        
        /**
         * ê³ ê¸‰ ì „ëµì  ì£¼ë¬¸ ì„ íƒ
         */
        function chooseAdvancedStrategicSpell(castableSpells, ai, player, gameState) {
            // ì²´ë ¥ ì°¨ì´ ë¶„ì„
            const healthDiff = ai.health - player.health;
            
            // AIê°€ ìœ ë¦¬í•œ ìƒí™©
            if (healthDiff > 1) {
                // ê³µê²©ìœ¼ë¡œ ìŠ¹ë¦¬ í™•ì •
                if (castableSpells.includes(4) && player.health <= 2) return 4;
                if (castableSpells.includes(2) && player.health <= 2) return 2;
            }
            
            // AIê°€ ë¶ˆë¦¬í•œ ìƒí™©
            if (healthDiff < -1) {
                // íšŒë³µ ìš°ì„ 
                if (castableSpells.includes(5) && ai.health <= 2) return 5;
                // ì •ë³´ ìˆ˜ì§‘ìœ¼ë¡œ ì—­ì „ ê¸°íšŒ ëª¨ìƒ‰
                if (castableSpells.includes(6) && gameState.secretStones.length > 0) return 6;
            }
            
            // ê· í˜• ìƒí™©
            if (castableSpells.includes(2)) return 2; // ë§ˆë ¥ ì°©ì·¨ë¡œ ê· í˜• ìœ ì§€
            if (castableSpells.includes(6) && gameState.secretStones.length > 0) return 6; // ì •ë³´ ìˆ˜ì§‘
            
            return Math.max(...castableSpells);
        }
        
        /**
         * ê¸°ë³¸ AI ì£¼ë¬¸ ì„ íƒ (ê¸°ì¡´ ë¡œì§)
         */
        function chooseBasicAISpell(castableSpells, ai, player) {
            // ê³µê²© ìš°ì„  (í”Œë ˆì´ì–´ ì²´ë ¥ì´ ë‚®ì„ ë•Œ)
            if (castableSpells.includes(4) && player.health <= 2) return 4;
            if (castableSpells.includes(2) && player.health <= 2) return 2;
            
            // íšŒë³µ ìš°ì„  (AI ì²´ë ¥ì´ ë‚®ì„ ë•Œ)
            if (ai.health <= 2 && castableSpells.includes(1)) return 1;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            // ì „ì„¸ ì—­ì „ (ìƒí™©ì´ ì¢‹ì§€ ì•Šì„ ë•Œ)
            if (ai.health <= 2 && castableSpells.includes(1)) return 1;
            
            // ì •ì°° ì‘ì „ (ì •ë³´ ìˆ˜ì§‘)
            if (castableSpells.includes(6) && state.secretStones.length > 0) return 6;
            
            // ìŠ¤íŒŒì´ íˆ¬ì… (ìƒëŒ€ íŒ¨ êµë€)
            if (castableSpells.includes(3) && state.secretStones.length > 0) return 3;
            
            return Math.max(...castableSpells);
        }
        
        /**
         * AI ë¶„ì„ ì‹œìŠ¤í…œ
         * ìƒëŒ€ì˜ íŒ¨ì™€ ê³µê°œëœ ë¹„ë°€ ì¹´ë“œë¥¼ ë¶„ì„í•˜ì—¬ ìì‹ ì˜ íŒ¨ë¥¼ ìœ ì¶”
         */
        const AIAnalysis = {
            /**
             * ê²Œì„ ìƒíƒœ ë¶„ì„
             * @returns {Object} ë¶„ì„ ê²°ê³¼
             */
            analyzeGameState() {
                if (!state || !state.players) return null;
                
                const aiPlayer = state.players.find(p => p.id === 2); // AIëŠ” í•­ìƒ í”Œë ˆì´ì–´ 2
                const humanPlayer = state.players.find(p => p.id === 1);
                
                if (!aiPlayer || !humanPlayer) return null;
                
                return {
                    aiPlayer: aiPlayer, // AI í”Œë ˆì´ì–´ ê°ì²´ ì „ì²´
                    humanPlayer: humanPlayer, // ì¸ê°„ í”Œë ˆì´ì–´ ê°ì²´ ì „ì²´
                    aiHand: aiPlayer.hand,
                    humanHand: humanPlayer.hand,
                    secretStones: state.secretStones || [],
                    usedStones: state.usedStones || [],
                    aiHealth: aiPlayer.health,
                    humanHealth: humanPlayer.health,
                    lastSuccessfulSpell: state.lastSuccessfulSpell || 0
                };
            },
            
            /**
             * ìƒëŒ€ì˜ íŒ¨ì—ì„œ íŠ¹ì • ì£¼ë¬¸ ê°œìˆ˜ ê³„ì‚°
             * @param {Array} opponentHand - ìƒëŒ€ì˜ íŒ¨
             * @param {number} spellNumber - ì£¼ë¬¸ ë²ˆí˜¸
             * @returns {number} ê°œìˆ˜
             */
            countSpellInHand(opponentHand, spellNumber) {
                return opponentHand.filter(card => card === spellNumber).length;
            },
            
            /**
             * ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸ì—ì„œ íŠ¹ì • ì£¼ë¬¸ ê°œìˆ˜ ê³„ì‚°
             * @param {Array} secretStones - ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸
             * @param {number} spellNumber - ì£¼ë¬¸ ë²ˆí˜¸
             * @returns {number} ê°œìˆ˜
             */
            countSpellInSecret(secretStones, spellNumber) {
                return secretStones.filter(stone => stone === spellNumber).length;
            },
            
            /**
             * ìì‹ ì˜ íŒ¨ì—ì„œ íŠ¹ì • ì£¼ë¬¸ì´ ìˆì„ í™•ë¥  ê³„ì‚°
             * @param {number} spellNumber - ì£¼ë¬¸ ë²ˆí˜¸
             * @param {Object} gameState - ê²Œì„ ìƒíƒœ
             * @returns {number} í™•ë¥  (0~1)
             */
            calculateSpellProbability(spellNumber, gameState) {
                const { humanHand, secretStones, usedStones } = gameState;
                
                // ì „ì²´ ë±ì—ì„œ í•´ë‹¹ ì£¼ë¬¸ì˜ ê°œìˆ˜
                const totalSpellCount = spellNumber; // 1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ...
                
                // ì´ë¯¸ ì‚¬ìš©ëœ ê°œìˆ˜
                const usedCount = usedStones.filter(stone => stone === spellNumber).length;
                
                // ìƒëŒ€ íŒ¨ì— ìˆëŠ” ê°œìˆ˜
                const opponentCount = this.countSpellInHand(humanHand, spellNumber);
                
                // ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸ì— ìˆëŠ” ê°œìˆ˜
                const secretCount = this.countSpellInSecret(secretStones, spellNumber);
                
                // ë‚¨ì€ ê°œìˆ˜ ê³„ì‚°
                const remainingCount = totalSpellCount - usedCount - opponentCount - secretCount;
                
                // AI íŒ¨ì— ìˆì„ í™•ë¥ 
                const aiHandSize = gameState.aiHand.length;
                const totalRemainingCards = 21 - usedStones.length - humanHand.length - secretStones.length;
                
                if (totalRemainingCards <= 0 || remainingCount <= 0) return 0;
                
                // í™•ë¥  ê³„ì‚° (ë‚¨ì€ ì¹´ë“œ ì¤‘ì—ì„œ í•´ë‹¹ ì£¼ë¬¸ì´ ìˆì„ í™•ë¥ )
                return Math.min(remainingCount / totalRemainingCards, 1);
            },
            
            /**
             * ë‚œì´ë„ë³„ ë¶„ì„ ì •í™•ë„ ì¡°ì •
             * @param {number} baseProbability - ê¸°ë³¸ í™•ë¥ 
             * @returns {number} ì¡°ì •ëœ í™•ë¥ 
             */
            adjustProbabilityByDifficulty(baseProbability) {
                const difficultyFactors = {
                    easy: 0.3,    // ì‰¬ì›€: ê±°ì˜ ëœë¤
                    normal: 0.7,  // ë³´í†µ: ì–´ëŠ ì •ë„ ë¶„ì„
                    hard: 0.9     // ì–´ë ¤ì›€: ì •í™•í•œ ë¶„ì„
                };
                
                const factor = difficultyFactors[aiDifficulty] || 0.7;
                return baseProbability * factor + (1 - factor) * Math.random();
            },
            
            /**
             * ì£¼ë¬¸ ì‹œì „ ê°€ëŠ¥ì„± í‰ê°€
             * @param {number} spellNumber - ì£¼ë¬¸ ë²ˆí˜¸
             * @param {Object} gameState - ê²Œì„ ìƒíƒœ
             * @returns {number} ì‹œì „ ê°€ëŠ¥ì„± ì ìˆ˜ (0~1)
             */
            evaluateSpellCastability(spellNumber, gameState) {
                const probability = this.calculateSpellProbability(spellNumber, gameState);
                const adjustedProbability = this.adjustProbabilityByDifficulty(probability);
                
                // ë‚œì´ë„ë³„ ìµœì†Œ í™•ë¥  ì„¤ì •
                const minProbabilities = {
                    easy: 0.1,
                    normal: 0.3,
                    hard: 0.5
                };
                
                const minProb = minProbabilities[aiDifficulty] || 0.3;
                
                return Math.max(adjustedProbability, minProb);
            }
        };

        /**
         * AI ì„±ê³µë¥  ê³„ì‚° (ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜)
         * @returns {number} ì„±ê³µë¥  (0~1)
         */
        function getAISuccessRate() {
            const gameState = AIAnalysis.analyzeGameState();
            if (!gameState) {
            return GAME_CONFIG.aiSuccessRate[aiDifficulty] || GAME_CONFIG.aiSuccessRate.normal;
        }
        
            // AIê°€ ì‹œì „í•  ì£¼ë¬¸ ì„ íƒ
            const aiPlayer = state.players.find(p => p.id === 2); // AIëŠ” í•­ìƒ í”Œë ˆì´ì–´ 2
            if (!aiPlayer) {
                return GAME_CONFIG.aiSuccessRate[aiDifficulty] || GAME_CONFIG.aiSuccessRate.normal;
            }
            
            const castableSpells = getCastableSpells(aiPlayer);
            if (castableSpells.length === 0) return 0;
            
            // ê°€ì¥ ë†’ì€ í™•ë¥ ì˜ ì£¼ë¬¸ ì„ íƒ
            let bestSpell = castableSpells[0];
            let bestProbability = 0;
            
            for (const spell of castableSpells) {
                const probability = AIAnalysis.evaluateSpellCastability(spell, gameState);
                if (probability > bestProbability) {
                    bestProbability = probability;
                    bestSpell = spell;
                }
            }
            
            // ë‚œì´ë„ë³„ ê¸°ë³¸ ì„±ê³µë¥ ê³¼ ë¶„ì„ ê¸°ë°˜ ì„±ê³µë¥ ì„ ì¡°í•©
            const baseRate = GAME_CONFIG.aiSuccessRate[aiDifficulty] || GAME_CONFIG.aiSuccessRate.normal;
            const analysisRate = bestProbability;
            
            // ë‚œì´ë„ë³„ ê°€ì¤‘ì¹˜
            const weights = {
                easy: 0.3,    // ì‰¬ì›€: ê¸°ë³¸ ì„±ê³µë¥  70%, ë¶„ì„ 30%
                normal: 0.6,  // ë³´í†µ: ê¸°ë³¸ ì„±ê³µë¥  40%, ë¶„ì„ 60%
                hard: 0.8     // ì–´ë ¤ì›€: ê¸°ë³¸ ì„±ê³µë¥  20%, ë¶„ì„ 80%
            };
            
            const weight = weights[aiDifficulty] || 0.6;
            return baseRate * (1 - weight) + analysisRate * weight;
        }
        
        /**
         * AI ì—°ì† ì˜ì°½ í™•ë¥  ê³„ì‚° (ì§€ëŠ¥ì  ë¶„ì„ ê¸°ë°˜)
         * @returns {number} ì—°ì† ì˜ì°½ í™•ë¥  (0~1)
         */
        function getAIContinueRate() {
            const gameState = AIAnalysis.analyzeGameState();
            if (!gameState) {
            return GAME_CONFIG.aiContinueRate[aiDifficulty] || GAME_CONFIG.aiContinueRate.normal;
            }
            
            // í˜„ì¬ ì„±ê³µí•œ ì£¼ë¬¸ë³´ë‹¤ ë†’ì€ ì£¼ë¬¸ë“¤ì˜ í™•ë¥  ë¶„ì„
            const higherSpells = [];
            for (let i = gameState.lastSuccessfulSpell + 1; i <= 6; i++) {
                const probability = AIAnalysis.evaluateSpellCastability(i, gameState);
                higherSpells.push({ spell: i, probability });
            }
            
            if (higherSpells.length === 0) return 0;
            
            // ê°€ì¥ ë†’ì€ í™•ë¥ ì˜ ì£¼ë¬¸ ì°¾ê¸°
            const bestSpell = higherSpells.reduce((best, current) => 
                current.probability > best.probability ? current : best
            );
            
            // ë‚œì´ë„ë³„ ê¸°ë³¸ ì—°ì† í™•ë¥ ê³¼ ë¶„ì„ ê¸°ë°˜ í™•ë¥ ì„ ì¡°í•©
            const baseRate = GAME_CONFIG.aiContinueRate[aiDifficulty] || GAME_CONFIG.aiContinueRate.normal;
            const analysisRate = bestSpell.probability;
            
            const weights = {
                easy: 0.2,    // ì‰¬ì›€: ê¸°ë³¸ í™•ë¥  80%, ë¶„ì„ 20%
                normal: 0.5,  // ë³´í†µ: ê¸°ë³¸ í™•ë¥  50%, ë¶„ì„ 50%
                hard: 0.7     // ì–´ë ¤ì›€: ê¸°ë³¸ í™•ë¥  30%, ë¶„ì„ 70%
            };
            
            const weight = weights[aiDifficulty] || 0.5;
            return baseRate * (1 - weight) + analysisRate * weight;
        }

        function checkGameOver() {
            if (!GameConditions.isGameValid() || !state.players[0] || !state.players[1]) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ê²Œì„ ì¢…ë£Œ ì²´í¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤');
                return false;
            }
            
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const myPlayer = state.players.find(p => p.id === myPlayerId);
            const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
            
            let winner = null;
            
            console.log('ğŸ ê²Œì„ ì¢…ë£Œ ì²´í¬:', {
                myPlayerId: myPlayerId,
                myHealth: myPlayer.health,
                opponentHealth: opponentPlayer.health,
                myHandLength: myPlayer.hand.length,
                opponentHandLength: opponentPlayer.hand.length,
                myHand: myPlayer.hand,
                opponentHand: opponentPlayer.hand,
                isGameOver: state.isGameOver
            });
            
            // ì²´ë ¥ì´ 0 ì´í•˜ì¸ ê²½ìš°ê°€ ìš°ì„  (íŒ¨ë°° ì¡°ê±´)
            if (myPlayer.health <= 0) {
                console.log('ğŸ ê²Œì„ ì¢…ë£Œ ì¡°ê±´: ë‚´ ì²´ë ¥ì´ 0 ì´í•˜');
                winner = opponentPlayer;
            } else if (opponentPlayer.health <= 0) {
                console.log('ğŸ ê²Œì„ ì¢…ë£Œ ì¡°ê±´: ìƒëŒ€ ì²´ë ¥ì´ 0 ì´í•˜');
                winner = myPlayer;
            } else if (myPlayer.hand.length === 0) {
                // íŒ¨ê°€ ë¹„ì—ˆì§€ë§Œ ì²´ë ¥ì´ ë‚¨ì•„ìˆìœ¼ë©´ ìŠ¹ë¦¬
                console.log('ğŸ ê²Œì„ ì¢…ë£Œ ì¡°ê±´: ë‚´ íŒ¨ê°€ ë¹„ì–´ìˆìŒ');
                winner = myPlayer;
            } else if (opponentPlayer.hand.length === 0) {
                // ìƒëŒ€ íŒ¨ê°€ ë¹„ì—ˆì§€ë§Œ ì²´ë ¥ì´ ë‚¨ì•„ìˆìœ¼ë©´ ìŠ¹ë¦¬
                console.log('ğŸ ê²Œì„ ì¢…ë£Œ ì¡°ê±´: ìƒëŒ€ íŒ¨ê°€ ë¹„ì–´ìˆìŒ');
                winner = opponentPlayer;
            }
            
            if (winner && !state.isGameOver) {
                state.isGameOver = true;
                
                // ê²Œì„ ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
                stopTurnTimer();
                resetTurnGauge();
                
                // ìŠ¹ë¦¬/íŒ¨ë°° ë©”ì‹œì§€ ìƒì„±
                const isPlayerWin = winner.id === myPlayerId;
                let message;
                
                if (isPlayerWin) {
                    // ë‚´ê°€ ìŠ¹ë¦¬í•œ ê²½ìš°
                    if (opponentPlayer.health <= 0) {
                        message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!';
                    } else if (myPlayer.hand.length === 0) {
                        message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!';
                    } else {
                        message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ê°€ ë„ë§ì³¤ìŠµë‹ˆë‹¤!';
                    }
                } else {
                    // ë‚´ê°€ íŒ¨ë°°í•œ ê²½ìš°
                    if (myPlayer.health <= 0) {
                        message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìì‹ ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    } else if (opponentPlayer.hand.length === 0) {
                        message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìƒëŒ€ê°€ ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.';
                    } else {
                        message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ë„ë§ì¹˜ê³  ë§ì•˜ìŠµë‹ˆë‹¤.';
                    }
                }
                console.log(`ğŸ† ê²Œì„ ì¢…ë£Œ: ${winner.name} ìŠ¹ë¦¬!`);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ê²Œì„ ì¢…ë£Œ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'gameOver',
                        winner: winner.id,
                        gameState: state
                    }));
                }
                
                // ì „ì  ì—…ë°ì´íŠ¸ (ì—°ìŠ¹ ì²˜ë¦¬ í¬í•¨)
                updateStats(isPlayerWin, multiplayerMode);
                
                // ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                if (socket && socket.connected) {
                    const playerName = localStorage.getItem('playerName') || 'Player';
                    const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                    const trophies = TrophySystem.loadTrophies();
                    
                    // í˜„ì¬ ì ìˆ˜ë¡œ ë­í‚¹ ì—…ë°ì´íŠ¸
                    socket.emit('updateRanking', {
                        category: multiplayerMode ? 'formal' : 'mock',
                        playerName: playerName,
                        score: multiplayerMode ? trophies.multiplayer : trophies.ai,
                        icon: playerIcon
                    });
                    
                    console.log(`ğŸ”„ ê²Œì„ ì¢…ë£Œ í›„ ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸: ${playerName} (${multiplayerMode ? 'ì •ì‹' : 'ëª¨ì˜'} ê²°íˆ¬)`);
                }
                
                // ì—°ìŠ¹ ë©”ì‹œì§€ ì¶”ê°€ (updateStatsì—ì„œ ì²˜ë¦¬ëœ ì—°ìŠ¹ ì‚¬ìš©)
                if (isPlayerWin && currentWinStreak >= 2) {
                    message += `\n\n${Messages.streak(currentWinStreak)}`;
                }
                
                // ê³„ì • ì‹œìŠ¤í…œê³¼ ì—°ë™ëœ ê²Œì„ ê²°ê³¼ ì—…ë°ì´íŠ¸
                const gameType = multiplayerMode ? 'formal' : 'mock';
                const opponentName = multiplayerMode ? (opponentPlayer.name || 'ìƒëŒ€ë°©') : 'AI í—ˆìˆ˜ì•„ë¹„';
                
                // ì„œë²„ë¡œ ê²Œì„ ê²°ê³¼ ì „ì†¡ (ê³„ì • ìœ ì €ë§Œ)
                updateGameResult(gameType, isPlayerWin, opponentName);
                
                // ê¸°ì¡´ ì¦í‘œ ì‹œìŠ¤í…œ (ê²ŒìŠ¤íŠ¸ ëª¨ë“œìš©)
                if (isPlayerWin) {
                    if (multiplayerMode) {
                        TrophySystem.addVictoryTrophy('multiplayer');
                    } else {
                        TrophySystem.addVictoryTrophy('ai');
                    }
                } else {
                    if (multiplayerMode) {
                        TrophySystem.addDefeatTrophy('multiplayer');
                    } else {
                        TrophySystem.addDefeatTrophy('ai');
                    }
                }
                
                // ìŠ¹ì  ë³€í™” ë©”ì‹œì§€ ì¶”ê°€ (ìŠ¹ë¦¬/íŒ¨ë°° ëª¨ë‘ í‘œì‹œ)
                const trophyType = multiplayerMode ? 'multiplayer' : 'ai';
                const trophyChange = isPlayerWin ? '+3' : '-1';
                const trophyMessage = `\n\nğŸ… ìŠ¹ì  ${trophyChange}`;
                message += trophyMessage;
                
                // ìƒˆë¡œê³ ì¹¨ ì•ˆë‚´ ë©”ì‹œì§€ ì¶”ê°€
                message += `\n\nğŸ”„ 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ìƒˆë¡œê³ ì¹¨ë©ë‹ˆë‹¤.`;
                
                // ìŠ¹ë¦¬/íŒ¨ë°° ì‚¬ìš´ë“œ
                activateAudioContext();
                playGameOverSound(winner.id === myPlayerId);
                
                showModal('ê²Œì„ ì¢…ë£Œ', message, true);
                addLog(`- ê²Œì„ ì¢…ë£Œ: ${winner.name} ìŠ¹ë¦¬! -`);
                render();
                
                // ê²Œì„ ì¢…ë£Œ í›„ 3ì´ˆ ë’¤ ìë™ ìƒˆë¡œê³ ì¹¨
                setTimeout(() => {
                    console.log('ğŸ”„ ê²Œì„ ì¢…ë£Œ í›„ ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
                    window.location.reload();
                }, 3000);
                
                return true;
            }
            return false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ë””ë²„ê·¸ í•¨ìˆ˜ë“¤
        function showDebugInfo() {
            const player = state.players[0];
            const ai = state.players[1];
            debugInfo.innerHTML = `
                <div>í”Œë ˆì´ì–´ ì²´ë ¥: ${player.health}</div>
                <div>AI ì²´ë ¥: ${ai.health}</div>
                <div>í”Œë ˆì´ì–´ ì†íŒ¨: [${player.hand.join(', ')}]</div>
                <div>AI ì†íŒ¨: [${ai.hand.join(', ')}]</div>
                <div>ë¹„ë°€ ì „ìˆ : ${state.secretStones.length}ê°œ</div>
                <div>ì‚¬ìš©í•œ ì „ìˆ : ${state.usedStones.length}ê°œ</div>
                <div>ë§ˆì§€ë§‰ ì„±ê³µ ì „ëµ: ${state.lastSuccessfulSpell}</div>
                <div>ê²Œì„ ì¢…ë£Œ: ${state.isGameOver}</div>
            `;
        }

        function showPlayerHand() {
            const player = state.players[0];
            showCardListModal('í”Œë ˆì´ì–´ ì†íŒ¨', player.hand, true);
        }

        function showAIHand() {
            const ai = state.players[1];
            showCardListModal('AI ì†íŒ¨', ai.hand, true);
        }

        function showCardListModal(title, cards, showNumbers = false) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">${title}</h3>
                    ${cards.length > 0 ? `
                    <div class="grid grid-cols-4 gap-2 mb-4">
                        ${cards.sort((a, b) => a - b).map((card, index) => `
                            <div class="card card-front flex flex-col items-center justify-center text-sm">
                                <div class="text-lg">${getSpellIcon(card)}</div>
                                <div class="text-xs">${card}</div>
                                ${showNumbers ? `<div class="text-xs opacity-75">#${index + 1}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    ` : `
                        <div class="text-center mb-4 text-gray-400">
                            <div class="text-4xl mb-2">ğŸ“­</div>
                            <p>ì•„ì§ ì‚¬ìš©ëœ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                        </div>
                    `}
                    <button class="w-full py-2 rounded-lg font-bold btn-primary">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showCombinedSecretStonesModal() {
            // ê° ì„¹ì…˜ì˜ ì¹´ë“œ ê°œìˆ˜ ê³„ì‚°
            const personalCount = state.personalRevealedStones ? state.personalRevealedStones.length : 0;
            const opponentPersonalCount = state.opponentPersonalRevealedStones ? state.opponentPersonalRevealedStones.length : 0;
            const publicCount = state.publiclyRevealedSecretStones ? state.publiclyRevealedSecretStones.length : 0;
            const secretCount = state.secretStones ? state.secretStones.length : 0;
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                    <h3 class="text-xl font-bold mb-4 text-center">ë¹„ë°€ ì£¼ë¬¸ ëª©ë¡</h3>
                    
                    <!-- ë‚˜ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ë“¤ -->
                    ${personalCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-blue-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸ‘ï¸</span><span>ë‚˜ì—ê²Œë§Œ ê³µê°œ</span><span class="ml-auto text-xs text-blue-500">(${personalCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-blue-50 p-3 rounded">
                                ${state.personalRevealedStones.sort((a, b) => a - b).map(stone => `
                                <div class="card card-front flex flex-col items-center justify-center text-sm">
                                    <div class="text-lg">${getSpellIcon(stone)}</div>
                                    <div class="text-xs">${stone}</div>
                                </div>
                            `).join('')}
                        </div>
                        </div>
                    ` : ''}
                    
                    <!-- ìƒëŒ€ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ë“¤ -->
                    ${opponentPersonalCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-orange-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸ‘ï¸</span><span>ìƒëŒ€ì—ê²Œë§Œ ê³µê°œ</span><span class="ml-auto text-xs text-orange-500">(${opponentPersonalCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-orange-50 p-3 rounded">
                                ${state.opponentPersonalRevealedStones.sort((a, b) => a - b).map(stone => `
                                    <div class="card ${cheatMode ? 'card-front' : 'card-back'} flex flex-col items-center justify-center text-sm">
                                        <div class="text-lg">${cheatMode ? getSpellIcon(stone) : 'â“'}</div>
                                        <div class="text-xs">${cheatMode ? stone : '???'}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- ëª¨ë‘ì—ê²Œ ê³µê°œëœ ì£¼ë¬¸ë“¤ -->
                    ${publicCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-green-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸŒ</span><span>ëª¨ë‘ì—ê²Œ ê³µê°œ</span><span class="ml-auto text-xs text-green-500">(${publicCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-green-50 p-3 rounded">
                                ${state.publiclyRevealedSecretStones.sort((a, b) => a - b).map(stone => `
                                    <div class="card card-front flex flex-col items-center justify-center text-sm">
                                        <div class="text-lg">${getSpellIcon(stone)}</div>
                                        <div class="text-xs">${stone}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- ì•„ì§ ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸ë“¤ -->
                    ${secretCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-gray-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸ”’</span><span>ì•„ì§ ê³µê°œë˜ì§€ ì•ŠìŒ</span><span class="ml-auto text-xs text-gray-500">(${secretCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-gray-50 p-3 rounded">
                                ${state.secretStones.sort((a, b) => a - b).map(stone => `
                                    <div class="card ${cheatMode ? 'card-front' : 'card-back'} flex flex-col items-center justify-center text-sm">
                                        <div class="text-lg">${cheatMode ? getSpellIcon(stone) : 'â“'}</div>
                                        <div class="text-xs">${cheatMode ? stone : '???'}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- ëª¨ë“  ì„¹ì…˜ì´ ë¹„ì–´ìˆëŠ” ê²½ìš° -->
                    ${personalCount === 0 && opponentPersonalCount === 0 && publicCount === 0 && secretCount === 0 ? `
                        <p class="text-center mb-4 text-gray-400">ì•„ì§ ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                    ` : ''}
                    
                    <button class="w-full py-2 rounded-lg font-bold btn-primary mt-4">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showCardChoiceModal(title, message, cards, isHand = false) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
                modal.innerHTML = `
                    <div class="modal-content p-6 rounded-lg max-w-lg w-full mx-4">
                        <h3 class="text-xl font-bold mb-2 text-center">${title}</h3>
                        <p class="text-center mb-4">${message}</p>
                        <div class="grid grid-cols-4 gap-2 mb-4">
                            ${cards.map((card, index) => `
                                <div class="card ${isHand ? 'card-front' : 'card-back'} flex flex-col items-center justify-center text-sm cursor-pointer hover:scale-105 transition-transform" data-card="${card}">
                                    <div class="text-lg">${isHand ? getSpellIcon(card) : '?'}</div>
                                    <div class="text-xs">${isHand ? card : 'ìˆ¨ê¹€'}</div>
                                </div>
                            `).join('')}
                        </div>
                        <button class="w-full py-2 rounded-lg font-bold btn-primary">ì·¨ì†Œ</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                playCardSound();
                
                const cardElements = modal.querySelectorAll('[data-card]');
                cardElements.forEach(cardEl => {
                    cardEl.addEventListener('click', () => {
                        const selectedCard = parseInt(cardEl.dataset.card);
                        document.body.removeChild(modal);
                        resolve(selectedCard);
                    });
                });
                
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
            });
        }

        function showChoiceModal(title, message, option1, option2) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
                modal.innerHTML = `
                    <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                        <h3 class="text-xl font-bold mb-2 text-center">${title}</h3>
                        <p class="text-center mb-4">${message}</p>
                        <div class="grid grid-cols-2 gap-4">
                            <button class="py-3 rounded-lg font-bold btn-primary" data-choice="${option1}">${option1}</button>
                            <button class="py-3 rounded-lg font-bold btn-primary" data-choice="${option2}">${option2}</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                playCardSound();
                
                const buttons = modal.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const choice = btn.dataset.choice;
                        document.body.removeChild(modal);
                        resolve(choice);
                    });
                });
            });
        }

        function showModal(title, message, isGameOver = false) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
                modal.innerHTML = `
                    <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                        <h3 class="text-xl font-bold mb-4 text-center">${title}</h3>
                        <p class="text-center mb-4">${message}</p>
                        <button class="w-full py-3 rounded-lg font-bold btn-primary">${isGameOver ? 'íƒ€ì´í‹€ë¡œ ëŒì•„ê°€ê¸°' : 'í™•ì¸'}</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                playCardSound();
                
                // ì˜ì°½ ì„±ê³µ ê´€ë ¨ ëª¨ë‹¬ì¸ì§€ í™•ì¸í•˜ê³  íŒŒí‹°í´ íš¨ê³¼ ì¶”ê°€
                const isSpellSuccessModal = title.includes('ì˜ì°½ ì„±ê³µ') || 
                                          title.includes('ğŸ’¤ ëª…ìƒ') || 
                                          title.includes('ğŸ§ª ìƒëª… ë¬¼ì•½') || 
                                          title.includes('ğŸ”¥ í™”ì—¼ í™”ì‚´') || 
                                          title.includes('ğŸŒ€ ì •ì‹  êµë€') || 
                                          title.includes('ğŸ’« ë§ˆë ¥ ì°©ì·¨') || 
                                          title.includes('ğŸ”® ìš´ëª… ë³€í™˜');
                
                if (isSpellSuccessModal) {
                    // í˜„ì¬ ì„±ê³µí•œ ì£¼ë¬¸ ë²ˆí˜¸ë¥¼ ì°¾ê¸° ìœ„í•´ stateì—ì„œ í™•ì¸
                    const lastSpell = state.lastSuccessfulSpell;
                    if (lastSpell > 0) {
                        // íŒì—…ì´ ëœ¨ëŠ” ì¦‰ì‹œ íŒŒí‹°í´ íš¨ê³¼ ìƒì„±
                        createModalParticles(lastSpell);
                    }
                }
                
                modal.querySelector('button').addEventListener('click', () => {
                    if (document.body.contains(modal)) {
                    document.body.removeChild(modal);
                    }
                    if (isGameOver) {
                        setTimeout(() => {
                            showTitleScreen();
                        }, 100);
                    }
                    resolve();
                });
            });
        }

        function resetGame() {
            console.log('ğŸ”„ ê²Œì„ ë¦¬ì…‹');
            
            // ë¡œì»¬ ë©”ëª¨ ìƒíƒœ ì´ˆê¸°í™”
            localMemoNotes = {};
            localMemoPanelActive = false;
            
            // ê²Œì„ ì‹œì‘ ì‹œ íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
            stopTurnTimer();
            resetTurnGauge();
            
            // ì˜¬ë°”ë¥¸ ë± ìƒì„± (1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ, 3ë²ˆì€ 3ê°œ...)
            let deck = [];
            for (let spellNumber = 1; spellNumber <= GAME_CONFIG.deckStructure.maxSpell; spellNumber++) {
                for (let cardCount = 0; cardCount < GAME_CONFIG.deckStructure.cardsPerSpell(spellNumber); cardCount++) {
                    deck.push(spellNumber);
                }
            }
            console.log('ğŸ“¦ ì´ˆê¸° ë± ìƒì„±:', deck);
            
            // ë± ì…”í”Œ
            shuffleArray(deck);
            console.log('ğŸ”„ ë± ì…”í”Œ ì™„ë£Œ');
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ì„ ê²°ì •í•˜ê³  ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
            let firstPlayer;
            if (multiplayerMode && isHost) {
                // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ í•­ìƒ 1ë²ˆ í”Œë ˆì´ì–´, ì²« í„´ë§Œ ëœë¤ ê²°ì •
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer} (í˜¸ìŠ¤íŠ¸ëŠ” í•­ìƒ 1ë²ˆ)`);
                
                // ìƒëŒ€ë°©ì—ê²Œ ì²« ë²ˆì§¸ í„´ ì •ë³´ ì „ì†¡
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'firstTurn',
                        firstPlayer: firstPlayer
                    }));
                }
            } else if (multiplayerMode && !isHost) {
                // ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦¼
                console.log('â³ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì • ëŒ€ê¸° ì¤‘...');
                // ê²ŒìŠ¤íŠ¸ë„ ê¸°ë³¸ ê²Œì„ ìƒíƒœëŠ” ì´ˆê¸°í™”í•˜ë˜, ì²« ë²ˆì§¸ í„´ì€ í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦¼
                firstPlayer = 1; // ì„ì‹œê°’, í˜¸ìŠ¤íŠ¸ê°€ ê²°ì •í•œ ê°’ìœ¼ë¡œ ë®ì–´ì”Œì›Œì§
            } else {
                // AI ëª¨ë“œì—ì„œëŠ” ëœë¤ ê²°ì •
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ AI ëª¨ë“œ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer}`);
            }
            
            const playerName = localStorage.getItem('playerName') || 'Player';
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            
            state = {
                players: [
                    { id: 1, name: playerName, health: GAME_CONFIG.maxHealth, hand: deck.slice(0, GAME_CONFIG.maxHandSize).sort((a, b) => a - b), knownSecretStones: [] },
                    { id: 2, name: multiplayerMode ? (opponentName || 'Player2') : 'AI', health: GAME_CONFIG.maxHealth, hand: deck.slice(GAME_CONFIG.maxHandSize, GAME_CONFIG.maxHandSize * 2).sort((a, b) => a - b), knownSecretStones: [] }
                ],
                secretStones: deck.slice(14),
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: firstPlayer,
                isPlayerTurn: multiplayerMode ? (firstPlayer === myPlayerId) : (firstPlayer === 1),
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                isGameOver: false,
                gameStarted: true,
                gameLog: [Messages.gameStart(firstPlayer === 1 ? playerName : (multiplayerMode ? (opponentName || 'Player2') : 'AI'))]
            };
            
            console.log(`ğŸ¯ ê²Œì„ ìƒíƒœ ì„¤ì • ì™„ë£Œ - í˜¸ìŠ¤íŠ¸: ${isHost}, ì²« í„´ í”Œë ˆì´ì–´: ${firstPlayer}, ë‚´ í”Œë ˆì´ì–´ ID: ${myPlayerId}, ë‚´ í„´: ${state.isPlayerTurn}`);
            
            console.log('ğŸ¯ ì´ˆê¸° ê²Œì„ ìƒíƒœ:', {
                playerHand: state.players[0].hand,
                aiHand: state.players[1].hand,
                secretStones: state.secretStones,
                totalCards: deck.length
            });
            
            createSpellButtons();
            updatePlayerName();
            render();
            updateButtons();
            
            // ì²« ë²ˆì§¸ í„´ íƒ€ì´ë¨¸ ì‹œì‘ (AI ë˜ëŠ” í”Œë ˆì´ì–´ ëª¨ë‘)
            setTimeout(() => {
                startTurnTimer();
                
                // AIê°€ ë¨¼ì € ì‹œì‘í•˜ëŠ” ê²½ìš° AI í„´ ì‹¤í–‰
                if (!state.isPlayerTurn && !multiplayerMode) {
                    aiTurn();
                }
            }, 1000);
        }

        // ì‚¬ìš´ë“œ íš¨ê³¼ í•¨ìˆ˜ë“¤ (ìƒë‹¨ì—ì„œ í†µí•©ëœ ë²„ì „ ì‚¬ìš©)
        // ì¤‘ë³µ ì œê±°ë¨ - ìƒë‹¨ì˜ playSoundEffect() í•¨ìˆ˜ ì‚¬ìš©

        // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ í•¨ìˆ˜ë“¤
        function addSuccessAnimation(element) {
            element.classList.add('success-animation');
            setTimeout(() => element.classList.remove('success-animation'), 500);
        }

        function addFailureAnimation(element) {
            element.classList.add('failure-animation');
            setTimeout(() => element.classList.remove('failure-animation'), 500);
        }

        function showDamageEffect(element, amount) {
            const damageEl = document.createElement('div');
            damageEl.className = 'card-damage';
            damageEl.textContent = `-${amount}`;
            element.appendChild(damageEl);
            setTimeout(() => element.removeChild(damageEl), 1000);
        }

        function showHealEffect(element, amount) {
            const healEl = document.createElement('div');
            healEl.className = 'card-heal';
            healEl.textContent = `+${amount}`;
            element.appendChild(healEl);
            setTimeout(() => element.removeChild(healEl), 1000);
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function shuffleArray(array) {
            for (let currentIndex = array.length - 1; currentIndex > 0; currentIndex--) {
                const randomIndex = Math.floor(Math.random() * (currentIndex + 1));
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ë§ˆë²• ë²ˆí˜¸ì— ë”°ë¥¸ ì•„ì´ì½˜ ë°˜í™˜ í•¨ìˆ˜
        function getSpellIcon(spellNumber) {
            const spellIcons = {
                1: 'ğŸ”®', // ìš´ëª… ë³€í™˜
                2: 'ğŸ’«', // ë§ˆë ¥ ì°©ì·¨
                3: 'ğŸŒ€', // ì •ì‹  êµë€
                4: 'ğŸ”¥', // í™”ì—¼ í™”ì‚´
                5: 'ğŸ§ª', // ìƒëª… ë¬¼ì•½
                6: 'ğŸ’¤'  // ëª…ìƒ
            };
            return spellIcons[spellNumber] || 'â“';
        }

        // ëª¨ë‹¬ í•¨ìˆ˜ë“¤
        function showCardListModal(title, cards, showNumbers = false) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">${title}</h3>
                    ${cards.length > 0 ? `
                    <div class="grid grid-cols-4 gap-2 mb-4">
                        ${cards.sort((a, b) => a - b).map((card, index) => `
                            <div class="card card-front flex flex-col items-center justify-center text-sm">
                                <div class="text-lg">${getSpellIcon(card)}</div>
                                <div class="text-xs">${card}</div>
                                ${showNumbers ? `<div class="text-xs opacity-75">#${index + 1}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    ` : `
                        <div class="text-center mb-4 text-gray-400">
                            <div class="text-4xl mb-2">ğŸ“­</div>
                            <p>ì•„ì§ ì‚¬ìš©ëœ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                        </div>
                    `}
                    <button class="w-full py-2 rounded-lg font-bold btn-primary">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showCombinedSecretStonesModal() {
            // ê° ì„¹ì…˜ì˜ ì¹´ë“œ ê°œìˆ˜ ê³„ì‚°
            const personalCount = state.personalRevealedStones ? state.personalRevealedStones.length : 0;
            const opponentPersonalCount = state.opponentPersonalRevealedStones ? state.opponentPersonalRevealedStones.length : 0;
            const publicCount = state.publiclyRevealedSecretStones ? state.publiclyRevealedSecretStones.length : 0;
            const secretCount = state.secretStones ? state.secretStones.length : 0;
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                    <h3 class="text-xl font-bold mb-4 text-center">ë¹„ë°€ ì£¼ë¬¸ ëª©ë¡</h3>
                    
                    <!-- ë‚˜ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ë“¤ -->
                    ${personalCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-blue-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸ‘ï¸</span><span>ë‚˜ì—ê²Œë§Œ ê³µê°œ</span><span class="ml-auto text-xs text-blue-500">(${personalCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-blue-50 p-3 rounded">
                                ${state.personalRevealedStones.sort((a, b) => a - b).map(stone => `
                                <div class="card card-front flex flex-col items-center justify-center text-sm">
                                    <div class="text-lg">${getSpellIcon(stone)}</div>
                                    <div class="text-xs">${stone}</div>
                                </div>
                            `).join('')}
                        </div>
                        </div>
                    ` : ''}
                    
                    <!-- ìƒëŒ€ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ë“¤ -->
                    ${opponentPersonalCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-orange-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸ‘ï¸</span><span>ìƒëŒ€ì—ê²Œë§Œ ê³µê°œ</span><span class="ml-auto text-xs text-orange-500">(${opponentPersonalCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-orange-50 p-3 rounded">
                                ${state.opponentPersonalRevealedStones.sort((a, b) => a - b).map(stone => `
                                    <div class="card ${cheatMode ? 'card-front' : 'card-back'} flex flex-col items-center justify-center text-sm">
                                        <div class="text-lg">${cheatMode ? getSpellIcon(stone) : 'â“'}</div>
                                        <div class="text-xs">${cheatMode ? stone : '???'}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- ëª¨ë‘ì—ê²Œ ê³µê°œëœ ì£¼ë¬¸ë“¤ -->
                    ${publicCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-green-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸŒ</span><span>ëª¨ë‘ì—ê²Œ ê³µê°œ</span><span class="ml-auto text-xs text-green-500">(${publicCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-green-50 p-3 rounded">
                                ${state.publiclyRevealedSecretStones.sort((a, b) => a - b).map(stone => `
                                    <div class="card card-front flex flex-col items-center justify-center text-sm">
                                        <div class="text-lg">${getSpellIcon(stone)}</div>
                                        <div class="text-xs">${stone}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- ì•„ì§ ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸ë“¤ -->
                    ${secretCount > 0 ? `
                        <div class="mb-4">
                            <div class="text-sm font-bold text-gray-600 mb-2 flex items-center">
                                <span class="mr-1">ğŸ”’</span><span>ì•„ì§ ê³µê°œë˜ì§€ ì•ŠìŒ</span><span class="ml-auto text-xs text-gray-500">(${secretCount}ê°œ)</span>
                            </div>
                            <div class="grid grid-cols-4 gap-2 bg-gray-50 p-3 rounded">
                                ${state.secretStones.sort((a, b) => a - b).map(stone => `
                                    <div class="card ${cheatMode ? 'card-front' : 'card-back'} flex flex-col items-center justify-center text-sm">
                                        <div class="text-lg">${cheatMode ? getSpellIcon(stone) : 'â“'}</div>
                                        <div class="text-xs">${cheatMode ? stone : '???'}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- ëª¨ë“  ì„¹ì…˜ì´ ë¹„ì–´ìˆëŠ” ê²½ìš° -->
                    ${personalCount === 0 && opponentPersonalCount === 0 && publicCount === 0 && secretCount === 0 ? `
                        <p class="text-center mb-4 text-gray-400">ì•„ì§ ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                    ` : ''}
                    
                    <button class="w-full py-2 rounded-lg font-bold btn-primary mt-4">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showDebugInfo() {
            const player = state.players[0];
            const ai = state.players[1];
            debugInfo.innerHTML = `
                <div>í”Œë ˆì´ì–´ ì²´ë ¥: ${player.health}</div>
                <div>AI ì²´ë ¥: ${ai.health}</div>
                <div>í”Œë ˆì´ì–´ ì†íŒ¨: [${player.hand.join(', ')}]</div>
                <div>AI ì†íŒ¨: [${ai.hand.join(', ')}]</div>
                <div>ë¹„ë°€ ì „ìˆ : ${state.secretStones.length}ê°œ</div>
                <div>ì‚¬ìš©í•œ ì „ìˆ : ${state.usedStones.length}ê°œ</div>
                <div>ë§ˆì§€ë§‰ ì„±ê³µ ì „ëµ: ${state.lastSuccessfulSpell}</div>
                <div>ê²Œì„ ì¢…ë£Œ: ${state.isGameOver}</div>
            `;
        }

        function showPlayerHand() {
            const player = state.players[0];
            showCardListModal('í”Œë ˆì´ì–´ ì†íŒ¨', player.hand, true);
        }

        function showAIHand() {
            const ai = state.players[1];
            showCardListModal('AI ì†íŒ¨', ai.hand, true);
        }

        // ê²Œì„ ì„¤ì • ìƒìˆ˜ (ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€)
        const GAME_CONFIG = {
            maxHealth: 4,
            maxHandSize: 7,
            maxLogEntries: 20,
            turnDuration: {
                easy: 25,
                normal: 30,
                hard: 35,
                multiplayer: 30
            },
            aiSuccessRate: {
                easy: 0.3,
                normal: 0.5,
                hard: 0.7
            },
            aiContinueRate: {
                easy: 0.4,
                normal: 0.6,
                hard: 0.8
            },
            deckStructure: {
                maxSpell: 6,
                cardsPerSpell: (spell) => spell // 1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ...
            }
        };

        // GAME_CONFIG ì •ì˜ í›„ ì´ˆê¸°í™” í•¨ìˆ˜ í˜¸ì¶œ
        initializeGameConfig();

        /**
         * ê²Œì„ ì¡°ê±´ ê²€ì¦ í—¬í¼ í•¨ìˆ˜ë“¤
         * ë³µì¡í•œ ì¡°ê±´ë¬¸ì„ ë‹¨ìˆœí™”í•˜ê³  ê°€ë…ì„±ì„ í–¥ìƒ
         */
        const GameConditions = {
            /**
             * ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ìƒíƒœ í™•ì¸
             * @returns {boolean} ì—°ê²° ìƒíƒœ
             */
            isMultiplayerConnected: () => multiplayerMode && dataChannel && dataChannel.readyState === 'open',
            
            /**
             * ê²Œì„ ìƒíƒœ ìœ íš¨ì„± ê²€ì¦
             * @returns {boolean} ê²Œì„ ìƒíƒœ ìœ íš¨ì„±
             */
            isGameValid: () => state && state.players && state.players.length >= 2,
            
            /**
             * ë‚´ í„´ì¸ì§€ í™•ì¸
             * @returns {boolean} ë‚´ í„´ ì—¬ë¶€
             */
            isMyTurn: () => {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                return multiplayerMode ? (state.currentPlayerId === myPlayerId) : state.isPlayerTurn;
            },
            
            /**
             * ì£¼ë¬¸ ì‹œì „ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
             * @returns {boolean} ì£¼ë¬¸ ì‹œì „ ê°€ëŠ¥ ì—¬ë¶€
             */
            canPlaySpell: () => {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                const isMyTurn = multiplayerMode ? (state.currentPlayerId === myPlayerId) : state.isPlayerTurn;
                return isMyTurn && !state.turnInProgress && !state.isGameOver;
            },
            
            /**
             * ê²Œì„ ì§„í–‰ ì¤‘ì¸ì§€ í™•ì¸
             * @returns {boolean} ê²Œì„ ì§„í–‰ ìƒíƒœ
             */
            isGameInProgress: () => multiplayerMode && state.gameStarted && !state.isGameOver
        };

        // ì£¼ë¬¸ ì•„ì´ì½˜ ì •ì˜
        const SpellIcons = {
            1: 'ğŸ”®', // ìš´ëª… ë³€í™˜
            2: 'ğŸ’«', // ë§ˆë ¥ ì°©ì·¨
            3: 'ğŸŒ€', // ì •ì‹  êµë€
            4: 'ğŸ”¥', // í™”ì—¼ í™”ì‚´
            5: 'ğŸ§ª', // ìƒëª… ë¬¼ì•½
            6: 'ğŸ’¤'  // ëª…ìƒ
        };

        // ë©”ì‹œì§€ í…œí”Œë¦¿
        const Messages = {
            spellSuccess: (name, spell) => `âœ… ${name} ${SpellIcons[spell] || 'â“'}${spell}ë²ˆ ì˜ì°½ ì„±ê³µ`,
            spellFailure: (name, spell) => `âŒ ${name} ${SpellIcons[spell] || 'â“'}${spell}ë²ˆ ì˜ì°½ ì‹¤íŒ¨`,
            turnStart: (name) => `ğŸ”„ ${name} í„´ ì‹œì‘`,
            turnEnd: (name) => `â¹ï¸ ${name} í„´ ì¢…ë£Œ`,
            timeOut: () => `â° ì‹œê°„ ì´ˆê³¼`,
            gameStart: (name) => `ğŸ® ${name} ê²Œì„ ì‹œì‘`,
            gameOver: (winner) => `ğŸ† ${winner} ìŠ¹ë¦¬`,
            damage: (name, amount) => `ğŸ’” ${name} ì²´ë ¥ -${amount}`,
            heal: (name, amount) => `ğŸ’š ${name} ì²´ë ¥ +${amount}`,
            reveal: (stones) => `ğŸ”® ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ: ${stones.map(stone => `${SpellIcons[stone] || 'â“'}${stone}`).join(', ')}`,
            spy: (name) => `ğŸŒ€ ${name} ì •ì‹  êµë€`,
            meditate: (stone) => `ğŸ’¤ ëª…ìƒ: ${SpellIcons[stone] || 'â“'}${stone} ê³µê°œ`,
            surrender: (name) => `ğŸ³ï¸ ${name} ë„ë§`,
            streak: (count) => `ğŸ”¥ ${count}ì—°ìŠ¹`
        };

        /**
         * ê²Œì„ ë¡œê·¸ ì¶”ê°€ í•¨ìˆ˜
         * ì•ˆì „í•œ ë¡œê·¸ ì¶”ê°€ì™€ ìƒíƒœ ê²€ì¦ì„ í¬í•¨
         * @param {string} message - ë¡œê·¸ ë©”ì‹œì§€
         */
        function addLog(message) {
            try {
            console.log(`ğŸ“ ê²Œì„ ë¡œê·¸: ${message}`);
            
            // stateë‚˜ gameLogê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
            if (!state) {
                state = {};
            }
            if (!state.gameLog) {
                state.gameLog = [];
            }
                
                // ë©”ì‹œì§€ ìœ íš¨ì„± ê²€ì¦
                if (typeof message !== 'string' || message.trim() === '') {
                    console.warn('âš ï¸ ë¹ˆ ë©”ì‹œì§€ ë˜ëŠ” ì˜ëª»ëœ íƒ€ì…ì˜ ë¡œê·¸ ì‹œë„');
                    return;
                }
            
            state.gameLog.unshift(message);
                
                // ë¡œê·¸ ê°œìˆ˜ ì œí•œ
                if (state.gameLog.length > GAME_CONFIG.maxLogEntries) {
                    state.gameLog.pop();
                }
                
                // UI ì—…ë°ì´íŠ¸
                updateGameLog();
                
            } catch (error) {
                console.error('âŒ ë¡œê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            }
        }

        /**
         * ê²Œì„ ë¡œê·¸ UI ì—…ë°ì´íŠ¸
         */
        function updateGameLog() {
            const gameLogEl = DOM.get('game-log');
            if (!gameLogEl || !state.gameLog) return;
            
            gameLogEl.innerHTML = state.gameLog.map(log => {
                const isSuccess = log.includes('âœ…');
                const isFailure = log.includes('âŒ');
                const isTurn = log.includes('í„´');
                const isGameEnd = log.includes('ê²Œì„ ì¢…ë£Œ');
                
                let className = '';
                if (isSuccess) className = 'text-green-400';
                else if (isFailure) className = 'text-red-400';
                else if (isTurn) className = 'text-blue-400 font-bold';
                else if (isGameEnd) className = 'text-purple-400 font-bold';
                
                return `<p class="${className}">${log}</p>`;
            }).join('');
        }

        // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ê´€ë ¨ ë³€ìˆ˜ë“¤
        let longPressType = null;
        
        // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì‹œì‘
        function startLongPress(type) {
            longPressType = type;
            showLongPressTooltip(type);
        }
        
        // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì¢…ë£Œ
        function endLongPress() {
            longPressType = null;
        }
        
        // ê¸¸ê²Œ ëˆ„ë¥´ê¸° íˆ´íŒ í‘œì‹œ
        function showLongPressTooltip(type) {
            if (type === 'secret') {
                showSecretStonesTooltip();
            } else if (type === 'used') {
                showUsedStonesTooltip();
            }
        }
        
        // ë¹„ë°€ ì£¼ë¬¸ íˆ´íŒ í‘œì‹œ (ê°œì„ ëœ ë²„ì „)
        function showSecretStonesTooltip() {
            const tooltip = DOM.get('secret-stones-tooltip');
            const personalSection = DOM.get('personal-revealed-section');
            const personalList = DOM.get('personal-revealed-list');
            const opponentPersonalSection = DOM.get('opponent-personal-revealed-section');
            const opponentPersonalList = DOM.get('opponent-personal-revealed-list');
            const publiclySection = DOM.get('publicly-revealed-section');
            const publiclyList = DOM.get('publicly-revealed-list');
            const secretSection = DOM.get('secret-stones-section');
            const secretList = DOM.get('secret-stones-list');
            
            // ë™ì  ê°œìˆ˜ ì—…ë°ì´íŠ¸
            updateTooltipCounts();
            
            // ë‚˜ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ í‘œì‹œ (ë‚´ê°€ 1ë²ˆ ì£¼ë¬¸ìœ¼ë¡œ ë°œê²¬í•œ ê²½ìš°)
            if (state.personalRevealedStones && state.personalRevealedStones.length > 0) {
                const sortedPersonal = [...state.personalRevealedStones].sort((a, b) => a - b);
                const personalHtml = sortedPersonal.map(stone => 
                    `<div class="flex items-center justify-between">
                        <span class="text-sm">${SpellIcons[stone] || 'â“'}${stone}</span>
                        <span class="text-gray-500 text-sm">${getSpellName(stone)}</span>
                    </div>`
                ).join('');
                personalList.innerHTML = personalHtml;
                personalSection.classList.remove('hidden');
            } else {
                personalSection.classList.add('hidden');
            }
            
            // ìƒëŒ€ì—ê²Œë§Œ ê³µê°œëœ ì£¼ë¬¸ í‘œì‹œ (ì¹˜íŠ¸í‚¤ ëª¨ë“œì—ì„œëŠ” ì •ë³´ í‘œì‹œ, ì¼ë°˜ ëª¨ë“œì—ì„œëŠ” ìˆ¨ê¹€)
            if (state.opponentPersonalRevealedStones && state.opponentPersonalRevealedStones.length > 0) {
                const sortedOpponentPersonal = [...state.opponentPersonalRevealedStones].sort((a, b) => a - b);
                const opponentPersonalHtml = sortedOpponentPersonal.map(stone => {
                    if (cheatMode) {
                        return `<div class="flex items-center justify-between">
                            <span class="text-sm">${SpellIcons[stone] || 'â“'}${stone}</span>
                            <span class="text-gray-500 text-sm">${getSpellName(stone)}</span>
                        </div>`;
                    } else {
                        return `<div class="flex items-center justify-between">
                            <span class="text-sm">â“?</span>
                            <span class="text-gray-500 text-sm">???</span>
                        </div>`;
                    }
                }).join('');
                opponentPersonalList.innerHTML = opponentPersonalHtml;
                opponentPersonalSection.classList.remove('hidden');
            } else {
                opponentPersonalSection.classList.add('hidden');
            }
            
            // ì „ì²´ ê³µê°œëœ ì£¼ë¬¸ í‘œì‹œ (6ë²ˆ ì£¼ë¬¸ìœ¼ë¡œ ë°œê²¬ëœ ê²½ìš°)
            if (state.publiclyRevealedSecretStones && state.publiclyRevealedSecretStones.length > 0) {
                const sortedPublicly = [...state.publiclyRevealedSecretStones].sort((a, b) => a - b);
                const publiclyHtml = sortedPublicly.map(stone => 
                    `<div class="flex items-center justify-between">
                        <span class="text-sm">${SpellIcons[stone] || 'â“'}${stone}</span>
                        <span class="text-gray-500 text-sm">${getSpellName(stone)}</span>
                    </div>`
                ).join('');
                publiclyList.innerHTML = publiclyHtml;
                publiclySection.classList.remove('hidden');
            } else {
                publiclySection.classList.add('hidden');
            }
            
            // ì•„ì§ ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸ í‘œì‹œ (ì¹˜íŠ¸í‚¤ ëª¨ë“œì—ì„œëŠ” ì •ë³´ í‘œì‹œ, ì¼ë°˜ ëª¨ë“œì—ì„œëŠ” ìˆ¨ê¹€)
            if (state.secretStones && state.secretStones.length > 0) {
                const sortedSecret = [...state.secretStones].sort((a, b) => a - b);
                const secretHtml = sortedSecret.map(stone => {
                    if (cheatMode) {
                        return `<div class="flex items-center justify-between">
                            <span class="text-sm">${SpellIcons[stone] || 'â“'}${stone}</span>
                            <span class="text-gray-500 text-sm">${getSpellName(stone)}</span>
                        </div>`;
                    } else {
                        return `<div class="flex items-center justify-between">
                            <span class="text-sm">â“?</span>
                            <span class="text-gray-500 text-sm">???</span>
                        </div>`;
                    }
                }).join('');
                secretList.innerHTML = secretHtml;
            } else {
                secretList.innerHTML = '<div class="text-center text-gray-500">ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
            
            tooltip.classList.remove('hidden');
        }
        
        /**
         * íˆ´íŒ ì„¹ì…˜ ê°œìˆ˜ ì—…ë°ì´íŠ¸
         */
        function updateTooltipCounts() {
            const personalCount = state.personalRevealedStones ? state.personalRevealedStones.length : 0;
            const opponentPersonalCount = state.opponentPersonalRevealedStones ? state.opponentPersonalRevealedStones.length : 0;
            const publiclyCount = state.publiclyRevealedSecretStones ? state.publiclyRevealedSecretStones.length : 0;
            const secretCount = state.secretStones ? state.secretStones.length : 0;
            
            // ê°œìˆ˜ í‘œì‹œ ì—…ë°ì´íŠ¸
            const personalTitle = document.querySelector('#personal-revealed-section .text-blue-500');
            const opponentPersonalTitle = document.querySelector('#opponent-personal-revealed-section .text-orange-500');
            const publiclyTitle = document.querySelector('#publicly-revealed-section .text-green-500');
            const secretTitle = document.querySelector('#secret-stones-section .text-gray-500');
            
            if (personalTitle) personalTitle.textContent = `(${personalCount}ê°œ)`;
            if (opponentPersonalTitle) opponentPersonalTitle.textContent = `(${opponentPersonalCount}ê°œ)`;
            if (publiclyTitle) publiclyTitle.textContent = `(${publiclyCount}ê°œ)`;
            if (secretTitle) secretTitle.textContent = `(${secretCount}ê°œ)`;
        }
        
        // ì‚¬ìš©í•œ ì£¼ë¬¸ íˆ´íŒ í‘œì‹œ
        function showUsedStonesTooltip() {
            const tooltip = DOM.get('used-stones-tooltip');
            const list = DOM.get('used-stones-list');
            
            if (state.usedStones.length === 0) {
                list.innerHTML = '<div class="text-center text-gray-500">ì‚¬ìš©í•œ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            } else {
                // ë‚®ì€ ìˆ˜ë¶€í„° ì •ë ¬
                const sortedStones = [...state.usedStones].sort((a, b) => a - b);
                const stonesHtml = sortedStones.map(stone => 
                    `<div class="flex items-center justify-between">
                        <span class="text-sm">${SpellIcons[stone] || 'â“'}${stone}</span>
                        <span class="text-gray-500 text-sm">${getSpellName(stone)}</span>
                    </div>`
                ).join('');
                list.innerHTML = stonesHtml;
            }
            
            tooltip.classList.remove('hidden');
        }
        
        // ì£¼ë¬¸ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
        function getSpellName(spellNumber) {
            const spellNames = {
                1: 'ìš´ëª… ë³€í™˜',
                2: 'ë§ˆë ¥ ì°©ì·¨',
                3: 'ì •ì‹  êµë€',
                4: 'í™”ì—¼ í™”ì‚´',
                5: 'ìƒëª… ë¬¼ì•½',
                6: 'ëª…ìƒ'
            };
            return spellNames[spellNumber] || `ì£¼ë¬¸ ${spellNumber}`;
        }
        
        // íˆ´íŒ ìˆ¨ê¸°ê¸° (í´ë¦­ ì‹œ)
        function hideTooltips() {
            const secretTooltip = DOM.get('secret-stones-tooltip');
            const usedTooltip = DOM.get('used-stones-tooltip');
            secretTooltip.classList.add('hidden');
            usedTooltip.classList.add('hidden');
        }
        
        // íˆ´íŒ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        document.addEventListener('click', function(event) {
            const secretTooltip = DOM.get('secret-stones-tooltip');
            const usedTooltip = DOM.get('used-stones-tooltip');
            
            // íˆ´íŒ ì™¸ë¶€ í´ë¦­ ì‹œ ìˆ¨ê¸°ê¸°
            if (!secretTooltip.contains(event.target) && !usedTooltip.contains(event.target)) {
                hideTooltips();
            }
        });
        
        // ì¹˜íŠ¸í‚¤ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', function(event) {
            if (event.key === '-') {
                toggleCheatMode();
            }
        });
        
        // ë„ì›€ë§ íˆ´íŒ í•¨ìˆ˜ë“¤
        function showHelpTooltip() {
            const tooltip = DOM.get('help-tooltip');
            tooltip.classList.remove('hidden');
        }
        
        function hideHelpTooltip() {
            const tooltip = DOM.get('help-tooltip');
            tooltip.classList.add('hidden');
        }
        
        /**
         * ì¹˜íŠ¸í‚¤ ëª¨ë“œ í† ê¸€
         */
        function toggleCheatMode() {
            cheatMode = !cheatMode;
            console.log(`ğŸ”§ ì¹˜íŠ¸í‚¤ ëª¨ë“œ: ${cheatMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
            
            // UI ì—…ë°ì´íŠ¸
            render();
            
            // ì¹˜íŠ¸í‚¤ ìƒíƒœ í‘œì‹œ
            const status = cheatMode ? 'ğŸ”§ ì¹˜íŠ¸í‚¤ í™œì„±í™”ë¨' : 'ğŸ”§ ì¹˜íŠ¸í‚¤ ë¹„í™œì„±í™”ë¨';
            addLog(status);
            
            // 3ì´ˆ í›„ ì¹˜íŠ¸í‚¤ ìƒíƒœ ë©”ì‹œì§€ ì œê±°
            setTimeout(() => {
                if (state.gameLog && state.gameLog.length > 0) {
                    state.gameLog = state.gameLog.filter(log => !log.includes('ì¹˜íŠ¸í‚¤'));
                    updateGameLog();
                }
            }, 3000);
        }
        
        // ë©€í‹°í”Œë ˆì´ì–´ ê´€ë ¨ ë³€ìˆ˜ë“¤
        let multiplayerMode = false;
        let peerConnection = null;
        let dataChannel = null;
        let matchingInterval = null;
        let aiDifficulty = 'normal'; // 'easy', 'normal', 'hard'
        let isHost = false;
        let playerName = '';
        let opponentName = '';
        let opponentIcon = 'ğŸ‘¤'; // ìƒëŒ€ë°© ì•„ì´ì½˜ ê¸°ë³¸ê°’
        let myPlayerId = null;
        let localMemoNotes = {}; // ê°œë³„ í”Œë ˆì´ì–´ì˜ ë©”ëª¨ ë…¸íŠ¸ (ë¡œì»¬ ìƒíƒœ)
        let localMemoPanelActive = false; // ê°œë³„ í”Œë ˆì´ì–´ì˜ ë©”ëª¨ íŒ¨ë„ ìƒíƒœ (ë¡œì»¬ ìƒíƒœ)
        
        // ì¹˜íŠ¸í‚¤ ê´€ë ¨ ë³€ìˆ˜
        let cheatMode = false; // ì¹˜íŠ¸í‚¤ í™œì„±í™” ìƒíƒœ
        
        // Socket.IO ì—°ê²°
        let socket = null;
        let serverConnected = false;
        
        // ì „ì  ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function loadStats() {
            const stats = localStorage.getItem('tacticalCardBattleStats');
            if (stats) {
                const parsedStats = JSON.parse(stats);
                
                // ê¸°ì¡´ í˜•ì‹ê³¼ ìƒˆë¡œìš´ í˜•ì‹ í˜¸í™˜ì„± ì²˜ë¦¬
                if (parsedStats.wins !== undefined || parsedStats.losses !== undefined) {
                    console.log('ê¸°ì¡´ í˜•ì‹ ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.');
                    const newStats = {
                        mock: { 
                            wins: parsedStats.wins || 0, 
                            losses: parsedStats.losses || 0 
                        },
                        formal: { wins: 0, losses: 0 }
                    };
                    // ìƒˆë¡œìš´ í˜•ì‹ìœ¼ë¡œ ì €ì¥
                    saveStats(newStats);
                    return newStats;
                }
                
                return parsedStats;
            }
            return { 
                mock: { wins: 0, losses: 0 },
                formal: { wins: 0, losses: 0 }
            };
        }
        
        function saveStats(stats) {
            localStorage.setItem('tacticalCardBattleStats', JSON.stringify(stats));
        }
        
        function updateStats(isWin, isMultiplayer = false) {
            const stats = loadStats();
            const category = isMultiplayer ? 'formal' : 'mock';
            
            console.log(`ğŸ“Š updateStats í˜¸ì¶œ: ìŠ¹ë¦¬=${isWin}, ë©€í‹°í”Œë ˆì´ì–´=${isMultiplayer}, ì¹´í…Œê³ ë¦¬=${category}`);
            console.log(`ğŸ“Š ì—°ìŠ¹ ì²˜ë¦¬ ì „: í˜„ì¬ ${currentWinStreak}ì—°ìŠ¹, ìµœê³  ${maxWinStreak}ì—°ìŠ¹`);
            
            // ì¹´í…Œê³ ë¦¬ê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
            if (!stats[category]) {
                stats[category] = { wins: 0, losses: 0 };
            }
            
            if (isWin) {
                stats[category].wins++;
                currentWinStreak++;
                if (currentWinStreak > maxWinStreak) {
                    maxWinStreak = currentWinStreak;
                }
                console.log(`ğŸ† ìŠ¹ë¦¬! ì—°ìŠ¹ ì¦ê°€: ${currentWinStreak}ì—°ìŠ¹ (ìµœê³ : ${maxWinStreak}ì—°ìŠ¹)`);
                console.log(`ğŸ“Š ì—°ìŠ¹ ì €ì¥: localStorageì— ${currentWinStreak}ì—°ìŠ¹ ì €ì¥`);
            } else {
                stats[category].losses++;
                currentWinStreak = 0;
                console.log(`ğŸ’” íŒ¨ë°°! ì—°ìŠ¹ ë¦¬ì…‹: 0ì—°ìŠ¹`);
                console.log(`ğŸ“Š ì—°ìŠ¹ ì €ì¥: localStorageì— 0ì—°ìŠ¹ ì €ì¥`);
            }
            
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
            localStorage.setItem('currentWinStreak', currentWinStreak.toString());
            localStorage.setItem('maxWinStreak', maxWinStreak.toString());
            saveStats(stats);
            
            // ì¦í‘œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const trophies = TrophySystem.loadTrophies();
            const trophyCount = isMultiplayer ? trophies.multiplayer : trophies.ai;
            
            // ë­í‚¹ ì—…ë°ì´íŠ¸ (ìŠ¹ë¦¬/íŒ¨ë°° ëª¨ë‘ ì—…ë°ì´íŠ¸)
            const playerName = localStorage.getItem('playerName') || 'Player';
            const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
            
            // ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬ ì •ë³´ ê³„ì‚°
            const allTrophies = TrophySystem.loadTrophies();
            const otherCategory = isMultiplayer ? 'mock' : 'formal';
            const otherScore = isMultiplayer ? allTrophies.ai : allTrophies.multiplayer;
            
            if (socket) {
                // í˜„ì¬ ì ìˆ˜ë¡œ ë­í‚¹ ì—…ë°ì´íŠ¸
                socket.emit('updateRanking', {
                    category: category,
                    playerName: playerName,
                    score: trophyCount,
                    icon: playerIcon
                });
                
                // ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬ë„ í•¨ê»˜ ì—…ë°ì´íŠ¸ (ì „ì²´ ë­í‚¹ ë™ê¸°í™”)
                socket.emit('updateRanking', {
                    category: otherCategory,
                    playerName: playerName,
                    score: otherScore,
                    icon: playerIcon
                });
            }
            
            console.log(`ğŸ“Š ì „ì  ì—…ë°ì´íŠ¸: ${category} - ${playerName} (ì¦í‘œ: ${trophyCount}, ìŠ¹ë¦¬: ${stats[category].wins}, íŒ¨ë°°: ${stats[category].losses})`);
            console.log(`ğŸ“Š ë­í‚¹ ë™ê¸°í™”: ${otherCategory} - ${playerName} (ì¦í‘œ: ${otherScore})`);
        }
        

        
        // ë­í‚¹ ëª¨ë‹¬ í‘œì‹œ í•¨ìˆ˜
        function showRankingModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                    <div class="text-center mb-6">
                        <div class="text-4xl mb-4">ğŸ†</div>
                        <h3 class="text-xl font-bold mb-2">ë§ˆë²• ë­í‚¹</h3>
                        <p class="text-gray-600">ëª¨ë“  ë§ˆë²•ì‚¬ì˜ ìŠ¹ë¦¬ì˜ ì¦í‘œë¥¼ í™•ì¸í•˜ì„¸ìš”</p>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- ëª¨ì˜ ê²°íˆ¬ ë­í‚¹ -->
                        <div class="bg-gray-100 rounded-lg p-4">
                            <h4 class="text-lg font-bold mb-4 text-center">ğŸ­ ëª¨ì˜ ê²°íˆ¬ ë­í‚¹</h4>
                            <div id="mock-ranking-list" class="space-y-2">
                                <div class="text-center text-gray-500">ë¡œë”© ì¤‘...</div>
                            </div>
                        </div>
                        
                        <!-- ì •ì‹ ê²°íˆ¬ ë­í‚¹ -->
                        <div class="bg-gray-100 rounded-lg p-4">
                            <h4 class="text-lg font-bold mb-4 text-center">âš”ï¸ ì •ì‹ ê²°íˆ¬ ë­í‚¹</h4>
                            <div id="formal-ranking-list" class="space-y-2">
                                <div class="text-center text-gray-500">ë¡œë”© ì¤‘...</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="text-center mt-6 space-x-2">
                        <button id="refresh-ranking-btn" class="px-4 py-2 rounded-lg font-bold bg-blue-600 hover:bg-blue-700 text-white">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                        <button id="close-ranking-btn" class="px-6 py-2 rounded-lg font-bold btn-secondary">ë‹«ê¸°</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ë­í‚¹ ë°ì´í„° ë¡œë“œ
            loadRankingData();
            
            // ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ ì´ë²¤íŠ¸
            const refreshBtn = modal.querySelector('#refresh-ranking-btn');
            refreshBtn.addEventListener('click', () => {
                console.log('ğŸ”„ ì‚¬ìš©ìê°€ ë­í‚¹ ìƒˆë¡œê³ ì¹¨ ìš”ì²­');
                loadRankingData();
            });
            
            // ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
            const closeBtn = modal.querySelector('#close-ranking-btn');
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            // ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        // ë­í‚¹ ë°ì´í„° ë¡œë“œ í•¨ìˆ˜
        function loadRankingData() {
            console.log('ğŸ”„ ë­í‚¹ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì¤‘...');
            
            // ëª¨ì˜ ê²°íˆ¬ ë­í‚¹ ë¡œë“œ
            fetch('/api/rankings/mock')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('ğŸ“Š ëª¨ì˜ ê²°íˆ¬ ë­í‚¹ ë¡œë“œ ì™„ë£Œ:', data.rankings.length + 'ëª…');
                        displayRanking('mock-ranking-list', data.rankings, 'ğŸ­');
                    }
                })
                .catch(error => {
                    console.error('ëª¨ì˜ ê²°íˆ¬ ë­í‚¹ ë¡œë“œ ì˜¤ë¥˜:', error);
                    document.getElementById('mock-ranking-list').innerHTML = '<div class="text-center text-red-500">ë¡œë”© ì‹¤íŒ¨</div>';
                });
            
            // ì •ì‹ ê²°íˆ¬ ë­í‚¹ ë¡œë“œ
            fetch('/api/rankings/formal')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('ğŸ“Š ì •ì‹ ê²°íˆ¬ ë­í‚¹ ë¡œë“œ ì™„ë£Œ:', data.rankings.length + 'ëª…');
                        displayRanking('formal-ranking-list', data.rankings, 'âš”ï¸');
                    }
                })
                .catch(error => {
                    console.error('ì •ì‹ ê²°íˆ¬ ë­í‚¹ ë¡œë“œ ì˜¤ë¥˜:', error);
                    document.getElementById('formal-ranking-list').innerHTML = '<div class="text-center text-red-500">ë¡œë”© ì‹¤íŒ¨</div>';
                });
        }
        
        // ë­í‚¹ í‘œì‹œ í•¨ìˆ˜
        function displayRanking(containerId, rankings, icon) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            if (rankings.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-500">ì•„ì§ ë­í‚¹ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }
            
            let html = '';
            rankings.forEach((rank, index) => {
                const rankClass = index === 0 ? 'bg-yellow-100 border-yellow-300' : 
                                index === 1 ? 'bg-gray-100 border-gray-300' : 
                                index === 2 ? 'bg-orange-100 border-orange-300' : 
                                'bg-white border-gray-200';
                const rankIcon = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}`;
                
                html += `
                    <div class="flex items-center justify-between p-3 border rounded-lg ${rankClass}">
                        <div class="flex items-center space-x-3">
                            <span class="text-lg font-bold">${rankIcon}</span>
                            <span class="font-semibold">${rank.nickname}</span>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-bold text-blue-600">${rank.score}ì </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function showProfileModal() {
            // ì„œë²„ì—ì„œ ìµœì‹  ìœ ì € ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            fetch(`/api/profile/${currentUserData.userId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    showToast('ìœ ì € ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error', 3000);
                    return;
                }
                
                const userData = data.userData;
                const stats = loadStats();
                const mockStats = stats.mock || { wins: 0, losses: 0 };
                const formalStats = stats.formal || { wins: 0, losses: 0 };
                
                const mockTotalGames = mockStats.wins + mockStats.losses;
                const formalTotalGames = formalStats.wins + formalStats.losses;
                
                const mockWinRate = mockTotalGames > 0 ? ((mockStats.wins / mockTotalGames) * 100).toFixed(1) : 0;
                const formalWinRate = formalTotalGames > 0 ? ((formalStats.wins / formalTotalGames) * 100).toFixed(1) : 0;
                
                // ë¡œê·¸ì¸í•œ ê³„ì •ì˜ ë‹‰ë„¤ì„ ì‚¬ìš©
                const playerName = userData.nickname || '';
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                
                // ì—°ìŠ¹ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const currentWinStreak = parseInt(localStorage.getItem('currentWinStreak')) || 0;
                const maxWinStreak = parseInt(localStorage.getItem('maxWinStreak')) || 0;
                
                // ì„œë²„ì˜ íŠ¸ë¡œí”¼ ì •ë³´ ì‚¬ìš©
                const trophies = userData.trophies || { mock: 0, formal: 0 };
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-lg w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">ë§ˆë²• ì´ë ¥ì„œ</h3>
                    <div class="space-y-4">
                        <div class="text-center">
                            <label class="block text-sm font-bold mb-2">ì§€íŒ¡ì´ ì£¼ì¸ ì´ë¦„</label>
                            <div class="w-full px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white text-center">
                                ${playerName || 'ì´ë¦„ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}
                            </div>
                        </div>
                        <div class="text-center">
                            <label class="block text-sm font-bold mb-2">ëŒ€í‘œ ì•„ì´ì½˜</label>
                            <div class="flex items-center justify-center space-x-3">
                                <div class="text-3xl">${playerIcon}</div>
                                <button id="change-icon-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors">
                                    ì•„ì´ì½˜ ë³€ê²½
                                </button>
                            </div>
                        </div>
                        <div class="space-y-4">
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-yellow-300">ğŸ¤– ëª¨ì˜ ê²°íˆ¬ ëŒ€ì „ ê¸°ë¡</h4>
                                <div class="grid grid-cols-4 gap-2">
                                    <div class="bg-emerald-600 bg-opacity-40 p-2 rounded-lg border border-emerald-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-emerald-100">${mockStats.wins}</div>
                                        <div class="text-xs text-emerald-50 font-semibold">ìŠ¹ë¦¬</div>
                                    </div>
                                    <div class="bg-rose-600 bg-opacity-40 p-2 rounded-lg border border-rose-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-rose-100">${mockStats.losses}</div>
                                        <div class="text-xs text-rose-50 font-semibold">íŒ¨ë°°</div>
                                    </div>
                                    <div class="bg-cyan-600 bg-opacity-40 p-2 rounded-lg border border-cyan-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-cyan-100">${mockTotalGames}ì „</div>
                                        <div class="text-xs text-cyan-50 font-semibold">ì´ ê²Œì„</div>
                                    </div>
                                    <div class="bg-violet-600 bg-opacity-40 p-2 rounded-lg border border-violet-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-violet-100">${mockWinRate}%</div>
                                        <div class="text-xs text-violet-50 font-semibold">ìŠ¹ë¥ </div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-green-300">ğŸ‘¥ ì •ì‹ ê²°íˆ¬ ëŒ€ì „ ê¸°ë¡</h4>
                                <div class="grid grid-cols-4 gap-2">
                                    <div class="bg-teal-600 bg-opacity-40 p-2 rounded-lg border border-teal-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-teal-100">${formalStats.wins}</div>
                                        <div class="text-xs text-teal-50 font-semibold">ìŠ¹ë¦¬</div>
                                    </div>
                                    <div class="bg-pink-600 bg-opacity-40 p-2 rounded-lg border border-pink-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-pink-100">${formalStats.losses}</div>
                                        <div class="text-xs text-pink-50 font-semibold">íŒ¨ë°°</div>
                                    </div>
                                    <div class="bg-indigo-600 bg-opacity-40 p-2 rounded-lg border border-indigo-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-indigo-100">${formalTotalGames}ì „</div>
                                        <div class="text-xs text-indigo-50 font-semibold">ì´ ê²Œì„</div>
                                    </div>
                                    <div class="bg-fuchsia-600 bg-opacity-40 p-2 rounded-lg border border-fuchsia-400 border-opacity-30 shadow-lg">
                                        <div class="text-sm font-bold text-fuchsia-100">${formalWinRate}%</div>
                                        <div class="text-xs text-fuchsia-50 font-semibold">ìŠ¹ë¥ </div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-orange-300">ğŸ”¥ ì—°ìŠ¹ ê¸°ë¡</h4>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-amber-600 bg-opacity-40 p-3 rounded-lg border border-amber-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-amber-100">${maxWinStreak}ì—°ìŠ¹</div>
                                        <div class="text-xs text-amber-50 font-semibold">ìµœê³  ì—°ìŠ¹</div>
                                    </div>
                                    <div class="bg-lime-600 bg-opacity-40 p-3 rounded-lg border border-lime-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-lime-100">${currentWinStreak}ì—°ìŠ¹</div>
                                        <div class="text-xs text-lime-50 font-semibold">í˜„ì¬ ì—°ìŠ¹</div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-yellow-300">ğŸ† ìŠ¹ë¦¬ì˜ ì¦í‘œ</h4>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-yellow-600 bg-opacity-40 p-3 rounded-lg border border-yellow-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-yellow-100">ğŸ… ${trophies.mock}ê°œ</div>
                                        <div class="text-xs text-yellow-50 font-semibold">ëª¨ì˜ ê²°íˆ¬ ì ìˆ˜</div>
                                    </div>
                                    <div class="bg-red-600 bg-opacity-40 p-3 rounded-lg border border-red-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-red-100">ğŸ… ${trophies.formal}ê°œ</div>
                                        <div class="text-xs text-red-50 font-semibold">ì •ì‹ ê²°íˆ¬ ì ìˆ˜</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-center mt-4">
                        <button id="close-profile-btn" class="px-6 py-3 rounded-lg font-bold btn-secondary">ë‹«ê¸°</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
                // ì•„ì´ì½˜ ë³€ê²½ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                const changeIconBtn = modal.querySelector('#change-icon-btn');
                changeIconBtn.addEventListener('click', () => {
                    showIconSelectionModal().then(() => {
                        // ì•„ì´ì½˜ ì„ íƒ í›„ ëª¨ë‹¬ ë‹«ê¸°
                        document.body.removeChild(modal);
                    });
                });
                
                const closeBtn = modal.querySelector('#close-profile-btn');
                
                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
            })
            .catch(error => {
                console.error('í”„ë¡œí•„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
                showToast('ìœ ì € ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error', 3000);
            });
        }
        
        // ì¡°ì‚¬ ì²˜ë¦¬ í•¨ìˆ˜
        function getJosa(name, josa) {
            const lastName = name.charAt(name.length - 1);
            const hasBatchim = (lastName.charCodeAt(0) - 44032) % 28 !== 0;
            
            switch(josa) {
                case 'ì€/ëŠ”':
                    return hasBatchim ? 'ì€' : 'ëŠ”';
                case 'ì´/ê°€':
                    return hasBatchim ? 'ì´' : 'ê°€';
                case 'ì„/ë¥¼':
                    return hasBatchim ? 'ì„' : 'ë¥¼';
                case 'ì˜':
                    return 'ì˜';
                default:
                    return '';
            }
        }

        function updatePlayerName() {
            const playerName = localStorage.getItem('playerName') || 'Player';
            const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
            const myTitle = DOM.get('my-title');
            if (myTitle) {
                myTitle.textContent = `ë‚˜ (${getPlayerDisplayName()})`;
            }
            
            // íƒ€ì´í‹€ í™”ë©´ì˜ ì•„ì´ì½˜ í‘œì‹œ ì—…ë°ì´íŠ¸
            const currentIconDisplay = DOM.get('current-icon-display');
            if (currentIconDisplay) {
                currentIconDisplay.textContent = playerIcon;
            }
        }
        
        function updateOpponentName() {
            const opponentArea = DOM.get('opponent-area');
            const opponentTitle = opponentArea.querySelector('h2');
            if (opponentTitle) {
                let opponentDisplayName;
                let titleClass = 'text-xl font-bold text-green-300';
                
                if (multiplayerMode) {
                    // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ: ì‹¤ì œ ìœ ì € (ìƒëŒ€ë°© ì•„ì´ì½˜ ì‚¬ìš©)
                    opponentDisplayName = `${opponentIcon} ${opponentName || 'Player'}`;
                } else {
                    // ì‹±ê¸€í”Œë ˆì´ì–´ ëª¨ë“œ: AI (ë¡œë´‡ ì•„ì´ì½˜)
                    switch(aiDifficulty) {
                        case 'easy':
                            opponentDisplayName = 'ğŸ¤– ì‰¬ì›€ í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-green-300';
                            break;
                        case 'normal':
                            opponentDisplayName = 'ğŸ¤– ë³´í†µ í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-yellow-300';
                            break;
                        case 'hard':
                            opponentDisplayName = 'ğŸ¤– ì–´ë ¤ì›€ í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-red-300';
                            break;
                        default:
                            opponentDisplayName = 'ğŸ¤– ì–´ë ¤ì›€ í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-red-300';
                    }
                }
                
                opponentTitle.textContent = `ìƒëŒ€ (${opponentDisplayName})`;
                opponentTitle.className = titleClass;
                console.log('ğŸ‘¤ ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸:', opponentDisplayName, 'ëª¨ë“œ:', multiplayerMode ? 'ë©€í‹°í”Œë ˆì´ì–´' : 'ì‹±ê¸€í”Œë ˆì´ì–´');
            }
        }
        
        function showSurrenderConfirmModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <div class="text-center">
                        <div class="text-4xl mb-4">âš ï¸</div>
                                                                <h3 class="text-xl font-bold mb-4">ë„ë§</h3>
                        <p class="text-gray-300 mb-6">ì •ë§ ë„ë§ì¹˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
                        <div class="flex space-x-3">
                            <button id="confirm-surrender-btn" class="flex-1 py-3 rounded-lg font-bold bg-red-600 hover:bg-red-700 text-white">ë„¤..</button>
                            <button id="cancel-surrender-btn" class="flex-1 py-3 rounded-lg font-bold btn-primary">ì•„ë‹ˆì˜¤</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                const confirmBtn = modal.querySelector('#confirm-surrender-btn');
                const cancelBtn = modal.querySelector('#cancel-surrender-btn');
                
                confirmBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(true);
                });
                
                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(false);
                });
            });
                }
        
        // ì•„ì´ì½˜ ì„ íƒ ëª¨ë‹¬
        function showIconSelectionModal() {
            const currentIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
            const icons = [
                'ğŸ‘¤', 'ğŸ§™â€â™‚ï¸', 'ğŸ§™â€â™€ï¸', 'ğŸ‘‘', 'âš¡', 'ğŸ”¥', 'â„ï¸', 'ğŸŒ™', 'â­', 'ğŸ’',
                'ğŸ¦„', 'ğŸ‰', 'ğŸ¦…', 'ğŸ¦Š', 'ğŸº', 'ğŸ¦', 'ğŸ¯', 'ğŸ¸', 'ğŸ¦‹', 'ğŸŒº'
            ];
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <div class="text-center">
                        <h3 class="text-xl font-bold mb-4">ëŒ€í‘œ ì•„ì´ì½˜ ì„ íƒ</h3>
                        <p class="text-gray-300 mb-6">ìì‹ ì„ ë‚˜íƒ€ë‚¼ ì•„ì´ì½˜ì„ ì„ íƒí•´ì£¼ì„¸ìš”</p>
                        <div class="grid grid-cols-5 gap-3 mb-6">
                            ${icons.map(icon => `
                                <button class="icon-btn p-3 text-2xl rounded-lg border-2 transition-all hover:scale-110 ${
                                    icon === currentIcon ? 'border-blue-500 bg-blue-100 bg-opacity-20' : 'border-gray-600 hover:border-blue-400'
                                }" data-icon="${icon}">
                                    ${icon}
                                </button>
                            `).join('')}
                        </div>
                        <div class="flex space-x-3">
                            <button id="confirm-icon-btn" class="flex-1 py-3 rounded-lg font-bold btn-primary">í™•ì¸</button>
                            <button id="cancel-icon-btn" class="flex-1 py-3 rounded-lg font-bold btn-secondary">ì·¨ì†Œ</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            let selectedIcon = currentIcon;
            
            // ì•„ì´ì½˜ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            const iconButtons = modal.querySelectorAll('.icon-btn');
            iconButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // ì´ì „ ì„ íƒ í•´ì œ
                    iconButtons.forEach(b => {
                        b.classList.remove('border-blue-500', 'bg-blue-100', 'bg-opacity-20');
                        b.classList.add('border-gray-600');
                    });
                    
                    // í˜„ì¬ ì„ íƒ í‘œì‹œ
                    btn.classList.remove('border-gray-600');
                    btn.classList.add('border-blue-500', 'bg-blue-100', 'bg-opacity-20');
                    
                    selectedIcon = btn.dataset.icon;
                });
            });
            
            return new Promise(resolve => {
                const confirmBtn = modal.querySelector('#confirm-icon-btn');
                const cancelBtn = modal.querySelector('#cancel-icon-btn');
                
                confirmBtn.addEventListener('click', () => {
                    localStorage.setItem('playerIcon', selectedIcon);
                    
                    // ë¡œê·¸ì¸í•œ ìƒíƒœë¼ë©´ ì„œë²„ì—ë„ ì•„ì´ì½˜ ì €ì¥
                    if (isLoggedIn && currentUserData && currentSessionId) {
                        fetch('/api/change-icon', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                sessionId: currentSessionId,
                                icon: selectedIcon
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                showToast('ëŒ€í‘œ ì•„ì´ì½˜ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success', 2000);
                                // ì„œë²„ ë°ì´í„° ì—…ë°ì´íŠ¸
                                if (currentUserData) {
                                    currentUserData.icon = selectedIcon;
                                    console.log('âœ… ì•„ì´ì½˜ ë³€ê²½ ì™„ë£Œ:', selectedIcon);
                                }
                            } else {
                                showToast('ì•„ì´ì½˜ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error', 3000);
                                console.error('âŒ ì•„ì´ì½˜ ë³€ê²½ ì‹¤íŒ¨:', data.error);
                            }
                        })
                        .catch(error => {
                            console.error('ì•„ì´ì½˜ ë³€ê²½ ì˜¤ë¥˜:', error);
                            showToast('ì•„ì´ì½˜ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error', 3000);
                        });
                    } else {
                        showToast('ëŒ€í‘œ ì•„ì´ì½˜ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success', 2000);
                    }
                    
                    updatePlayerName(); // í”Œë ˆì´ì–´ ì´ë¦„ ì—…ë°ì´íŠ¸ë¡œ ì•„ì´ì½˜ë„ í•¨ê»˜ ì—…ë°ì´íŠ¸
                    updateAccountUI(); // ê³„ì • UI ì—…ë°ì´íŠ¸
                    document.body.removeChild(modal);
                    resolve();
                });
                
                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }
        

        // Socket.IO ì—°ê²° ì´ˆê¸°í™”
        function initializeSocketIO() {
            if (socket) {
                socket.disconnect();
            }
            
            // Socket.IO ì—°ê²° (ê°œì„ ëœ ì„¤ì •)
            // ë¡œì»¬ ê°œë°œ í™˜ê²½ì—ì„œëŠ” localhost, ë°°í¬ í™˜ê²½ì—ì„œëŠ” ì›ê²© ì„œë²„ ì‚¬ìš©
            const serverUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
                ? 'http://localhost:3000' 
                : `https://${window.location.hostname}`;
            
            console.log(`ğŸ”Œ ì„œë²„ ì—°ê²° ì‹œë„: ${serverUrl}`);
            socket = io(serverUrl, {
                transports: ['websocket', 'polling'],
                timeout: 60000,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            socket.on('connect', () => {
                console.log('ğŸ”Œ Socket.IO ì—°ê²° ì„±ê³µ');
                serverConnected = true;
                
                // ì—°ê²° ì„±ê³µ ì‹œ ë­í‚¹ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ (ë­í‚¹ ëª¨ë‹¬ì´ ì—´ë ¤ìˆëŠ” ê²½ìš°)
                const rankingModal = document.querySelector('.modal-bg');
                if (rankingModal && rankingModal.innerHTML.includes('ë§ˆë²• ë­í‚¹')) {
                    console.log('ğŸ”„ ë­í‚¹ ëª¨ë‹¬ ê°ì§€ - ë°ì´í„° ìƒˆë¡œê³ ì¹¨');
                    // ë­í‚¹ ë°ì´í„° ìë™ ìš”ì²­
                    if (socket && socket.connected) {
                        socket.emit('getRanking', { category: 'ai' });
                        socket.emit('getRanking', { category: 'multiplayer' });
                        socket.emit('getRanking', { category: 'daily' });
                    }
                }
            });
            
            socket.on('disconnect', () => {
                console.log('ğŸ”Œ Socket.IO ì—°ê²° í•´ì œ');
                serverConnected = false;
                addLog('ğŸ”Œ ì„œë²„ì™€ì˜ ì—°ê²°ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                // ì—°ê²° í•´ì œ ì‹œ ë­í‚¹ ëª¨ë‹¬ì— ì—ëŸ¬ í‘œì‹œ
                const rankingModal = document.querySelector('.modal-bg');
                if (rankingModal && rankingModal.innerHTML.includes('ë§ˆë²• ë­í‚¹')) {
                    const containers = ['ai-ranking', 'multiplayer-ranking', 'daily-king-ranking'];
                    containers.forEach(containerId => {
                        const container = document.getElementById(containerId);
                        if (container) {
                            container.innerHTML = `
                                <div class="text-center text-red-400">
                                    <div class="text-lg mb-2">ğŸ”Œ</div>
                                    <div class="text-sm">ì„œë²„ ì—°ê²° í•´ì œ</div>
                                    <div class="text-xs mt-1">ì—°ê²° ë³µêµ¬ ì‹œ ìë™ìœ¼ë¡œ ìƒˆë¡œê³ ì¹¨ë©ë‹ˆë‹¤</div>
                                </div>
                            `;
                        }
                    });
                }
            });
            
            // ì—°ê²° ì¬ì‹œë„
            socket.on('reconnect', (attemptNumber) => {
                console.log(`ğŸ”„ Socket.IO ì¬ì—°ê²° ì„±ê³µ (ì‹œë„ ${attemptNumber})`);
                serverConnected = true;
                addLog('ğŸ”„ ì„œë²„ì™€ì˜ ì—°ê²°ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
            });
            
            socket.on('reconnect_attempt', (attemptNumber) => {
                console.log(`ğŸ”„ Socket.IO ì¬ì—°ê²° ì‹œë„ ${attemptNumber}`);
            });
            
            socket.on('reconnect_failed', () => {
                console.log('âŒ Socket.IO ì¬ì—°ê²° ì‹¤íŒ¨');
                addLog('âŒ ì„œë²„ ì¬ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            });
            
            socket.on('serverStats', (stats) => {
                console.log('ğŸ“Š ì„œë²„ ìƒíƒœ:', stats);
            });
            
            socket.on('waitingForMatch', (data) => {
                console.log('â³ ë§¤ì¹­ ëŒ€ê¸° ì¤‘:', data);
                updateMatchingMessage(data.message);
            });
            
            socket.on('matchFound', (data) => {
                console.log('âœ… ë§¤ì¹­ ì„±ê³µ:', data);
                opponentName = data.opponent.name;
                isHost = data.isHost;
                
                // ìƒëŒ€ë°© ì´ë¦„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                updateOpponentName();
                
                // ë§¤ì¹­ ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
            const matchingModal = DOM.get('matching-modal');
                matchingModal.classList.add('hidden');
                
                // WebRTC ì—°ê²° ì‹œì‘
                initializeWebRTC(data.opponent.id);
            });
            
            socket.on('opponentDisconnected', (data) => {
                console.log('âŒ ìƒëŒ€ë°© ì—°ê²° í•´ì œ:', data);
                addLog(`ìƒëŒ€ë°© ${data.disconnectedPlayerName || 'Unknown'}ì´(ê°€) ì—°ê²°ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤.`);
                
                // ìƒëŒ€ë°©ì´ ê°•ì œì¢…ë£Œí•œ ê²½ìš° ë„ë§ìœ¼ë¡œ ì¸í•œ ìŠ¹ë¦¬ ì²˜ë¦¬
                if (multiplayerMode && state && state.gameStarted && !state.isGameOver) {
                    handleOpponentDisconnect(data.disconnectedPlayerName);
                    
                    // ê°•ì œì¢…ë£Œí•œ í”Œë ˆì´ì–´ì˜ íŒ¨ë°°ë„ ê¸°ë¡ (ì„œë²„ì— ì „ì†¡)
                    if (data.isDisconnectedAsLoser && data.disconnectedPlayerName) {
                        // ê°•ì œì¢…ë£Œí•œ í”Œë ˆì´ì–´ì˜ íŒ¨ë°° ê¸°ë¡ì„ ì„œë²„ì— ì „ì†¡
                        socket.emit('updateRanking', {
                            category: 'multiplayer',
                            playerName: data.disconnectedPlayerName,
                            stats: {
                                wins: 0,
                                losses: 1,
                                currentWinStreak: 0,
                                maxWinStreak: 0,
                                trophies: 0
                            }
                        });
                    }
                } else {
                    setTimeout(() => {
                        showTitleScreen();
                    }, 2000);
                }
            });
            
            // WebRTC ì‹œê·¸ë„ë§ ì´ë²¤íŠ¸
            socket.on('offer', (data) => {
                console.log('ğŸ“¥ Offer ìˆ˜ì‹ :', data);
                handleOffer(data.from, data.offer);
            });
            
            socket.on('answer', (data) => {
                console.log('ğŸ“¥ Answer ìˆ˜ì‹ :', data);
                handleAnswer(data.from, data.answer);
            });
            
            socket.on('iceCandidate', (data) => {
                console.log('ğŸ“¥ ICE Candidate ìˆ˜ì‹ :', data);
                handleIceCandidate(data.from, data.candidate);
            });
            
            // ì„œë²„ ì—ëŸ¬ ì²˜ë¦¬
            socket.on('error', (error) => {
                console.error('âŒ ì„œë²„ ì—ëŸ¬:', error);
                addLog(`âŒ ì„œë²„ ì˜¤ë¥˜: ${error.message}`);
                
                // ì—°ê²° ì¬ì‹œë„
                if (error.context === 'offer' || error.context === 'answer') {
                    setTimeout(() => {
                        console.log('ğŸ”„ WebRTC ì—°ê²° ì¬ì‹œë„...');
                        if (peerConnection) {
                            peerConnection.close();
                            peerConnection = null;
                        }
                        initializeWebRTC(opponentId);
                    }, 2000);
                }
            });
            
            // ê²Œì„ ìƒíƒœ ë³µêµ¬
            socket.on('gameStateRecovery', (data) => {
                console.log('ğŸ”„ ê²Œì„ ìƒíƒœ ë³µêµ¬ ìˆ˜ì‹ :', data);
                if (data.gameState) {
                    state = data.gameState;
                    render();
                    updateButtons();
                    addLog('ğŸ”„ ê²Œì„ ìƒíƒœê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            });

            // ì¹˜íŠ¸: ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ
            socket.on('serverDataReset', (data) => {
                console.log('ğŸ§¹ ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ:', data);
                showToast('ëª¨ë“  ì„œë²„ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success', 3000);
            });

            // ì¹˜íŠ¸: ê°œì¸ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ
            socket.on('myDataReset', (data) => {
                console.log('ğŸ§¹ ê°œì¸ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ:', data);
                showToast(`${data.playerName}ì˜ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success', 3000);
            });
        }
        
        // ë§¤ì¹­ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        function updateMatchingMessage(message) {
            const matchingModal = document.getElementById('matching-modal');
            const messageEl = matchingModal.querySelector('p');
            if (messageEl) {
                messageEl.textContent = message;
            }
        }
        
        // ë©€í‹°í”Œë ˆì´ì–´ ê´€ë ¨ í•¨ìˆ˜ë“¤
        function startMatching() {
            console.log('ğŸ” WebRTC ë©€í‹°í”Œë ˆì´ì–´ ë§¤ì¹­ ì‹œì‘');
            playerName = localStorage.getItem('playerName') || 'Player';
            
            // Socket.IO ì—°ê²° ì´ˆê¸°í™”
            initializeSocketIO();
            
            const matchingModal = DOM.get('matching-modal');
            matchingModal.classList.remove('hidden');
            
            // ëœë¤ ë§¤ì¹­ ë©”ì‹œì§€ í‘œì‹œ
            const matchingMessages = [
                'ê²°íˆ¬í•  ë§ˆë²•ì‚¬ë¥¼ ì†Œí™˜ ì¤‘...',
                'ë§ì§± ëœ° ë§ˆë²•ì‚¬ë¥¼ íƒìƒ‰ ì¤‘...',
                'ìƒëŒ€ ë§ˆë²•ì‚¬ ì¶”ì  ì¤‘...',
                'ëˆ„ê°€ ì£¼ë¬¸ ë¨¼ì € ì™¸ì¹˜ë‚˜ ë³´ì...',
                'ì˜¤ëŠ˜ ìš´ ì—†ì„ ì‚¬ëŒì„ ê³ ë¥´ëŠ” ì¤‘...'
            ];
            const randomMessage = matchingMessages[Math.floor(Math.random() * matchingMessages.length)];
            DOM.get('matching-message').textContent = randomMessage;
            
            // ë§¤ì¹­ ìš”ì²­
            socket.emit('requestMatch', { playerName: playerName });
        }
        
        function cancelMatching() {
            console.log('âŒ ë§¤ì¹­ ì·¨ì†Œ');
            const matchingModal = DOM.get('matching-modal');
            matchingModal.classList.add('hidden');
            
            // Socket.IO ì—°ê²° í•´ì œ
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            
            // WebRTC ì—°ê²° í•´ì œ
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            showTitleScreen();
        }
        
        function startMultiplayerGame() {
            console.log('ğŸ® WebRTC ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ì‹œì‘');
            multiplayerMode = true;
            
            // ë¡œì»¬ ë©”ëª¨ ìƒíƒœ ì´ˆê¸°í™”
            localMemoNotes = {};
            localMemoPanelActive = false;
            
            // ë§¤ì¹­ ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
            const matchingModal = DOM.get('matching-modal');
            matchingModal.classList.add('hidden');
            
            // ê²Œì„ í™”ë©´ í‘œì‹œ í™•ì‹¤íˆ í•˜ê¸° (ê°•ì œë¡œ í‘œì‹œ)
            titleScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            // ê²Œì„ ì‹œì‘ íš¨ê³¼ìŒ ì¬ìƒ
            activateAudioContext();
            playGameStartSound();
            
            // ì¶”ê°€ í™•ì¸: ê²Œì„ í™”ë©´ì´ ì‹¤ì œë¡œ í‘œì‹œë˜ì—ˆëŠ”ì§€ í™•ì¸
            setTimeout(() => {
                if (gameScreen.classList.contains('hidden')) {
                    console.log('âš ï¸ ê²Œì„ í™”ë©´ì´ ì—¬ì „íˆ ìˆ¨ê²¨ì ¸ ìˆìŒ - ê°•ì œ í‘œì‹œ');
                    titleScreen.classList.add('hidden');
                    gameScreen.classList.remove('hidden');
                }
            }, 100);
            
            // í”Œë ˆì´ì–´ ì´ë¦„ ì—…ë°ì´íŠ¸
            updatePlayerName();
            
            // ìƒëŒ€ë°© ì •ë³´ í‘œì‹œ (ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
            updateOpponentName();
            
            // ì–‘ìª½ ëª¨ë‘ ê¸°ë³¸ ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            console.log('ğŸ”„ ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”');
            state = {
                players: [
                    { id: 1, name: playerName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] },
                    { id: 2, name: opponentName || 'Player2', health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] }
                ],
                secretStones: [],
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: 1, // í˜¸ìŠ¤íŠ¸ê°€ í•­ìƒ 1ë²ˆ í”Œë ˆì´ì–´, ì²« í„´ì€ resetGameì—ì„œ ê²°ì •
                isPlayerTurn: true, // í˜¸ìŠ¤íŠ¸ê°€ ì²« í„´ ì‹œì‘ (resetGameì—ì„œ ì¬ì„¤ì •ë¨)
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                isGameOver: false,
                gameStarted: true,
                gameLog: ['ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.']
            };
            
            // ê¸°ë³¸ UI ë Œë”ë§
            createSpellButtons();
            // ê²Œì„ ì‹œì‘ ì‹œ ì£¼ë¬¸ ë²„íŠ¼ í™œì„±í™”
            spellButtonsDisabled = false;
            render();
            updateButtons();
            
            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° ê²Œì„ ì´ˆê¸°í™” ë° ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
            if (isHost) {
                console.log('ğŸ¯ í˜¸ìŠ¤íŠ¸: ê²Œì„ ì´ˆê¸°í™” ì‹œì‘');
                resetGame();
                
                            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° ê²Œì„ ì´ˆê¸°í™” í›„ íƒ€ì´ë¨¸ ì‹œì‘ (í˜¸ìŠ¤íŠ¸ê°€ ì²« í„´ì¼ ë•Œë§Œ)
            if (isHost && state.currentPlayerId === 1) {
                console.log('â° í˜¸ìŠ¤íŠ¸: ì²« í„´ íƒ€ì´ë¨¸ ì‹œì‘');
                startTurnTimer();
            } else if (isHost && state.currentPlayerId === 2) {
                console.log('â° í˜¸ìŠ¤íŠ¸: ìƒëŒ€ í„´ ì‹œì‘ - íƒ€ì´ë¨¸ ì‹œì‘');
                startTurnTimer();
            }
                
                // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° ì´ˆê¸° ê²Œì„ ìƒíƒœë¥¼ ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
                setTimeout(() => {
                    if (dataChannel && dataChannel.readyState === 'open') {
                        console.log('ğŸ“¤ ì´ˆê¸° ê²Œì„ ìƒíƒœ ì „ì†¡');
                        dataChannel.send(JSON.stringify({
                            type: 'gameState',
                            state: state
                        }));
                    } else {
                        console.log('âš ï¸ ë°ì´í„° ì±„ë„ì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ - ì¬ì‹œë„ ì˜ˆì •');
                        // ë°ì´í„° ì±„ë„ì´ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìœ¼ë©´ 1ì´ˆ í›„ ì¬ì‹œë„
                        setTimeout(() => {
                            if (dataChannel && dataChannel.readyState === 'open') {
                                console.log('ğŸ“¤ ì´ˆê¸° ê²Œì„ ìƒíƒœ ì „ì†¡ (ì¬ì‹œë„)');
                                dataChannel.send(JSON.stringify({
                                    type: 'gameState',
                                    state: state
                                }));
                            }
                        }, 1000);
                    }
                }, 500); // 0.5ì´ˆ í›„ ì „ì†¡
            } else {
                console.log('â³ ê²ŒìŠ¤íŠ¸: í˜¸ìŠ¤íŠ¸ì˜ ê²Œì„ ìƒíƒœ ëŒ€ê¸° ì¤‘...');
                addLog('í˜¸ìŠ¤íŠ¸ì˜ ê²Œì„ ì´ˆê¸°í™”ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...');
                
                // ê²ŒìŠ¤íŠ¸ê°€ í˜¸ìŠ¤íŠ¸ì—ê²Œ ìì‹ ì˜ ì•„ì´ì½˜ ì •ë³´ ì „ì†¡
                setTimeout(() => {
                    if (dataChannel && dataChannel.readyState === 'open') {
                        console.log('ğŸ“¤ ê²ŒìŠ¤íŠ¸ ì•„ì´ì½˜ ì •ë³´ ì „ì†¡');
                        dataChannel.send(JSON.stringify({
                            type: 'playerInfo',
                            guestIcon: localStorage.getItem('playerIcon') || 'ğŸ‘¤'
                        }));
                    }
                }, 200);
                
                // ê²ŒìŠ¤íŠ¸ë„ íƒ€ì„ì•„ì›ƒ ì„¤ì •
                setTimeout(() => {
                    if (!state.players || state.players[0].hand.length === 0) {
                        console.log('âš ï¸ í˜¸ìŠ¤íŠ¸ë¡œë¶€í„° ê²Œì„ ìƒíƒœë¥¼ ë°›ì§€ ëª»í•¨ - ìë™ ë³µêµ¬ ì‹œë„');
                        addLog('í˜¸ìŠ¤íŠ¸ ì‘ë‹µì´ ì—†ì–´ ìë™ìœ¼ë¡œ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.');
                        resetGame();
                    }
                }, 5000); // 5ì´ˆ í›„ íƒ€ì„ì•„ì›ƒ
            }
        }

        // WebRTC ì´ˆê¸°í™”
        function initializeWebRTC(opponentId) {
            console.log('ğŸŒ WebRTC ì—°ê²° ì‹œë„ ì¤‘...');
            
            // STUN ì„œë²„ ì„¤ì •
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(configuration);
            
            // ë°ì´í„° ì±„ë„ ìƒì„± (í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš°)
            if (isHost) {
                dataChannel = peerConnection.createDataChannel('gameData');
                setupDataChannel(dataChannel);
            }

            // ë°ì´í„° ì±„ë„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel(dataChannel);
            };

            // ICE í›„ë³´ ì´ë²¤íŠ¸
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('ğŸ“¤ ICE candidate ì „ì†¡:', event.candidate);
                    socket.emit('iceCandidate', {
                        target: opponentId,
                        candidate: event.candidate
                    });
                }
            };

            // ì—°ê²° ìƒíƒœ ë³€ê²½
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    console.log('WebRTC ì—°ê²° ì„±ê³µ!');
                    // í˜¸ìŠ¤íŠ¸ë§Œ ì—¬ê¸°ì„œ ê²Œì„ ì‹œì‘ (ê²ŒìŠ¤íŠ¸ëŠ” ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ë¥¼ ë°›ì„ ë•Œ ì‹œì‘)
                    if (isHost) {
                        startMultiplayerGame();
                    }
                } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    console.log('WebRTC ì—°ê²° ì‹¤íŒ¨ ë˜ëŠ” ì—°ê²° í•´ì œ');
                }
            };

            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° Offer ìƒì„±
            if (isHost) {
                createOffer(opponentId);
            }
        }
        
        // Offer ìƒì„± ë° ì „ì†¡
        async function createOffer(opponentId) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. Offer ìƒì„±ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                console.log('ğŸ“¤ Offer ìƒì„± ë° ì „ì†¡');
                socket.emit('offer', {
                    target: opponentId,
                    offer: offer
                });
            } catch (error) {
                console.error('Offer ìƒì„± ì‹¤íŒ¨:', error);
            }
        }
        
        // Offer ì²˜ë¦¬
        async function handleOffer(from, offer) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. Offer ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                console.log('ğŸ“¤ Answer ìƒì„± ë° ì „ì†¡');
                socket.emit('answer', {
                    target: from,
                    answer: answer
                });
            } catch (error) {
                console.error('Offer ì²˜ë¦¬ ì‹¤íŒ¨:', error);
            }
        }
        
        // Answer ì²˜ë¦¬
        async function handleAnswer(from, answer) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. Answer ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('ğŸ“¥ Answer ì²˜ë¦¬ ì™„ë£Œ');
            } catch (error) {
                console.error('Answer ì²˜ë¦¬ ì‹¤íŒ¨:', error);
            }
        }
        
        // ICE Candidate ì²˜ë¦¬
        async function handleIceCandidate(from, candidate) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. ICE Candidate ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('ğŸ“¥ ICE Candidate ì²˜ë¦¬ ì™„ë£Œ');
            } catch (error) {
                console.error('ICE Candidate ì²˜ë¦¬ ì‹¤íŒ¨:', error);
            }
        }

        // ë°ì´í„° ì±„ë„ ì„¤ì •
        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('ë°ì´í„° ì±„ë„ ì—´ë¦¼');
                // ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ì „ì†¡
                if (isHost) {
                    console.log('ğŸ“¤ ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ì „ì†¡');
                    channel.send(JSON.stringify({
                        type: 'gameStart',
                        hostName: playerName,
                        hostIcon: localStorage.getItem('playerIcon') || 'ğŸ‘¤',
                        guestName: opponentName || 'Player2'
                    }));
                }
            };

            channel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('ğŸ“¥ ê²Œì„ ë©”ì‹œì§€ ìˆ˜ì‹ :', message.type);
                    handleGameMessage(message);
                } catch (error) {
                    console.error('ê²Œì„ ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', error);
                    // íŒŒì‹± ì˜¤ë¥˜ ì‹œ ê²Œì„ ìƒíƒœ ë³µêµ¬
                    setTimeout(() => {
                        safeRefreshGameState();
                    }, 1000);
                }
            };

            channel.onclose = () => {
                console.log('ë°ì´í„° ì±„ë„ ë‹«í˜');
            };
        }

        // ê²Œì„ ë©”ì‹œì§€ ì²˜ë¦¬
        function handleGameMessage(message) {
            console.log('ğŸ“¨ ë°›ì€ ë©”ì‹œì§€:', message);
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ìƒíƒœë¡œ ì´ˆê¸°í™”
            if (!state || !state.players || state.players.length < 2 || !state.players[0] || !state.players[1]) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ê¸°ë³¸ ìƒíƒœë¡œ ì´ˆê¸°í™”');
                const currentPlayerName = localStorage.getItem('playerName') || 'Player';
                state = {
                    players: [
                                        { id: 1, name: currentPlayerName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] },
                { id: 2, name: opponentName || 'Player2', health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] }
                    ],
                    secretStones: [],
                    usedStones: [],
                    publiclyRevealedSecretStones: [],
                    currentPlayerId: 1,
                    isPlayerTurn: false,
                    lastSuccessfulSpell: 0,
                    turnInProgress: false,
                    isGameOver: false,
                    gameStarted: true,
                    gameLog: ['ê²Œì„ ìƒíƒœê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.']
                };
                // ê²Œì„ ìƒíƒœ ë³µêµ¬ ì‹œ ì£¼ë¬¸ ë²„íŠ¼ ì¬í™œì„±í™”
                spellButtonsDisabled = false;
                console.log('âœ… ê²Œì„ ìƒíƒœ ë³µêµ¬ ì™„ë£Œ:', state);
            }
            
            switch (message.type) {
                case 'gameStart':
                    opponentName = isHost ? message.guestName : message.hostName;
                    opponentIcon = isHost ? (message.guestIcon || 'ğŸ‘¤') : (message.hostIcon || 'ğŸ‘¤');
                    console.log('ğŸ‘¤ ìƒëŒ€ë°© ì•„ì´ì½˜ ìˆ˜ì‹ :', opponentIcon);
                    // ê²ŒìŠ¤íŠ¸ì¸ ê²½ìš°ì—ë§Œ startMultiplayerGame í˜¸ì¶œ (í˜¸ìŠ¤íŠ¸ëŠ” ì´ë¯¸ í˜¸ì¶œë¨)
                    if (!isHost) {
                        console.log('ğŸ® ê²ŒìŠ¤íŠ¸: ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ìˆ˜ì‹  - ê²Œì„ ì‹œì‘');
                        startMultiplayerGame();
                    } else {
                        console.log('ğŸ® í˜¸ìŠ¤íŠ¸: ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ìˆ˜ì‹  - ê²Œì„ í™”ë©´ í™•ì¸');
                        // í˜¸ìŠ¤íŠ¸ë„ ê²Œì„ í™”ë©´ì´ ì œëŒ€ë¡œ í‘œì‹œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³  ê°•ì œ í‘œì‹œ
                        if (gameScreen.classList.contains('hidden')) {
                            console.log('âš ï¸ í˜¸ìŠ¤íŠ¸: ê²Œì„ í™”ë©´ì´ ìˆ¨ê²¨ì ¸ ìˆìŒ - ê°•ì œ í‘œì‹œ');
                            titleScreen.classList.add('hidden');
                            gameScreen.classList.remove('hidden');
                        }
                        // í˜¸ìŠ¤íŠ¸ë„ ê²Œì„ í™”ë©´ì´ í‘œì‹œë˜ì—ˆëŠ”ì§€ ë‹¤ì‹œ í•œë²ˆ í™•ì¸
                        setTimeout(() => {
                            if (gameScreen.classList.contains('hidden')) {
                                console.log('âš ï¸ í˜¸ìŠ¤íŠ¸: ê²Œì„ í™”ë©´ì´ ì—¬ì „íˆ ìˆ¨ê²¨ì ¸ ìˆìŒ - ìµœì¢… ê°•ì œ í‘œì‹œ');
                                titleScreen.classList.add('hidden');
                                gameScreen.classList.remove('hidden');
                            }
                        }, 50);
                    }
                    break;
                case 'firstTurn':
                    console.log(`ğŸ¯ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì • ìˆ˜ì‹ : í”Œë ˆì´ì–´ ${message.firstPlayer}`);
                    // í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ìœ¼ë¡œ ê²Œì„ ì´ˆê¸°í™”
                    resetGameWithFirstPlayer(message.firstPlayer);
                    break;
                case 'gameState':
                    console.log('ğŸ“¥ ê²Œì„ ìƒíƒœ ìˆ˜ì‹ ');
                    if (message.state) {
                        updateGameState(message.state);
                        
                        // ê²ŒìŠ¤íŠ¸ê°€ í˜¸ìŠ¤íŠ¸ì˜ ê²Œì„ ìƒíƒœë¥¼ ë°›ì•˜ì„ ë•Œ íƒ€ì´ë¨¸ ì‹œì‘
                        if (!isHost) {
                            console.log(`â° ê²ŒìŠ¤íŠ¸: í˜¸ìŠ¤íŠ¸ ê²Œì„ ìƒíƒœ ìˆ˜ì‹  - ì²« í„´ í”Œë ˆì´ì–´: ${message.state.currentPlayerId}`);
                            setTimeout(() => {
                                startTurnTimer();
                            }, 100); // ì•½ê°„ì˜ ì§€ì—° í›„ íƒ€ì´ë¨¸ ì‹œì‘
                        }
                    }
                    break;
                case 'cardPlayed':
                    handleCardPlayed(message.card, message.playerId, message.gameState);
                    break;
                case 'turnEnd':
                    console.log('ğŸ“¥ í„´ ì¢…ë£Œ ë©”ì‹œì§€ ìˆ˜ì‹ ');
                    handleTurnEnd(message.gameState);
                    break;
                case 'gameOver':
                    handleGameOver(message.winner, message.gameState);
                    break;
                case 'surrender':
                    handleSurrender(message.surrenderingPlayerId);
                    break;
                case 'playerInfo':
                    // ê²ŒìŠ¤íŠ¸ì˜ ì•„ì´ì½˜ ì •ë³´ ìˆ˜ì‹  (í˜¸ìŠ¤íŠ¸ë§Œ ì²˜ë¦¬)
                    if (isHost && message.guestIcon) {
                        opponentIcon = message.guestIcon;
                        console.log('ğŸ‘¤ ê²ŒìŠ¤íŠ¸ ì•„ì´ì½˜ ì •ë³´ ìˆ˜ì‹ :', opponentIcon);
                        updateOpponentName();
                    }
                    break;
                case 'spellFailed':
                    console.log('ğŸ“¥ ì˜ì°½ ì‹¤íŒ¨ ë©”ì‹œì§€ ìˆ˜ì‹ ');
                    // ìƒëŒ€ë°© ì˜ì°½ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™”
                    spellButtonsDisabled = true;
                    disableSpellButtons();
                    
                    // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ì¦‰ì‹œ ë¹„í™œì„±í™”
                    endTurnBtn.disabled = true;
                    endTurnBtn.style.opacity = '0.5';
                    endTurnBtn.style.cursor = 'not-allowed';
                    
                    // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë²„íŠ¼ ìƒíƒœëŠ” ìœ ì§€)
                    if (message.gameState) {
                        // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” ê° í”Œë ˆì´ì–´ë³„ë¡œ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬
                        const currentRevealedStones = state.publiclyRevealedSecretStones;
                        
                        state = message.gameState;
                        
                        // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì •ë³´ë§Œ ìœ ì§€
                        state.publiclyRevealedSecretStones = currentRevealedStones;
                        
                        // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ í„´ ìƒíƒœ ë™ê¸°í™”
                        if (multiplayerMode) {
                            const myPlayerId = isHost ? 1 : 2;
                            const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                            if (state.isPlayerTurn !== shouldBeMyTurn) {
                                state.isPlayerTurn = shouldBeMyTurn;
                            }
                        }
                        
                        // ê²Œì„ ìƒíƒœë§Œ ì—…ë°ì´íŠ¸í•˜ê³  ë²„íŠ¼ ìƒíƒœëŠ” ìœ ì§€
                        render();
                        
                        // ë©”ëª¨ íŒ¨ë„ ìƒíƒœ ë³µì›
                        if (localMemoPanelActive) {
                            const memoButtons = DOM.get('memo-buttons');
                            memoButtons.classList.remove('hidden');
                        }
                    }
                    break;
            }
        }



        // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateGameState(newState) {
            console.log('ğŸ”„ ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸');
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•œì§€ í™•ì¸
            if (!newState || !newState.players || newState.players.length < 2) {
                console.log('âš ï¸ ë°›ì€ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ');
                return;
            }
            
            // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” ê° í”Œë ˆì´ì–´ë³„ë¡œ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬
            const currentRevealedStones = state.publiclyRevealedSecretStones;
            
            state = newState;
            
            // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì •ë³´ë§Œ ìœ ì§€
            state.publiclyRevealedSecretStones = currentRevealedStones;
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ í„´ ìƒíƒœ ë™ê¸°í™”
            if (multiplayerMode) {
                const myPlayerId = isHost ? 1 : 2;
                const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                if (state.isPlayerTurn !== shouldBeMyTurn) {
                    state.isPlayerTurn = shouldBeMyTurn;
                }
            }
            
            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹œ ì£¼ë¬¸ ë²„íŠ¼ ì¬í™œì„±í™”
            spellButtonsDisabled = false;
            
            render();
            updateButtons();
            
            // ë©”ëª¨ íŒ¨ë„ ìƒíƒœ ë³µì›
            if (localMemoPanelActive) {
                const memoButtons = DOM.get('memo-buttons');
                memoButtons.classList.remove('hidden');
            }
            
            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ íƒ€ì´ë¨¸ ì‹œì‘
            if (isHost) {
                console.log(`â° í˜¸ìŠ¤íŠ¸: ê²Œì„ ìƒíƒœ ìˆ˜ì‹  í›„ íƒ€ì´ë¨¸ ì‹œì‘ - ì²« í„´ í”Œë ˆì´ì–´: ${state.currentPlayerId}`);
                setTimeout(() => {
                    startTurnTimer();
                }, 100); // ì•½ê°„ì˜ ì§€ì—° í›„ íƒ€ì´ë¨¸ ì‹œì‘
            }
            
            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ ë¡œê·¸
            console.log('âœ… ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
        }

                    // ì£¼ë¬¸ í”Œë ˆì´ ì²˜ë¦¬
        function handleCardPlayed(card, playerId, gameState = null) {
            console.log(`ğŸ¯ ì£¼ë¬¸ í”Œë ˆì´ ì²˜ë¦¬: ${card}, í”Œë ˆì´ì–´ ${playerId}`);
            
            if (gameState) {
                // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” ê° í”Œë ˆì´ì–´ë³„ë¡œ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬
                const currentRevealedStones = state.publiclyRevealedSecretStones;
                
                // ìƒëŒ€ë°©ì´ ë³´ë‚¸ ê²Œì„ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                state = gameState;
                
                // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì •ë³´ë§Œ ìœ ì§€
                state.publiclyRevealedSecretStones = currentRevealedStones;
                
                console.log('ğŸ”„ ê²Œì„ ìƒíƒœ ë™ê¸°í™”ë¨');
                
                // ìƒëŒ€ë°©ì˜ ì£¼ë¬¸ í”Œë ˆì´ íš¨ê³¼ ì‹¤í–‰
                const player = state.players.find(p => p.id === playerId);
                const opponent = state.players.find(p => p.id !== playerId);
                
                // ì£¼ë¬¸ íš¨ê³¼ ì‹¤í–‰ (ìƒëŒ€ë°©ì´ í”Œë ˆì´í•œ ì£¼ë¬¸)
                executeSpellEffect(playerId, card);
                
                // ìƒëŒ€ë°© ì˜ì°½ ì„±ê³µ íŒŒí‹°í´ íš¨ê³¼
                createModalParticles(card);
            } else {
                // ì£¼ë¬¸ íš¨ê³¼ ì ìš©
                const player = state.players.find(p => p.id === playerId);
                const opponent = state.players.find(p => p.id !== playerId);
                
                applyCardEffect(card, player, opponent);
            }
            render();
            
            // ë©”ëª¨ íŒ¨ë„ ìƒíƒœ ë³µì›
            if (localMemoPanelActive) {
                const memoButtons = DOM.get('memo-buttons');
                memoButtons.classList.remove('hidden');
            }
        }

        // í„´ ì¢…ë£Œ ì²˜ë¦¬
        function handleTurnEnd(gameState = null) {
            console.log('ğŸ”„ í„´ ì¢…ë£Œ ì²˜ë¦¬');
            
            if (gameState) {
                // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” ê° í”Œë ˆì´ì–´ë³„ë¡œ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬
                const currentRevealedStones = state.publiclyRevealedSecretStones;
                
                // ìƒëŒ€ë°©ì´ ë³´ë‚¸ ê²Œì„ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                state = gameState;
                
                // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì •ë³´ë§Œ ìœ ì§€
                state.publiclyRevealedSecretStones = currentRevealedStones;
                
                console.log('ğŸ”„ í„´ ì¢…ë£Œ ì‹œ ê²Œì„ ìƒíƒœ ë™ê¸°í™”ë¨');
                
                // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” currentPlayerIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ isPlayerTurn ì¬ì„¤ì •
                if (multiplayerMode) {
                    const myPlayerId = isHost ? 1 : 2;
                    const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                    state.isPlayerTurn = shouldBeMyTurn;
                    console.log(`ğŸ® í„´ ë™ê¸°í™” - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${shouldBeMyTurn}`);
                }
                
                // í„´ ì „í™˜ í›„ í˜„ì¬ í”Œë ˆì´ì–´ í„´ ì‹œì‘ ë¡œê·¸
                const currentPlayerName = state.currentPlayerId === 1 ? state.players[0].name : state.players[1].name;
                addLog(Messages.turnStart(currentPlayerName));
                
                // íƒ€ì´ë¨¸ ì‹œì‘
                setTimeout(() => {
                    startTurnTimer();
                }, 500);
                
                // í„´ì„ ë°›ì€ í”Œë ˆì´ì–´ì˜ ê²½ìš° ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰
                if (multiplayerMode && state.isPlayerTurn) {
                    console.log('ğŸ¯ ë‚´ í„´ ì‹œì‘ - ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
                    setTimeout(() => {
                        safeRefreshGameState();
                    }, 500);
                }
            } else {
                state.isPlayerTurn = !state.isPlayerTurn;
                state.currentPlayerId = state.currentPlayerId === 1 ? 2 : 1;
                
                // AI ëª¨ë“œì—ì„œë„ íƒ€ì´ë¨¸ ì‹œì‘
                setTimeout(() => {
                    startTurnTimer();
                }, 500);
            }
            render();
            updateButtons(); // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ ì¶”ê°€
            
            // ë©”ëª¨ íŒ¨ë„ ìƒíƒœ ë³µì›
            if (localMemoPanelActive) {
                const memoButtons = DOM.get('memo-buttons');
                memoButtons.classList.remove('hidden');
            }
        }

        // ìƒëŒ€ë°© ì—°ê²° í•´ì œ ì²˜ë¦¬ (ë„ë§ìœ¼ë¡œ ì¸í•œ ìŠ¹ë¦¬)
        async function handleOpponentDisconnect(opponentName = 'Unknown') {
            console.log('ğŸƒ ìƒëŒ€ë°© ê°•ì œì¢…ë£Œ - ë„ë§ìœ¼ë¡œ ì¸í•œ ìŠ¹ë¦¬ ì²˜ë¦¬');
            
            // ê²Œì„ ìƒíƒœë¥¼ ì¢…ë£Œ ìƒíƒœë¡œ ì„¤ì •
            state.isGameOver = true;
            
            // ìŠ¹ë¦¬ ì²˜ë¦¬ (ìƒëŒ€ë°©ì´ ë„ë§ì³¤ìœ¼ë¯€ë¡œ ë‚´ê°€ ìŠ¹ë¦¬)
            updateStats(true, true);
            
            // ìŠ¹ë¦¬ì˜ ì¦í‘œ ì¶”ê°€ (ë©€í‹°í”Œë ˆì´ì–´ ìŠ¹ë¦¬)
            TrophySystem.addVictoryTrophy('multiplayer');
            
            // ì „ì  ì—…ë°ì´íŠ¸ (ì—°ìŠ¹ ì²˜ë¦¬ í¬í•¨)
            updateStats(true, true); // ìŠ¹ë¦¬, ë©€í‹°í”Œë ˆì´ì–´
            
            // ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            if (socket && socket.connected) {
                const playerName = localStorage.getItem('playerName') || 'Player';
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                const trophies = TrophySystem.loadTrophies();
                
                socket.emit('updateRanking', {
                    category: 'formal',
                    playerName: playerName,
                    score: trophies.multiplayer,
                    icon: playerIcon
                });
                
                console.log(`ğŸ”„ ìƒëŒ€ë°© ê°•ì œì¢…ë£Œ í›„ ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸: ${playerName}`);
            }
            
            let message = `ìƒëŒ€ ${opponentName}ì´(ê°€) ê°•ì œì¢…ë£Œí•˜ì—¬ ìŠ¹ë¦¬í•˜ì˜€ìŠµë‹ˆë‹¤!`;
            
            // 2ì—°ìŠ¹ ì´ìƒì¼ ë•Œ ì—°ìŠ¹ ë©”ì‹œì§€ ì¶”ê°€
            if (currentWinStreak >= 2) {
                message += `\n\n${Messages.streak(currentWinStreak)}`;
            }
            
            message += '\n\nğŸ… ìŠ¹ì  +3';
            
            addLog(`ìƒëŒ€ë°© ${opponentName}ì´(ê°€) ê°•ì œì¢…ë£Œí–ˆìŠµë‹ˆë‹¤.`);
            addLog('ìŠ¹ë¦¬ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ìŠ¹ë¦¬í•œ í”Œë ˆì´ì–´ì—ê²Œ ë©”ì‹œì§€ í‘œì‹œ
            await showModal('ê²Œì„ ì¢…ë£Œ', message, true);
            
            // íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            showTitleScreen();
        }

        // ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬
        function handleGameOver(winner, gameState = null) {
            console.log('ğŸ† ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬');
            
            if (gameState) {
                // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” ê° í”Œë ˆì´ì–´ë³„ë¡œ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬
                const currentRevealedStones = state.publiclyRevealedSecretStones;
                
                // ìƒëŒ€ë°©ì´ ë³´ë‚¸ ê²Œì„ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                state = gameState;
                
                // ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ ì •ë³´ëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì •ë³´ë§Œ ìœ ì§€
                state.publiclyRevealedSecretStones = currentRevealedStones;
                
                console.log('ğŸ”„ ê²Œì„ ì¢…ë£Œ ì‹œ ê²Œì„ ìƒíƒœ ë™ê¸°í™”ë¨');
            } else {
                state.isGameOver = true;
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ í˜„ì¬ í”Œë ˆì´ì–´ ID ê³„ì‚°
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const isPlayerWin = winner === myPlayerId;
            
            // ì „ì  ì—…ë°ì´íŠ¸
            updateStats(isPlayerWin, true);
            
            // ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            if (socket && socket.connected) {
                const playerName = localStorage.getItem('playerName') || 'Player';
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                const trophies = TrophySystem.loadTrophies();
                
                socket.emit('updateRanking', {
                    category: 'formal',
                    playerName: playerName,
                    score: trophies.multiplayer,
                    icon: playerIcon
                });
                
                console.log(`ğŸ”„ ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ì¢…ë£Œ í›„ ë­í‚¹ ì¦‰ì‹œ ì—…ë°ì´íŠ¸: ${playerName} (${isPlayerWin ? 'ìŠ¹ë¦¬' : 'íŒ¨ë°°'})`);
            }
            
            // ìŠ¹ë¦¬/íŒ¨ë°° ë©”ì‹œì§€ ìƒì„±
            const winnerPlayer = state.players.find(p => p.id === winner);
            if (!winnerPlayer) {
                console.error('âŒ ìŠ¹ë¦¬ í”Œë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', winner);
                return;
            }
            
            let message;
            if (isPlayerWin) {
                // ìŠ¹ë¦¬í•œ ê²½ìš°
                const myPlayer = state.players.find(p => p.id === myPlayerId);
                const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
                
                if (!myPlayer || !opponentPlayer) {
                    console.error('âŒ í”Œë ˆì´ì–´ ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', { myPlayerId, myPlayer, opponentPlayer });
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (opponentPlayer.health <= 0) {
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!';
                } else if (myPlayer.hand.length === 0) {
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!';
                } else {
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ê°€ ë„ë§ì³¤ìŠµë‹ˆë‹¤!';
                }
            } else {
                // íŒ¨ë°°í•œ ê²½ìš°
                const myPlayer = state.players.find(p => p.id === myPlayerId);
                const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
                
                if (!myPlayer || !opponentPlayer) {
                    console.error('âŒ í”Œë ˆì´ì–´ ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', { myPlayerId, myPlayer, opponentPlayer });
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (myPlayer.health <= 0) {
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìì‹ ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (opponentPlayer.hand.length === 0) {
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìƒëŒ€ê°€ ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.';
                } else {
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ë„ë§ì¹˜ê³  ë§ì•˜ìŠµë‹ˆë‹¤.';
                }
            }
            
            // ì—°ìŠ¹ ë©”ì‹œì§€ ì¶”ê°€ (updateStatsì—ì„œ ì²˜ë¦¬ëœ ì—°ìŠ¹ ì‚¬ìš©)
            if (isPlayerWin && currentWinStreak >= 2) {
                message += `\n\n${Messages.streak(currentWinStreak)}`;
            }
            
            // ìŠ¹ë¦¬/íŒ¨ë°° ì‚¬ìš´ë“œ
            activateAudioContext();
            playGameOverSound(isPlayerWin);
            
            // ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ í‘œì‹œ
            showModal('ê²Œì„ ì¢…ë£Œ', message, true);
            addLog(`- ê²Œì„ ì¢…ë£Œ: ${winnerPlayer.name} ìŠ¹ë¦¬! -`);
            render();
        }
        
        function startAIGame() {
            console.log(`ğŸ¤– AI ê²Œì„ ì‹œì‘ (ë‚œì´ë„: ${aiDifficulty})`);
            multiplayerMode = false;
            titleScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            // ê²Œì„ ì‹œì‘ íš¨ê³¼ìŒ ì¬ìƒ
            activateAudioContext();
            playGameStartSound();
            
            resetGame();
            
            // AI ì •ë³´ í‘œì‹œ (ë‚œì´ë„ë³„)
            const aiName = aiDifficulty === 'easy' ? 'ğŸ¤– ì‰¬ì›€ í—ˆìˆ˜ì•„ë¹„' : aiDifficulty === 'normal' ? 'ğŸ¤– ë³´í†µ í—ˆìˆ˜ì•„ë¹„' : 'ğŸ¤– ì–´ë ¤ì›€ í—ˆìˆ˜ì•„ë¹„';
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” ì‹œ AI ì´ë¦„ ì„¤ì •
            if (state.players && state.players[1]) {
                state.players[1].name = aiName;
            }
            
            // AI ë‚œì´ë„ë³„ ì‹œê°„ ì œí•œ ì„¤ì •
            setTurnDurationByDifficulty();
            
            // ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸
            updateOpponentName();
        }
        
        // AI ë‚œì´ë„ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
        function showAIDifficultyModal() {
            const modal = DOM.get('ai-difficulty-modal');
            modal.classList.remove('hidden');
            playCardSound();
        }
        
        // ë§ˆë²• ì¹´ë“œ ì •ë³´ ëª¨ë‹¬ í‘œì‹œ
        function showSpellCardsModal() {
            const modal = DOM.get('spell-cards-modal');
            modal.classList.remove('hidden');
            playCardSound();
        }
        
        // ë§ˆë²• ì¹´ë“œ ì •ë³´ ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
        function hideSpellCardsModal() {
            const modal = DOM.get('spell-cards-modal');
            modal.classList.add('hidden');
            playCardSound();
        }
        
        // AI ë‚œì´ë„ ì„ íƒ ì²˜ë¦¬
        function selectAIDifficulty(difficulty) {
            aiDifficulty = difficulty;
            console.log(`ğŸ¤– AI ë‚œì´ë„ ì„ íƒ: ${difficulty}`);
            
            const modal = DOM.get('ai-difficulty-modal');
            modal.classList.add('hidden');
            
            startAIGame();
        }
        
        // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
        function showToast(message, type = 'info', duration = 3000) {
            const toast = DOM.get('toast');
            const toastMessage = DOM.get('toast-message');
            
            // ê¸°ì¡´ íƒ€ì… í´ë˜ìŠ¤ ì œê±°
            toast.classList.remove('bg-green-500', 'bg-yellow-500', 'bg-red-500', 'bg-blue-500');
            
            // íƒ€ì…ì— ë”°ë¥¸ ë°°ê²½ìƒ‰ ì„¤ì •
            switch (type) {
                case 'success':
                    toast.classList.add('bg-green-500');
                    break;
                case 'warning':
                    toast.classList.add('bg-yellow-500');
                    break;
                case 'error':
                    toast.classList.add('bg-red-500');
                    break;
                default:
                    toast.classList.add('bg-blue-500');
                    break;
            }
            
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            
            setTimeout(() => {
                toast.classList.add('hidden');
            }, duration);
        }
        
        // íƒ€ì´í‹€ í™”ë©´ í‘œì‹œ í•¨ìˆ˜
        function showTitleScreen() {
            // ê²Œì„ ì‹œì‘ ì¤‘ì—ëŠ” íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ì§€ ì•Šë„ë¡ ë³´í˜¸
            if (GameConditions.isGameInProgress()) {
                console.log('âš ï¸ ê²Œì„ ì§„í–‰ ì¤‘ - íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ì§€ ì•ŠìŒ');
                return;
            }
            
            console.log('ğŸ  íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°');
            gameScreen.classList.add('hidden');
            titleScreen.classList.remove('hidden');
            
            // íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
            stopTurnTimer();
            resetTurnGauge();
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
            state = {
                gameStarted: false,
                isGameOver: true,
                players: [],
                secretStones: [],
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: null,
                isPlayerTurn: false,
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                gameLog: []
            };
            
            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ ì´ˆê¸°í™”
            multiplayerMode = false;
            peerConnection = null;
            dataChannel = null;
            isHost = false;
            opponentName = '';
            myPlayerId = null;
            
            // ê¸°ë³¸ ì´ë¦„ ì´ˆê¸°í™” (ì²« ë°©ë¬¸ ì‹œ ëœë¤ ì´ë¦„ ìƒì„±)
            initializePlayerName();
            
            // 3ì´ˆê°„ ë²„íŠ¼ ë¹„í™œì„±í™”
            disableTitleButtons();
        }
        
        // íƒ€ì´í‹€ í™”ë©´ ë²„íŠ¼ ë¹„í™œì„±í™”
        function disableTitleButtons() {
            const buttons = titleScreen.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
            
            // 1ì´ˆ í›„ ë²„íŠ¼ í™œì„±í™”
            setTimeout(() => {
                enableTitleButtons();
            }, 1000);
        }
        
        // íƒ€ì´í‹€ í™”ë©´ ë²„íŠ¼ í™œì„±í™”
        function enableTitleButtons() {
            const buttons = titleScreen.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            });
        }
        
        // ë„ë§ í•¨ìˆ˜
        async function surrenderGame() {
            const confirmed = await showSurrenderConfirmModal();
            if (confirmed) {
                // íŒ¨ë°° íš¨ê³¼ìŒ ì¬ìƒ
                activateAudioContext();
                playGameOverSound(false);
                
                // íŒ¨ë°° ì²˜ë¦¬
                updateStats(false, multiplayerMode);
                
                // ìŠ¹ì  ê°ì†Œ ì²˜ë¦¬
                if (multiplayerMode) {
                    TrophySystem.addDefeatTrophy('multiplayer');
                } else {
                    TrophySystem.addDefeatTrophy('ai');
                }
                
                addLog('ê²°íˆ¬ë¥¼ ë„ë§ì³¤ìŠµë‹ˆë‹¤.');
                addLog('íŒ¨ë°°ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ë„ë§ ë©”ì‹œì§€ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'surrender',
                        surrenderingPlayerId: 1
                    }));
                }
                
                // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
                state = {
                    gameStarted: false,
                    isGameOver: true,
                    players: [],
                    secretStones: [],
                    usedStones: [],
                    publiclyRevealedSecretStones: [],
                    currentPlayerId: null,
                    isPlayerTurn: false,
                    lastSuccessfulSpell: 0,
                    turnInProgress: false,
                    gameLog: []
                };
                
                // ì—°ìŠ¹ ì´ˆê¸°í™” (íŒ¨ë°° ì‹œ)
                localStorage.setItem('currentWinStreak', '0');
                
                // ë„ë§í•œ í”Œë ˆì´ì–´ì—ê²Œ ë©”ì‹œì§€ í‘œì‹œ (ìŠ¹ì  ê°ì†Œ í¬í•¨)
                let message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ë„ë§ì¹˜ê³  ë§ì•˜ìŠµë‹ˆë‹¤.';
                message += '\n\nğŸ… ìŠ¹ì  -1';
                await showModal('ê²Œì„ ì¢…ë£Œ', message, true);
                
                // ë°”ë¡œ íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                showTitleScreen();
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        DOM.get('ai-battle-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            activateAudioContext(); // AudioContext í™œì„±í™”
            showAIDifficultyModal();
        });
        DOM.get('multiplayer-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            
            // ê³„ì • ë¡œê·¸ì¸ í™•ì¸
            if (!isLoggedIn) {
                showToast('ì •ì‹ ê²°íˆ¬ëŠ” ê³„ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.', 'warning', 3000);
                showAuthModal('login');
                return;
            }
            
            activateAudioContext(); // AudioContext í™œì„±í™”
            startMatching();
        });
        DOM.get('cancel-matching-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            cancelMatching();
        });
        
        // AI ë‚œì´ë„ ì„ íƒ ë²„íŠ¼ë“¤
        DOM.get('easy-ai-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            activateAudioContext(); // AudioContext í™œì„±í™”
            selectAIDifficulty('easy');
        });
        DOM.get('normal-ai-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            activateAudioContext(); // AudioContext í™œì„±í™”
            selectAIDifficulty('normal');
        });
        DOM.get('hard-ai-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            activateAudioContext(); // AudioContext í™œì„±í™”
            selectAIDifficulty('hard');
        });
        DOM.get('cancel-difficulty-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            DOM.get('ai-difficulty-modal').classList.add('hidden');
        });
        
        // ë§ˆë²• ì¹´ë“œ ë³´ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('spell-cards-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            showSpellCardsModal();
        });
        
        // ë§ˆë²• ì¹´ë“œ ëª¨ë‹¬ ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('close-spell-cards-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            hideSpellCardsModal();
        });

        endTurnBtn.addEventListener('click', () => {
            console.log('ğŸ”„ í„´ ì¢…ë£Œ ë²„íŠ¼ í´ë¦­');
            
            // ì¦‰ì‹œ ë²„íŠ¼ ë¹„í™œì„±í™”ë¡œ ì¤‘ë³µ í´ë¦­ ë°©ì§€
            endTurnBtn.disabled = true;
            endTurnBtn.style.opacity = '0.5';
            endTurnBtn.style.cursor = 'not-allowed';
            
            if (GameConditions.canPlaySpell()) {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                addLog(`- ${state.players[myPlayerId - 1].name}${getJosa(state.players[myPlayerId - 1].name, 'ì´/ê°€')} í„´ì„ ìˆ˜ë™ìœ¼ë¡œ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤.`);
                endTurn();
            } else {
                // ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™”
                setTimeout(() => {
                    if (GameConditions.canPlaySpell()) {
                        endTurnBtn.disabled = false;
                        endTurnBtn.style.opacity = '1';
                        endTurnBtn.style.cursor = 'pointer';
                    }
                }, 100);
            }
        });
        
        // ë„ë§ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('surrender-btn').addEventListener('click', surrenderGame);
        
        // ë‚´ ì •ë³´ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('profile-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            showProfileModal();
        });
        
        // ë­í‚¹ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('ranking-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'info', 3000);
                return;
            }
            showRankingModal();
        });
        

        
        // ì´ë¦„ ì…ë ¥ ë° ì €ì¥ ê¸°ëŠ¥
        const playerNameInput = DOM.get('player-name-input');
        const saveNameBtn = DOM.get('save-name-btn');
        const nameSaveStatus = DOM.get('name-save-status');
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ í˜„ì¬ ì´ë¦„ ì„¤ì •
        const currentName = localStorage.getItem('playerName') || '';
        playerNameInput.value = currentName;
        updateNameSaveStatus();
        updatePlayerName(); // ì•„ì´ì½˜ë„ í•¨ê»˜ ì—…ë°ì´íŠ¸
        
        // ì´ë¦„ ì…ë ¥ ì‹œ ì €ì¥ ìƒíƒœ ì—…ë°ì´íŠ¸
        playerNameInput.addEventListener('input', updateNameSaveStatus);
        
        // ì €ì¥ ë²„íŠ¼ í´ë¦­
        saveNameBtn.addEventListener('click', () => {
            const newName = playerNameInput.value.trim();
            if (newName) {
                const oldName = localStorage.getItem('playerName') || 'Player';
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                
                localStorage.setItem('playerName', newName);
                console.log(`ğŸ‘¤ í”Œë ˆì´ì–´ ì´ë¦„ ì €ì¥: ${oldName} -> ${newName}`);
                
                // ì„œë²„ì— ì´ë¦„ ë³€ê²½ ì•Œë¦¼
                if (socket && oldName !== newName) {
                    socket.emit('updateUserName', {
                        oldName: oldName,
                        newName: newName,
                        icon: playerIcon
                    });
                    console.log(`ğŸ”„ ì„œë²„ì— ì´ë¦„ ë³€ê²½ ì•Œë¦¼: ${oldName} -> ${newName}`);
                }
                
                updatePlayerName();
                showNameSaveSuccess();
                showToast('ì´ë¦„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success', 2000);
            } else {
                showToast('ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'warning', 3000);
            }
        });
        
        // ì´ë¦„ ì €ì¥ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateNameSaveStatus() {
            const currentName = localStorage.getItem('playerName') || '';
            const inputName = playerNameInput.value.trim();
            const nameSaveStatus = DOM.get('name-save-status');
            
            if (inputName === currentName && inputName !== '') {
                saveNameBtn.disabled = true;
                saveNameBtn.style.opacity = '0.5';
                saveNameBtn.style.cursor = 'not-allowed';
                if (nameSaveStatus) {
                    nameSaveStatus.classList.remove('hidden');
                }
            } else {
                saveNameBtn.disabled = false;
                saveNameBtn.style.opacity = '1';
                saveNameBtn.style.cursor = 'pointer';
                if (nameSaveStatus) {
                    nameSaveStatus.classList.add('hidden');
                }
            }
        }
        
        // ì•„ì´ì½˜ ê´€ë ¨ ë³€ìˆ˜ë“¤
        // ìœ ì € ID ê´€ë¦¬ í•¨ìˆ˜
        function getOrCreateUserId() {
            let userId = localStorage.getItem('userId');
            if (!userId) {
                userId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('userId', userId);
                console.log(`ğŸ†” ìƒˆë¡œìš´ ìœ ì € ID ìƒì„±: ${userId}`);
            }
            return userId;
        }
        
                // ì´ë¦„ê³¼ ì•„ì´ì½˜ì„ í•¨ê»˜ ê°€ì ¸ì˜¤ê¸°
        function getPlayerDisplayName() {
            try {
                // isLoggedInì´ ì •ì˜ë˜ì§€ ì•Šì•˜ê±°ë‚˜ falseì¸ ê²½ìš° ê²ŒìŠ¤íŠ¸ ëª¨ë“œë¡œ ì²˜ë¦¬
                if (typeof isLoggedIn !== 'undefined' && isLoggedIn && currentUserData) {
                    // ë¡œê·¸ì¸í•œ ê³„ì •: ì„œë²„ì˜ ì•„ì´ì½˜ê³¼ ë‹‰ë„¤ì„ ì‚¬ìš©
                    const playerIcon = currentUserData.icon || localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                    return `${playerIcon} ${currentUserData.nickname}`;
                } else {
                    // ê²ŒìŠ¤íŠ¸ ëª¨ë“œ: 'ì§€ë‚˜ê°€ëŠ” ë§ˆë²•ì‚¬' ê³ ì •
                    const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                    return `${playerIcon} ì§€ë‚˜ê°€ëŠ” ë§ˆë²•ì‚¬`;
                }
            } catch (error) {
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê²ŒìŠ¤íŠ¸ ëª¨ë“œë¡œ ì²˜ë¦¬
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                return `${playerIcon} ì§€ë‚˜ê°€ëŠ” ë§ˆë²•ì‚¬`;
            }
        }
        
        // ì´ë¦„ ì €ì¥ ì„±ê³µ í‘œì‹œ
        function showNameSaveSuccess() {
            const nameSaveStatus = DOM.get('name-save-status');
            if (nameSaveStatus) {
                nameSaveStatus.classList.remove('hidden');
                setTimeout(() => {
                    nameSaveStatus.classList.add('hidden');
                }, 2000);
            }
        }

        // í´ë¦­ ì‹œ í™•ì¸ íŒì—… í‘œì‹œ
        usedStonesPile.addEventListener('click', () => {
            playCardSound();
            showCardListModal('ì‚¬ìš©í•œ ì£¼ë¬¸ ëª©ë¡', state.usedStones);
        });
        
        secretStonesPile.addEventListener('click', () => {
            playCardSound();
            showCombinedSecretStonesModal();
        });

        // ë””ë²„ê·¸ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('debug-show-state').addEventListener('click', showDebugInfo);
        DOM.get('debug-show-player-hand').addEventListener('click', showPlayerHand);
        DOM.get('debug-show-ai-hand').addEventListener('click', showAIHand);
        DOM.get('debug-reset-game').addEventListener('click', resetGame);
        DOM.get('debug-player-win').addEventListener('click', () => {
            state.players[1].health = 0;
            checkGameOver();
        });
        DOM.get('debug-ai-win').addEventListener('click', () => {
            state.players[0].health = 0;
            checkGameOver();
        });
        DOM.get('debug-add-player-health').addEventListener('click', () => {
            if (state.players[0].health < 5) state.players[0].health++;
            render();
        });
        DOM.get('debug-add-ai-health').addEventListener('click', () => {
            if (state.players[1].health < 5) state.players[1].health++;
            render();
        });

        // ëª¨ë°”ì¼ ìµœì í™” í•¨ìˆ˜ë“¤
        function isMobile() {
            return window.innerWidth <= 768;
        }
        
        // í™”ë©´ í¬ê¸° ë³€ê²½ ê°ì§€ ë° ì£¼ë¬¸ ë²„íŠ¼ ì¬ìƒì„±
        function handleResize() {
            if (state && state.gameStarted) {
                createSpellButtons();
            }
        }
        
        // ëª¨ë°”ì¼ì—ì„œ ì»´íŒ©íŠ¸ ëª¨ë“œ í† ê¸€
        function toggleCompactMode() {
            const gameScreen = DOM.get('game-screen');
            gameScreen.classList.toggle('compact-mode');
            console.log('ğŸ“± ì»´íŒ©íŠ¸ ëª¨ë“œ í† ê¸€');
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        window.addEventListener('resize', handleResize);
        
        // localStorageì˜ ìŠ¹ë¦¬ì˜ ì¦í‘œ ë°ì´í„°ë¥¼ ì„œë²„ë¡œ ì „ì†¡
        const syncLocalDataToServer = () => {
            if (socket && socket.connected) {
                const playerName = localStorage.getItem('playerName') || 'Player';
                const playerIcon = localStorage.getItem('playerIcon') || 'ğŸ‘¤';
                const aiTrophies = parseInt(localStorage.getItem('aiTrophies')) || 0;
                const multiplayerTrophies = parseInt(localStorage.getItem('multiplayerTrophies')) || 0;
                
                console.log(`ğŸ“Š localStorage ë°ì´í„° ì„œë²„ ë™ê¸°í™”: ${playerName} (AI: ${aiTrophies}ì , ë©€í‹°: ${multiplayerTrophies}ì )`);
                
                // AI ë­í‚¹ ì—…ë°ì´íŠ¸
                if (aiTrophies > 0) {
                    socket.emit('updateRanking', {
                        category: 'mock',
                        playerName: playerName,
                        score: aiTrophies,
                        icon: playerIcon
                    });
                }
                
                // ë©€í‹°í”Œë ˆì´ì–´ ë­í‚¹ ì—…ë°ì´íŠ¸
                if (multiplayerTrophies > 0) {
                    socket.emit('updateRanking', {
                        category: 'formal',
                        playerName: playerName,
                        score: multiplayerTrophies,
                        icon: playerIcon
                    });
                }
            }
        };
        
        // ê³„ì • ì‹œìŠ¤í…œ ë³€ìˆ˜ë“¤
        let currentSessionId = null;
        let currentUserData = null;
        let isLoggedIn = false;

        // ê³„ì • ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        function initializeAccountSystem() {
            // ì €ì¥ëœ ì„¸ì…˜ í™•ì¸
            const savedSessionId = localStorage.getItem('sessionId');
            if (savedSessionId) {
                verifySession(savedSessionId);
            }
            
            // UI ì—…ë°ì´íŠ¸
            updateAccountUI();
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
            setupAccountEventListeners();
        }

        // ì„¸ì…˜ í™•ì¸
        async function verifySession(sessionId) {
            try {
                const response = await fetch('/api/verify-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sessionId })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentSessionId = sessionId;
                    currentUserData = data.userData;
                    isLoggedIn = true;
                    
                    // ì„œë²„ ì‘ë‹µ í™•ì¸
                    console.log('ğŸ” ì„œë²„ ì‘ë‹µ userData:', data.userData);
                    
                    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                    localStorage.setItem('sessionId', sessionId);
                    localStorage.setItem('userData', JSON.stringify(data.userData));
                    
                    // UI ì—…ë°ì´íŠ¸
                    updateAccountUI();
                    updateTrophyDisplay();
                    
                    console.log(`ğŸ” ì„¸ì…˜ í™•ì¸ ì„±ê³µ: ${currentUserData.nickname}`);
                } else {
                    // ì„¸ì…˜ì´ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì‚­ì œ
                    localStorage.removeItem('sessionId');
                    localStorage.removeItem('userData');
                    currentSessionId = null;
                    currentUserData = null;
                    isLoggedIn = false;
                    updateAccountUI();
                }
            } catch (error) {
                console.error('âŒ ì„¸ì…˜ í™•ì¸ ì˜¤ë¥˜:', error);
                localStorage.removeItem('sessionId');
                localStorage.removeItem('userData');
                currentSessionId = null;
                currentUserData = null;
                isLoggedIn = false;
                updateAccountUI();
            }
        }

        // ë¡œê·¸ì¸ í•¨ìˆ˜
        async function login(username, password) {
            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentSessionId = data.sessionId;
                    currentUserData = data.userData;
                    isLoggedIn = true;
                    
                    // ì„œë²„ ì‘ë‹µ í™•ì¸
                    console.log('ğŸ” ì„œë²„ ì‘ë‹µ userData:', data.userData);
                    
                    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                    localStorage.setItem('sessionId', data.sessionId);
                    localStorage.setItem('userData', JSON.stringify(data.userData));
                    
                    // UI ì—…ë°ì´íŠ¸
                    updateAccountUI();
                    updateTrophyDisplay();
                    
                    console.log(`ğŸ” ë¡œê·¸ì¸ ì„±ê³µ: ${currentUserData.nickname}`);
                    return { success: true };
                } else {
                    return { success: false, error: data.error };
                }
            } catch (error) {
                console.error('âŒ ë¡œê·¸ì¸ ì˜¤ë¥˜:', error);
                return { success: false, error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' };
            }
        }

        // íšŒì›ê°€ì… í•¨ìˆ˜
        async function register(username, password, nickname) {
            try {
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password, nickname })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentSessionId = data.sessionId;
                    currentUserData = data.userData;
                    isLoggedIn = true;
                    
                    // ì„œë²„ ì‘ë‹µ í™•ì¸
                    console.log('ğŸ” ì„œë²„ ì‘ë‹µ userData:', data.userData);
                    
                    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                    localStorage.setItem('sessionId', data.sessionId);
                    localStorage.setItem('userData', JSON.stringify(data.userData));
                    
                    // UI ì—…ë°ì´íŠ¸
                    updateAccountUI();
                    updateTrophyDisplay();
                    
                    console.log(` íšŒì›ê°€ì… ì„±ê³µ: ${currentUserData.nickname}`);
                    return { success: true };
                } else {
                    return { success: false, error: data.error };
                }
            } catch (error) {
                console.error('âŒ íšŒì›ê°€ì… ì˜¤ë¥˜:', error);
                return { success: false, error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' };
            }
        }

        // ë¡œê·¸ì•„ì›ƒ í•¨ìˆ˜
        function logout() {
            currentSessionId = null;
            currentUserData = null;
            isLoggedIn = false;
            
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ê³„ì • ì •ë³´ ì‚­ì œ
            localStorage.removeItem('sessionId');
            localStorage.removeItem('userData');
            
            // UI ì—…ë°ì´íŠ¸
            updateAccountUI();
            updateTrophyDisplay();
            
            console.log('ğŸ” ë¡œê·¸ì•„ì›ƒë¨');
            showToast('ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤.', 'info', 2000);
        }

        // UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
        function updateAccountUI() {
            const guestDisplay = DOM.get('guest-mode-display');
            const accountDisplay = DOM.get('account-mode-display');
            const guestNameInput = DOM.get('guest-name-input');
            const accountStatus = DOM.get('account-status');
            const nameInput = DOM.get('player-name-input');
            const saveBtn = DOM.get('save-name-btn');
            const profileBtn = DOM.get('profile-btn');
            const trophyDisplay = DOM.get('trophy-display');
            
            if (isLoggedIn && currentUserData) {
                // ë¡œê·¸ì¸ ìƒíƒœ
                guestDisplay.classList.add('hidden');
                accountDisplay.classList.remove('hidden');
                guestNameInput.classList.add('hidden');
                accountStatus.classList.remove('hidden');
                
                // ê³„ì • ì •ë³´ í‘œì‹œ
                DOM.get('account-nickname').textContent = currentUserData.nickname;
                
                // ì„œë²„ì˜ ì•„ì´ì½˜ í‘œì‹œ
                const accountIcon = DOM.get('account-mode-display').querySelector('.text-xl');
                if (accountIcon && currentUserData) {
                    console.log('ğŸ” ì•„ì´ì½˜ ì—…ë°ì´íŠ¸:', currentUserData.icon || 'ğŸ‘¤');
                    console.log('ğŸ” ì „ì²´ userData:', currentUserData);
                    accountIcon.textContent = currentUserData.icon || 'ğŸ‘¤';
                }
                
                // ì´ë¦„ ì…ë ¥ ë¹„í™œì„±í™”
                nameInput.disabled = true;
                nameInput.style.opacity = '0.6';
                saveBtn.style.display = 'none';
                
                // ë‚´ ì •ë³´ ë²„íŠ¼ê³¼ íŠ¸ë¡œí”¼ í‘œì‹œ (ë¡œê·¸ì¸í•œ ìœ ì €ë§Œ)
                profileBtn.classList.remove('hidden');
                trophyDisplay.classList.remove('hidden');
                
                // ë­í‚¹ ë²„íŠ¼ì€ í•­ìƒ í‘œì‹œ (ê²ŒìŠ¤íŠ¸ë„ ë³¼ ìˆ˜ ìˆìŒ)
                DOM.get('ranking-btn').classList.remove('hidden');
                
            } else {
                // ê²ŒìŠ¤íŠ¸ ìƒíƒœ
                guestDisplay.classList.remove('hidden');
                accountDisplay.classList.add('hidden');
                guestNameInput.classList.remove('hidden');
                accountStatus.classList.add('hidden');
                
                // ê²ŒìŠ¤íŠ¸ ë‹‰ë„¤ì„ì„ 'ì§€ë‚˜ê°€ëŠ” ë§ˆë²•ì‚¬'ë¡œ ê³ ì •
                DOM.get('account-nickname').textContent = 'ì§€ë‚˜ê°€ëŠ” ë§ˆë²•ì‚¬';
                
                // ì´ë¦„ ì…ë ¥ ë¹„í™œì„±í™” (ê²ŒìŠ¤íŠ¸ëŠ” ë‹‰ë„¤ì„ ë³€ê²½ ë¶ˆê°€)
                nameInput.disabled = true;
                nameInput.style.opacity = '0.6';
                nameInput.value = 'ì§€ë‚˜ê°€ëŠ” ë§ˆë²•ì‚¬';
                saveBtn.style.display = 'none';
                
                // ë‚´ ì •ë³´ ë²„íŠ¼ê³¼ íŠ¸ë¡œí”¼ ìˆ¨ê¹€ (ê²ŒìŠ¤íŠ¸ëŠ” ë³¼ ìˆ˜ ì—†ìŒ)
                profileBtn.classList.add('hidden');
                trophyDisplay.classList.add('hidden');
                
                // ë­í‚¹ ë²„íŠ¼ì€ ê²ŒìŠ¤íŠ¸ë„ ë³¼ ìˆ˜ ìˆìŒ
                DOM.get('ranking-btn').classList.remove('hidden');
            }
        }

        function updateTrophyDisplay() {
            const aiTrophyCount = DOM.get('ai-trophy-count');
            const multiplayerTrophyCount = DOM.get('multiplayer-trophy-count');
            
            if (isLoggedIn && currentUserData) {
                aiTrophyCount.textContent = currentUserData.trophies.mock || 0;
                multiplayerTrophyCount.textContent = currentUserData.trophies.formal || 0;
            } else {
                // ê²ŒìŠ¤íŠ¸ ëª¨ë“œ: 0ìœ¼ë¡œ í‘œì‹œ
                aiTrophyCount.textContent = '0';
                multiplayerTrophyCount.textContent = '0';
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupAccountEventListeners() {
            // ë¡œê·¸ì¸ ë²„íŠ¼
            DOM.get('login-btn').addEventListener('click', () => {
                showAuthModal('login');
            });
            
            // ë¡œê·¸ì•„ì›ƒ ë²„íŠ¼
            DOM.get('logout-btn').addEventListener('click', logout);
            
            // ì¸ì¦ ëª¨ë‹¬ ì´ë²¤íŠ¸
            setupAuthModalEvents();
            
            // ê²Œì„ ë²„íŠ¼ ì´ë²¤íŠ¸ ìˆ˜ì • (ê³„ì • ì‹œìŠ¤í…œê³¼ ì—°ë™)
            // ì •ì‹ ê²°íˆ¬ ë²„íŠ¼ì€ ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬ë¨
        }

        // ì¸ì¦ ëª¨ë‹¬ í‘œì‹œ
        function showAuthModal(mode = 'login') {
            const modal = DOM.get('auth-modal');
            const loginForm = DOM.get('login-form');
            const registerForm = DOM.get('register-form');
            const title = DOM.get('auth-title');
            const subtitle = DOM.get('auth-subtitle');
            
            if (mode === 'login') {
                title.textContent = 'ë¡œê·¸ì¸';
                subtitle.textContent = 'ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì—¬ ì ìˆ˜ë¥¼ ì €ì¥í•˜ì„¸ìš”';
                loginForm.classList.remove('hidden');
                registerForm.classList.add('hidden');
            } else {
                title.textContent = 'íšŒì›ê°€ì…';
                subtitle.textContent = 'ìƒˆ ê³„ì •ì„ ë§Œë“¤ì–´ ì ìˆ˜ë¥¼ ì €ì¥í•˜ì„¸ìš”';
                loginForm.classList.add('hidden');
                registerForm.classList.remove('hidden');
            }
            
            modal.classList.remove('hidden');
        }

        // ì¸ì¦ ëª¨ë‹¬ ì´ë²¤íŠ¸ ì„¤ì •
        function setupAuthModalEvents() {
            const modal = DOM.get('auth-modal');
            const loginForm = DOM.get('login-form');
            const registerForm = DOM.get('register-form');
            const switchToRegister = DOM.get('switch-to-register');
            const switchToLogin = DOM.get('switch-to-login');
            const closeBtn = DOM.get('close-auth-btn');
            
            // í¼ ì „í™˜
            switchToRegister.addEventListener('click', () => {
                showAuthModal('register');
            });
            
            switchToLogin.addEventListener('click', () => {
                showAuthModal('login');
            });
            
            // ë¡œê·¸ì¸ í¼ ì œì¶œ
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const username = DOM.get('login-username').value;
                const password = DOM.get('login-password').value;
                
                const result = await login(username, password);
                
                if (result.success) {
                    modal.classList.add('hidden');
                    showToast('ë¡œê·¸ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success', 2000);
                } else {
                    showToast(result.error, 'error', 3000);
                }
            });
            
            // íšŒì›ê°€ì… í¼ ì œì¶œ
            registerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const username = DOM.get('register-username').value;
                const password = DOM.get('register-password').value;
                const nickname = DOM.get('register-nickname').value;
                
                const result = await register(username, password, nickname);
                
                if (result.success) {
                    modal.classList.add('hidden');
                    showToast('íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success', 2000);
                } else {
                    showToast(result.error, 'error', 3000);
                }
            });
            
            // ë‹«ê¸° ë²„íŠ¼
            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
            });
        }

        // ê²Œì„ ê²°ê³¼ ì—…ë°ì´íŠ¸
        async function updateGameResult(gameType, isWin, opponentNickname = null) {
            if (!isLoggedIn || !currentSessionId) {
                console.log('ê²ŒìŠ¤íŠ¸ ëª¨ë“œ: ì ìˆ˜ ì €ì¥í•˜ì§€ ì•ŠìŒ');
                return;
            }
            
            try {
                const response = await fetch('/api/update-trophies', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionId: currentSessionId,
                        category: gameType,
                        change: isWin ? 2 : -1
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentUserData.trophies = data.trophies;
                    updateTrophyDisplay();
                    
                    console.log(` ê²Œì„ ê²°ê³¼ ì—…ë°ì´íŠ¸: ${gameType} ${isWin ? 'ìŠ¹ë¦¬' : 'íŒ¨ë°°'}`);
                    
                    // ë­í‚¹ ëª¨ë‹¬ì´ ì—´ë ¤ìˆë‹¤ë©´ ë­í‚¹ ë°ì´í„° ìƒˆë¡œê³ ì¹¨
                    const rankingModal = document.querySelector('#ranking-modal');
                    if (rankingModal && !rankingModal.classList.contains('hidden')) {
                        console.log('ğŸ”„ ê²Œì„ ê²°ê³¼ ë°˜ì˜í•˜ì—¬ ë­í‚¹ ìƒˆë¡œê³ ì¹¨');
                        loadRankingData();
                    }
                }
            } catch (error) {
                console.error('âŒ ê²Œì„ ê²°ê³¼ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ê¸°ë³¸ ì´ë¦„ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ í˜ì´ì§€ ë¡œë“œ - ê¸°ë³¸ ì´ë¦„ ì´ˆê¸°í™”');
            DOM.init(); // DOM ìºì‹œ ì´ˆê¸°í™”
            TrophySystem.init(); // ì¦í‘œ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            getOrCreateUserId(); // ìœ ì € ID ì´ˆê¸°í™”
            initializePlayerName();
            
            // ê³„ì • ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¶”ê°€
            initializeAccountSystem();
            
            // AudioContext ì´ˆê¸°í™” ì‹œë„
            console.log('ğŸ”Š AudioContext ìƒíƒœ:', audioContext.state);
            if (audioContext.state === 'suspended') {
                console.log('ğŸ”Š AudioContext ì¼ì‹œ ì¤‘ë‹¨ ìƒíƒœ - ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ëŒ€ê¸° ì¤‘');
            }
            
            // ì†Œì¼“ ì—°ê²° ì´ˆê¸°í™” (ë­í‚¹ ê¸°ëŠ¥ì„ ìœ„í•´)
            console.log('ğŸ”Œ í˜ì´ì§€ ë¡œë“œ ì‹œ ì†Œì¼“ ì—°ê²° ì´ˆê¸°í™”');
            initializeSocketIO();
            
            // ì†Œì¼“ ì—°ê²° í›„ localStorage ë°ì´í„° ë™ê¸°í™”
            setTimeout(() => {
                if (socket && socket.connected) {
                    syncLocalDataToServer();
                } else {
                    // ì†Œì¼“ ì—°ê²° ëŒ€ê¸° í›„ ë‹¤ì‹œ ì‹œë„
                    socket.on('connect', () => {
                        syncLocalDataToServer();
                    });
                }
            }, 1000);
        });

    </script>
</body>
</html>
 