<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cast Me If You Can</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Pretendard:wght@300;400;500;600;700&family=MedievalSharp:wght@400&family=Uncial+Antiqua&family=UnifrakturMaguntia&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Pretendard', sans-serif;
            background: 
                linear-gradient(135deg, #ffffff 0%, #f8f9fa 50%, #e9ecef 100%),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 20px,
                    rgba(0, 0, 0, 0.03) 20px,
                    rgba(0, 0, 0, 0.03) 40px
                );
            background-size: 100% 100%, 40px 40px;
            background-position: 0 0, 0 0;
            background-repeat: no-repeat, repeat;
            color: #333333;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        .font-cinzel {
            font-family: 'Cinzel Decorative', cursive;
        }
        .font-orbitron {
            font-family: 'Orbitron', monospace;
        }
        .font-exo {
            font-family: 'Pretendard', sans-serif;
        }
        .game-title {
            font-family: 'UnifrakturMaguntia', cursive;
            font-weight: 900;
            color: #333333;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            letter-spacing: 2px;
        }
        .card {
            width: 70px;
            height: 100px;
            border: 2px solid #333333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            user-select: none;
            position: relative;
            overflow: hidden;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .card-back {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            color: #6c757d;
            border: 2px solid #dee2e6;
        }
        .card-back:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .card-front {
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
            color: #333333;
            border: 2px solid #333333;
        }
        .card-front:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .card-pile {
             cursor: help;
             transition: transform 0.3s ease;
        }
        .card-pile:hover {
            transform: scale(1.05);
        }
        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            transition: all 0.3s ease;
            border: none;
            position: relative;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }
        
        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.4);
        }
        .btn-primary:disabled {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        .btn-secondary {
            background: transparent;
            color: #6c757d;
            border: 2px solid #6c757d;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            font-weight: 600;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: rgba(108, 117, 125, 0.1);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
        }
        
        .btn-secondary:disabled {
            background: transparent;
            color: #adb5bd;
            border-color: #adb5bd;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        .memo-button {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #6c757d;
            border: 1px solid #dee2e6;
            transition: all 0.3s ease;
            font-family: 'Pretendard', sans-serif;
            font-weight: 500;
            font-size: 0.6rem;
            min-height: 24px;
        }
        .memo-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .memo-button.active {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border-color: #dc3545;
        }
        .memo-button.active:hover {
            background: linear-gradient(135deg, #c82333 0%, #bd2130 100%);
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.4);
        }
        .game-log {
            height: 150px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-family: 'Pretendard', sans-serif;
        }
        .game-log p {
            margin: 2px 0;
            padding: 3px 8px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        .game-log p:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }
        .modal-bg {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 2px solid #dee2e6;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease-out;
            font-family: 'Pretendard', sans-serif;
            color: #333333;
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        .player-area-glow {
            box-shadow: 0 0 10px 4px rgba(0, 123, 255, 0.6);
            animation: glowPulse 1.5s ease-in-out infinite;
            border: 1px solid rgba(0, 123, 255, 0.7);
            border-radius: 12px;
            position: relative;
        }
        .player-area-glow.opponent-turn {
            box-shadow: 0 0 10px 4px rgba(220, 53, 69, 0.6);
            border-color: rgba(220, 53, 69, 0.7);
            border: 1px solid rgba(220, 53, 69, 0.7);
        }
        .player-area-glow.opponent-turn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, rgba(220, 53, 69, 0.05), rgba(220, 53, 69, 0.15));
            border-radius: 14px;
            z-index: -1;
            animation: backgroundPulseRed 2s ease-in-out infinite;
        }
        .player-area-glow::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, rgba(0, 123, 255, 0.05), rgba(0, 123, 255, 0.15));
            border-radius: 14px;
            z-index: -1;
            animation: backgroundPulse 2s ease-in-out infinite;
        }
        @keyframes glowPulse {
            0%, 100% { 
                box-shadow: 0 0 10px 4px rgba(0, 123, 255, 0.6);
                border-color: rgba(0, 123, 255, 0.7);
            }
            50% { 
                box-shadow: 0 0 15px 6px rgba(0, 123, 255, 0.8);
                border-color: rgba(0, 123, 255, 0.8);
            }
        }
        .player-area-glow.opponent-turn {
            animation: glowPulseRed 1.5s ease-in-out infinite;
        }
        @keyframes glowPulseRed {
            0%, 100% { 
                box-shadow: 0 0 10px 4px rgba(220, 53, 69, 0.6);
                border-color: rgba(220, 53, 69, 0.7);
            }
            50% { 
                box-shadow: 0 0 15px 6px rgba(220, 53, 69, 0.8);
                border-color: rgba(220, 53, 69, 0.8);
            }
        }
        @keyframes backgroundPulseRed {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.02);
            }
        }
        @keyframes backgroundPulse {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.02);
            }
        }
        .health-heart {
            animation: heartBeat 1s ease-in-out infinite;
        }
        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        

        

        .spell-button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            /* ë¹„í™œì„±í™”ëœ ë²„íŠ¼ë„ í•­ìƒ ë³´ì´ë„ë¡ ì„¤ì • */
            display: block !important;
            visibility: visible !important;
        }
        .spell-button:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.4);
        }
        .spell-button:active:not(:disabled) {
            transform: translateY(-1px) scale(1.02);
        }
        .success-animation {
            animation: successGlow 0.5s ease-out;
        }
        @keyframes successGlow {
            0% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.8); }
            100% { box-shadow: 0 0 0 rgba(255, 255, 255, 0); }
        }
        .failure-animation {
            animation: failureShake 0.5s ease-out;
        }
        @keyframes failureShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .turn-indicator {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            border-radius: 50%;
            animation: turnPulse 1s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 9px;
            font-weight: bold;
            box-shadow: 0 1px 4px rgba(0, 123, 255, 0.3);
            z-index: 10;
        }
        .turn-indicator.opponent-turn {
            background: linear-gradient(135deg, #dc3545, #c82333);
            box-shadow: 0 1px 4px rgba(220, 53, 69, 0.3);
            animation: turnPulseRed 1s ease-in-out infinite;
        }
        @keyframes turnPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1;
                box-shadow: 0 1px 4px rgba(0, 123, 255, 0.3);
            }
            50% { 
                transform: scale(1.2); 
                opacity: 0.9;
                box-shadow: 0 3px 10px rgba(0, 123, 255, 0.5);
            }
        }
        .turn-indicator.opponent-turn {
            animation: turnPulseRed 1s ease-in-out infinite;
        }
        @keyframes turnPulseRed {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1;
                box-shadow: 0 1px 4px rgba(220, 53, 69, 0.3);
            }
            50% { 
                transform: scale(1.2); 
                opacity: 0.9;
                box-shadow: 0 3px 10px rgba(220, 53, 69, 0.5);
            }
        }
        .card-damage {
            position: absolute;
            color: #ffffff;
            font-weight: bold;
            font-size: 1.2rem;
            animation: damageFloat 1s ease-out forwards;
            pointer-events: none;
        }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        .card-heal {
            position: absolute;
            color: #ffffff;
            font-weight: bold;
            font-size: 1.2rem;
            animation: healFloat 1s ease-out forwards;
            pointer-events: none;
        }
        

        @keyframes healFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        
        /* ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #refresh-game-btn {
            transition: all 0.3s ease;
            opacity: 0.8;
        }
        #refresh-game-btn:hover {
            opacity: 1;
            transform: scale(1.02);
        }
        #refresh-game-btn:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- íƒ€ì´í‹€ í™”ë©´ -->
    <div id="title-screen" class="w-full max-w-2xl mx-auto text-center">
        <div class="mb-6">
            <img src="magic_battle.png" alt="MAGIC FLIP íƒ€ì´í‹€" class="mx-auto max-w-xs md:max-w-sm h-auto rounded-lg">
        </div>
        <h1 class="text-5xl game-title mb-8">Cast Me If You Can</h1>
        <div class="bg-black bg-opacity-10 p-6 rounded-lg text-left mb-8">
            <h3 class="text-xl font-bold mb-4 text-center font-exo flex items-center justify-center"><span>ğŸ“</span><span class="ml-1">ê²Œì„ ê·œì¹™</span></h3>
            <ul class="list-disc list-inside space-y-1">
                <li>ìƒëŒ€ì˜ ë§ˆë²• ì¹´ë“œë¥¼ ë³´ê³ , ë³´ì´ì§€ ì•ŠëŠ” ìì‹ ì˜ ì¹´ë“œë¥¼ ì¶”ì¸¡í•´ ì˜ì°½í•˜ì„¸ìš”.</li>
                <li>ì˜ì°½ì— ì„±ê³µí•˜ë©´ ì¶”ê°€ë¡œ ê°™ê±°ë‚˜, ë” ë†’ì€ ìˆ«ìì˜ ì˜ì°½ì„ ì‹œì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                <li>ì˜ì°½ì— ì‹¤íŒ¨í•˜ë©´ ì²´ë ¥ì´ 1 ê°ì†Œí•˜ê³  í„´ì´ ì¢…ë£Œë©ë‹ˆë‹¤.</li>
                <li>ìƒëŒ€ì˜ ì²´ë ¥ì„ 0ìœ¼ë¡œ ë§Œë“¤ê±°ë‚˜, ë‚´ ë§ˆë²• ì¹´ë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤!</li>
            </ul>
        </div>
        <!-- ì´ë¦„ ì…ë ¥ ì˜ì—­ -->
        <div class="bg-black bg-opacity-10 p-4 rounded-lg mb-6">
            <div class="flex items-center justify-between mb-2">
                <label class="text-sm font-bold text-white">ì§€íŒ¡ì´ ì£¼ì¸ ì´ë¦„</label>
                <span id="name-save-status" class="text-xs text-green-400 hidden">âœ“ ì €ì¥ë¨</span>
            </div>
            <div class="flex space-x-2">
                <input type="text" id="player-name-input" 
                       class="flex-1 px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white focus:outline-none focus:border-blue-400"
                       placeholder="ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10" value="">
                <button id="save-name-btn" class="px-4 py-2 rounded-lg font-bold btn-primary text-sm whitespace-nowrap">ì €ì¥</button>
            </div>
        </div>
        
        <div class="space-y-4">
            <button id="ai-battle-btn" class="w-full py-4 rounded-lg font-bold text-xl btn-primary border-2 border-white">ëª¨ì˜ ê²°íˆ¬ <span class="text-sm font-normal">(vs í—ˆìˆ˜ì•„ë¹„)</span></button>
            <button id="multiplayer-btn" class="w-full py-4 rounded-lg font-bold text-xl bg-red-600 hover:bg-red-700 text-white transition-all duration-300 hover:transform hover:-translate-y-0.5 hover:shadow-lg" style="box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);">ì •ì‹ ê²°íˆ¬ <span class="text-sm font-normal">(vs ë‹¤ë¥¸ ë§ˆë²•ì‚¬)</span></button>
            
            <!-- ìŠ¹ë¦¬ì˜ ì¦í‘œ í‘œì‹œ ì˜ì—­ -->
            <div class="flex justify-center items-center space-x-4 mb-4">
                <div class="text-2xl">ğŸ…</div>
                <div class="flex items-center space-x-2">
                    <div class="text-sm font-bold text-yellow-300">ëª¨ì˜ ê²°íˆ¬</div>
                    <div id="ai-trophy-count" class="text-lg font-bold text-yellow-200">0</div>
                </div>
                <div class="text-gray-400">|</div>
                <div class="flex items-center space-x-2">
                    <div class="text-sm font-bold text-red-300">ì •ì‹ ê²°íˆ¬</div>
                    <div id="multiplayer-trophy-count" class="text-lg font-bold text-red-200">0</div>
                </div>
            </div>
            
            <div class="flex space-x-2">
                <button id="profile-btn" class="w-1/2 py-2 rounded-lg font-bold text-base btn-secondary">ğŸ‘¤ ë§ˆë²• ì´ë ¥ì„œ</button>
                <button id="ranking-btn" class="w-1/2 py-2 rounded-lg font-bold text-base btn-secondary">ğŸ† ì˜¤ëŠ˜ì˜ ë§ˆë²•ì™•</button>
            </div>
        </div>
        
        <!-- AI ë‚œì´ë„ ì„ íƒ ëª¨ë‹¬ -->
        <div id="ai-difficulty-modal" class="fixed inset-0 flex items-center justify-center hidden modal-bg z-50">
            <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                <div class="text-center">
                                         <div class="text-4xl mb-4">ğŸ­</div>
                                         <h3 class="text-xl font-bold mb-4">ë‚œì´ë„ ì„ íƒ</h3>
                     <p class="text-gray-300 mb-6">í—ˆìˆ˜ì•„ë¹„ì—ê²Œë„ ìì¡´ì‹¬ì€ ìˆìŠµë‹ˆë‹¤.<br>ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
                    <div class="space-y-3">
                        <button id="easy-ai-btn" class="w-full py-3 rounded-lg font-bold btn-primary text-green-400 hover:text-green-300">ì…ë¬¸ìš©</button>
                        <button id="normal-ai-btn" class="w-full py-3 rounded-lg font-bold btn-primary text-yellow-400 hover:text-yellow-300">ì—°ìŠµìš©</button>
                        <button id="hard-ai-btn" class="w-full py-3 rounded-lg font-bold btn-primary text-red-400 hover:text-red-300">ê³ ìˆ˜ìš©</button>
                        <button id="cancel-difficulty-btn" class="w-full py-2 rounded-lg font-bold btn-secondary">ì·¨ì†Œ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ê²Œì„ í™”ë©´ -->
    <div id="game-screen" class="w-full max-w-4xl mx-auto space-y-2 hidden">
        <!-- ìƒëŒ€ ì˜ì—­ (í•­ìƒ ìƒë‹¨) -->
        <div id="opponent-area" class="p-4 border-2 border-red-400 rounded-lg transition-all duration-500 relative">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-red-300">ìƒëŒ€</h2>
                <div id="opponent-health" class="flex items-center space-x-1 text-2xl"></div>
            </div>
            <div id="opponent-hand" class="flex justify-center space-x-2"></div>
            <div id="opponent-turn-indicator" class="turn-indicator hidden">ìƒëŒ€ í„´!</div>
        </div>

        <!-- ì¤‘ì•™ ì˜ì—­ -->
        <div class="flex justify-between items-center p-4 h-48">
            <div id="secret-stones-pile" class="flex flex-col items-center space-y-1 card-pile">
                <div class="card card-back flex flex-col items-center justify-center">
                    <div class="text-2xl mb-1">â“</div>
                    <div class="text-sm font-bold">?</div>
                </div>
                <div class="font-bold">ë¹„ë°€ ì£¼ë¬¸</div>
                <div id="secret-stones-count" class="text-lg"></div>
            </div>
            <div class="flex-grow mx-4">
                <div id="game-log" class="game-log p-2 rounded-lg overflow-y-auto flex flex-col-reverse"></div>
            </div>
            <div id="used-stones-pile" class="flex flex-col items-center space-y-1 card-pile">
                <div class="card card-back flex flex-col items-center justify-center">
                    <div class="text-2xl mb-1">ğŸ—‘ï¸</div>
                    <div class="text-sm font-bold">X</div>
                </div>
                <div class="font-bold">ì‚¬ìš©í•œ ì£¼ë¬¸</div>
                <div id="used-stones-count" class="text-lg"></div>
            </div>
        </div>

        <!-- ë‚´ ì˜ì—­ (í•­ìƒ í•˜ë‹¨) -->
        <div id="my-area" class="p-4 border-2 border-blue-400 rounded-lg transition-all duration-500 relative">
            <div id="my-hand" class="flex justify-center space-x-2 mb-4"></div>
            <div class="flex justify-between items-center">
                <div id="my-health" class="flex items-center space-x-1 text-2xl"></div>
                <h2 id="my-title" class="text-xl font-bold text-blue-300">ë‚˜</h2>
            </div>
            <div id="my-turn-indicator" class="turn-indicator hidden">ë‚´ í„´!</div>
        </div>

        <!-- ì»¨íŠ¸ë¡¤ ì˜ì—­ -->
        <div class="p-4 bg-black bg-opacity-20 rounded-lg">
            <div id="spell-buttons" class="relative mb-4">
                <!-- ê²Œì´ì§€ë°” ë°°ê²½ -->
                <div class="absolute inset-0 bg-gray-800 bg-opacity-30 rounded-lg border border-gray-600"></div>
                
                <!-- ê²Œì´ì§€ë°” -->
                <div id="turn-gauge" class="absolute inset-0 rounded-lg overflow-hidden">
                    <div id="blue-gauge" class="absolute left-0 top-0 h-full bg-blue-500 bg-opacity-30 transition-all duration-50 ease-out" style="width: 0%"></div>
                    <div id="red-gauge" class="absolute right-0 top-0 h-full bg-red-500 bg-opacity-30 transition-all duration-50 ease-out" style="width: 0%"></div>
                </div>
                
                <!-- ì˜ì°½ ë²„íŠ¼ë“¤ -->
                <div id="spell-buttons-container" class="relative grid grid-cols-6 gap-2 p-4"></div>
            </div>
            <div id="memo-buttons" class="grid grid-cols-6 gap-2 mb-4"></div>
            <button id="end-turn-btn" class="w-full py-3 rounded-lg font-bold text-lg btn-primary">í„´ ì¢…ë£Œ</button>
        </div>
        
        <!-- í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ -->
        <div class="flex justify-between items-center p-2">
            <button id="surrender-btn" class="px-6 py-2 rounded-lg font-bold btn-secondary text-sm whitespace-nowrap">ë„ë§</button>
            
            <div class="relative">
                <button id="help-btn" class="px-6 py-2 rounded-lg font-bold btn-secondary text-sm whitespace-nowrap min-w-[100px]" 
                        onmousedown="showHelpTooltip()" onmouseup="hideHelpTooltip()" onmouseleave="hideHelpTooltip()"
                        ontouchstart="showHelpTooltip()" ontouchend="hideHelpTooltip()">ğŸ“ ê²Œì„ ê·œì¹™</button>
                <div id="help-tooltip" class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 p-4 bg-white border border-gray-200 rounded-lg text-sm w-80 hidden z-50 shadow-lg">
                    <div class="text-center font-bold mb-3 text-base text-gray-800">ê²Œì„ ê·œì¹™</div>
                    <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                        <li>ìƒëŒ€ì˜ ë§ˆë²• ì£¼ë¬¸ì„ ë³´ê³ , ë³´ì´ì§€ ì•ŠëŠ” ìì‹ ì˜ ì£¼ë¬¸ì„ ì¶”ì¸¡í•´ ì˜ì°½í•˜ì„¸ìš”.</li>
                        <li>ì˜ì°½ì— ì„±ê³µí•˜ë©´ ì¶”ê°€ë¡œ ê°™ê±°ë‚˜, ë” ë†’ì€ ìˆ«ìì˜ ì˜ì°½ì„ ì‹œì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li>ì˜ì°½ì— ì‹¤íŒ¨í•˜ë©´ ì²´ë ¥ì´ 1 ê°ì†Œí•˜ê³  í„´ì´ ì¢…ë£Œë©ë‹ˆë‹¤.</li>
                        <li>ìƒëŒ€ì˜ ì²´ë ¥ì„ 0ìœ¼ë¡œ ë§Œë“¤ê±°ë‚˜, ë‚´ ë§ˆë²• ì£¼ë¬¸ì„ ëª¨ë‘ ì‚¬ìš©í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤!</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- ë””ë²„ê·¸ íŒ¨ë„ (ê°œë°œììš©) -->
        <div id="debug-panel" class="p-4 bg-red-900 bg-opacity-20 rounded-lg border border-red-400 hidden">
            <h3 class="text-lg font-bold text-red-300 mb-2">ğŸ”§ ë””ë²„ê·¸ íŒ¨ë„</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                <button id="debug-show-state" class="px-2 py-1 bg-blue-600 rounded text-white">ê²Œì„ ìƒíƒœ ì¶œë ¥</button>
                <button id="debug-show-player-hand" class="px-2 py-1 bg-green-600 rounded text-white">í”Œë ˆì´ì–´ ì†íŒ¨ ë³´ê¸°</button>
                <button id="debug-show-ai-hand" class="px-2 py-1 bg-yellow-600 rounded text-white">AI ì†íŒ¨ ë³´ê¸°</button>
                <button id="debug-reset-game" class="px-2 py-1 bg-red-600 rounded text-white">ê²Œì„ ë¦¬ì…‹</button>
                <button id="debug-player-win" class="px-2 py-1 bg-purple-600 rounded text-white">í”Œë ˆì´ì–´ ìŠ¹ë¦¬</button>
                <button id="debug-ai-win" class="px-2 py-1 bg-orange-600 rounded text-white">AI ìŠ¹ë¦¬</button>
                <button id="debug-add-player-health" class="px-2 py-1 bg-green-600 rounded text-white">í”Œë ˆì´ì–´ ì²´ë ¥ +1</button>
                <button id="debug-add-ai-health" class="px-2 py-1 bg-yellow-600 rounded text-white">AI ì²´ë ¥ +1</button>
            </div>
            <div id="debug-info" class="mt-2 p-2 bg-black bg-opacity-30 rounded text-xs font-mono"></div>
        </div>
    </div>

    <!-- ëª¨ë‹¬ -->
    <div id="modal" class="fixed inset-0 items-center justify-center hidden modal-bg z-50">
        <div class="modal-content p-8 rounded-lg text-center max-w-lg w-full">
            <h3 id="modal-title" class="text-2xl font-bold mb-4"></h3>
            <div id="modal-body" class="mb-6"></div>
            <button id="modal-close-btn" class="px-6 py-2 rounded-lg btn-primary">í™•ì¸</button>
        </div>
    </div>
    
    <!-- í† ìŠ¤íŠ¸ ë©”ì‹œì§€ -->
    <div id="toast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
        <span id="toast-message"></span>
    </div>
    
    <!-- ë§¤ì¹­ ëª¨ë‹¬ -->
    <div id="matching-modal" class="fixed inset-0 flex items-center justify-center hidden modal-bg z-50">
        <div class="modal-content p-8 rounded-lg text-center max-w-md w-full mx-4">
            <div class="text-4xl mb-4">ğŸ”</div>
                            <h3 class="text-xl font-bold mb-4">ê²°íˆ¬ ìƒëŒ€ë¥¼ ë§¤ì¹­ ì¤‘ì…ë‹ˆë‹¤</h3>
            <div class="flex justify-center space-x-2 mb-6">
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
            </div>
            <p class="text-sm text-gray-300 mb-4" id="matching-message">ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘ì…ë‹ˆë‹¤...</p>
            <p class="text-xs text-gray-400 mb-4">ë©€í‹° í”Œë ˆì´ë¥¼ ìœ„í•œ ì„œë²„ê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <button id="cancel-matching-btn" class="px-6 py-2 rounded-lg btn-primary">ë§¤ì¹­ ì·¨ì†Œ</button>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // ì‚¬ìš´ë“œ íš¨ê³¼ (Web Audio API ì‚¬ìš©)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // ì‚¬ìš´ë“œ ì„¤ì • ê°ì²´
        const SOUNDS = {
            card: { freq: 150, dur: 0.1, type: 'square', sequence: [[200, 0.1, 'square', 50]] },
            success: { freq: 523.25, dur: 0.2, type: 'sine', sequence: [
                [659.25, 0.2, 'sine', 100], [783.99, 0.3, 'sine', 200]
            ]},
            failure: { freq: 220, dur: 0.3, type: 'sawtooth', sequence: [
                [196, 0.3, 'sawtooth', 150]
            ]},
            damage: { freq: 100, dur: 0.2, type: 'square', sequence: [
                [80, 0.2, 'square', 100], [60, 0.3, 'square', 200]
            ]},
            heal: { freq: 660, dur: 0.2, type: 'triangle', sequence: [
                [880, 0.2, 'triangle', 100], [1108.73, 0.3, 'triangle', 200]
            ]},
            gameStart: { freq: 440, dur: 0.3, type: 'sine', sequence: [
                [554.37, 0.3, 'sine', 200], [659.25, 0.4, 'sine', 400]
            ]},
            gameWin: { freq: 523.25, dur: 0.3, type: 'sine', sequence: [
                [659.25, 0.3, 'sine', 200], [783.99, 0.3, 'sine', 400], [1046.50, 0.4, 'sine', 600]
            ]},
            gameLose: { freq: 220, dur: 0.4, type: 'sawtooth', sequence: [
                [196, 0.4, 'sawtooth', 300], [174.61, 0.5, 'sawtooth', 600]
            ]}
        };
        
        function playSound(frequency, duration, type = 'sine') {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playSoundEffect(type) {
            const sound = SOUNDS[type];
            if (!sound) return;
            
            playSound(sound.freq, sound.dur, sound.type);
            
            // ì‹œí€€ìŠ¤ ì‚¬ìš´ë“œ ì¬ìƒ
            sound.sequence?.forEach(([freq, dur, type, delay]) => {
                setTimeout(() => playSound(freq, dur, type), delay);
            });
        }
        
        // ê¸°ì¡´ í•¨ìˆ˜ëª… í˜¸í™˜ì„± ìœ ì§€
        const playCardSound = () => playSoundEffect('card');
        const playSuccessSound = () => playSoundEffect('success');
        const playFailureSound = () => playSoundEffect('failure');
        const playDamageSound = () => playSoundEffect('damage');
        const playHealSound = () => playSoundEffect('heal');
        const playGameStartSound = () => playSoundEffect('gameStart');
        const playGameOverSound = (isWin) => playSoundEffect(isWin ? 'gameWin' : 'gameLose');

        // DOM ìš”ì†Œ ìºì‹œ
        const DOM = {
            elements: {},
            
            get(id) {
                if (!this.elements[id]) {
                    this.elements[id] = document.getElementById(id);
                }
                return this.elements[id];
            },
            
            // ìì£¼ ì‚¬ìš©ë˜ëŠ” ìš”ì†Œë“¤ ë¯¸ë¦¬ ìºì‹œ
            init() {
                const commonElements = [
                    'title-screen', 'game-screen', 'start-game-btn',
                    'my-area', 'opponent-area', 'my-health', 'opponent-health',
                    'my-hand', 'opponent-hand', 'secret-stones-pile', 'used-stones-pile',
                    'secret-stones-count', 'used-stones-count', 'game-log',
                    'spell-buttons-container', 'end-turn-btn', 'modal',
                    'modal-title', 'modal-body', 'modal-close-btn',
                    'debug-panel', 'debug-info', 'memo-buttons', 'my-title',
                    'help-tooltip', 'matching-modal', 'matching-message',
                    'ai-difficulty-modal', 'toast', 'toast-message',
                    'player-name-input', 'save-name-btn', 'name-save-status',
                    'my-turn-indicator', 'opponent-turn-indicator',
                    'ai-trophy-count', 'multiplayer-trophy-count'
                ];
                
                commonElements.forEach(id => this.get(id));
            }
        };

        // DOM ìš”ì†Œ (ê¸°ì¡´ ë³€ìˆ˜ëª… í˜¸í™˜ì„± ìœ ì§€)
        const titleScreen = DOM.get('title-screen');
        const gameScreen = DOM.get('game-screen');
        const startGameBtn = DOM.get('start-game-btn');
        const myArea = DOM.get('my-area');
        const opponentArea = DOM.get('opponent-area');
        const myHealthEl = DOM.get('my-health');
        const opponentHealthEl = DOM.get('opponent-health');
        const myHandEl = DOM.get('my-hand');
        const opponentHandEl = DOM.get('opponent-hand');
        const secretStonesPile = DOM.get('secret-stones-pile');
        const usedStonesPile = DOM.get('used-stones-pile');
        const secretStonesCountEl = DOM.get('secret-stones-count');
        const usedStonesCountEl = DOM.get('used-stones-count');
        const gameLogEl = DOM.get('game-log');
        const spellButtonsContainer = DOM.get('spell-buttons-container');
        const endTurnBtn = DOM.get('end-turn-btn');
        const modal = DOM.get('modal');
        const modalTitle = DOM.get('modal-title');
        const modalBody = DOM.get('modal-body');
        const modalCloseBtn = DOM.get('modal-close-btn');
        
        // ë””ë²„ê·¸ íŒ¨ë„ ìš”ì†Œë“¤
        const debugPanel = DOM.get('debug-panel');
        const debugInfo = DOM.get('debug-info');

        let state = {};
        let previousMyHealth = 3;
        let previousOpponentHealth = 3;
        
        // í„´ íƒ€ì´ë¨¸ ê´€ë ¨ ë³€ìˆ˜
        let turnTimer = null;
        let turnTimeLeft = 30; // 30ì´ˆ
        let TURN_DURATION = 30; // ê¸°ë³¸ 30ì´ˆ (AI ë‚œì´ë„ë³„ë¡œ ë³€ê²½ë¨)
        
        // ì—°ìŠ¹ ê´€ë ¨ ë³€ìˆ˜
        let currentWinStreak = parseInt(localStorage.getItem('currentWinStreak')) || 0;
        let maxWinStreak = parseInt(localStorage.getItem('maxWinStreak')) || 0;
        
        // ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™” ìƒíƒœ
        let spellButtonsDisabled = false;
        
        // ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™” í•¨ìˆ˜
        function disableSpellButtons() {
            spellButtonsDisabled = true;
            const spellButtons = spellButtonsContainer.querySelectorAll('button');
            spellButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
            console.log('ğŸ”’ ì£¼ë¬¸ ë²„íŠ¼ ë¹„í™œì„±í™”ë¨');
        }
        
        // ì£¼ë¬¸ ë²„íŠ¼ í™œì„±í™” í•¨ìˆ˜
        function enableSpellButtons() {
            spellButtonsDisabled = false;
            const spellButtons = spellButtonsContainer.querySelectorAll('button');
            spellButtons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            });
            console.log('ğŸ”“ ì£¼ë¬¸ ë²„íŠ¼ í™œì„±í™”ë¨');
        }
        
        // ë””ë²„ê·¸: ë³€ìˆ˜ ì´ˆê¸°í™” í™•ì¸
        console.log('ğŸ® ë³€ìˆ˜ ì´ˆê¸°í™”:', { previousMyHealth, previousOpponentHealth });

        // AI ë‚œì´ë„ë³„ ì‹œê°„ ì œí•œ ì„¤ì •
        function setTurnDurationByDifficulty() {
            if (multiplayerMode) {
                TURN_DURATION = GAME_CONFIG.turnDuration.multiplayer;
            } else {
                TURN_DURATION = GAME_CONFIG.turnDuration[aiDifficulty] || GAME_CONFIG.turnDuration.normal;
            }
            console.log(`â° AI ë‚œì´ë„: ${aiDifficulty}, ì‹œê°„ ì œí•œ: ${TURN_DURATION === Infinity ? 'ë¬´ì œí•œ' : TURN_DURATION + 'ì´ˆ'}`);
        }

        // í„´ íƒ€ì´ë¨¸ ê´€ë ¨ í•¨ìˆ˜ë“¤
        function startTurnTimer() {
            if (turnTimer) {
                clearInterval(turnTimer);
            }
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ íƒ€ì´ë¨¸ ì‹œì‘ ì¤‘ë‹¨
            if (!state || !state.players || state.players.length < 2) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ íƒ€ì´ë¨¸ ì‹œì‘ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            // AI ë‚œì´ë„ë³„ ì‹œê°„ ì œí•œ ì„¤ì •
            setTurnDurationByDifficulty();
            console.log(`â° ì‹œê°„ ì œí•œ ì„¤ì • ì™„ë£Œ - TURN_DURATION: ${TURN_DURATION}ì´ˆ`);
            
            // ì‹œê°„ ì œí•œì´ ì—†ìœ¼ë©´ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•˜ì§€ ì•ŠìŒ
            if (TURN_DURATION === Infinity) {
                console.log('â° ì‹œê°„ ì œí•œ ì—†ìŒ - íƒ€ì´ë¨¸ ë¹„í™œì„±í™”');
                updateTurnGauge(); // ê²Œì´ì§€ ì´ˆê¸°í™”ë§Œ
                return;
            }
            
            turnTimeLeft = TURN_DURATION;
            
            // ì²« í„´ ì‹œì‘ ì‹œ ê²Œì´ì§€ë¥¼ ì¦‰ì‹œ í‘œì‹œ
            updateTurnGauge();
            
            console.log(`â° íƒ€ì´ë¨¸ ì‹œì‘ - í˜„ì¬í”Œë ˆì´ì–´: ${state.currentPlayerId}, ë‚´í„´: ${state.isPlayerTurn}, ì œí•œì‹œê°„: ${TURN_DURATION}ì´ˆ, ë‚¨ì€ì‹œê°„: ${turnTimeLeft}ì´ˆ`);
            
            // ë” ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´ 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
            turnTimer = setInterval(() => {
                turnTimeLeft -= 0.1; // 0.1ì´ˆì”© ê°ì†Œ
                updateTurnGauge();
                
                if (turnTimeLeft <= 0) {
                    clearInterval(turnTimer);
                    turnTimer = null;
                    console.log('â° í„´ ì‹œê°„ ì´ˆê³¼! ìë™ í„´ ì¢…ë£Œ');
                    addLog(Messages.timeOut());
                    endTurn();
                }
            }, 100); // 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
        }
        
        function stopTurnTimer() {
            if (turnTimer) {
                clearInterval(turnTimer);
                turnTimer = null;
            }
        }
        
        function resetTurnGauge() {
            const blueGauge = DOM.get('blue-gauge');
            const redGauge = DOM.get('red-gauge');
            
            if (blueGauge && redGauge) {
                blueGauge.style.width = '0%';
                redGauge.style.width = '0%';
                console.log('ğŸ”„ ê²Œì´ì§€ ì´ˆê¸°í™” ì™„ë£Œ');
            }
        }
        
        function updateTurnGauge() {
            const blueGauge = DOM.get('blue-gauge');
            const redGauge = DOM.get('red-gauge');
            
            if (!blueGauge || !redGauge) return;
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ê²Œì´ì§€ ì´ˆê¸°í™”ë§Œ
            if (!state || !state.players || state.players.length < 2) {
                blueGauge.style.width = '0%';
                redGauge.style.width = '0%';
                return;
            }
            
            // ì‹œê°„ ì œí•œì´ ì—†ìœ¼ë©´ ê²Œì´ì§€ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ
            if (TURN_DURATION === Infinity) {
                blueGauge.style.width = '0%';
                redGauge.style.width = '0%';
                return;
            }
            
            // ì²« í„´ ì‹œì‘ ì‹œì—ë„ ê²Œì´ì§€ê°€ í‘œì‹œë˜ë„ë¡ ìˆ˜ì •
            let progress;
            if (turnTimeLeft === TURN_DURATION) {
                // ì²« í„´ ì‹œì‘ ì‹œ - ê²Œì´ì§€ê°€ 0%ì—ì„œ ì‹œì‘í•˜ë„ë¡
                progress = 0;
            } else {
                progress = turnTimeLeft >= 0 ? (TURN_DURATION - turnTimeLeft) / TURN_DURATION : 0;
            }
            const gaugeWidth = Math.min(progress * 100, 100);
            
            // ë””ë²„ê·¸: ê²Œì´ì§€ ê³„ì‚° ë¡œê·¸ (ì²« í„´ ì‹œì‘ ì‹œì—ë§Œ)
            if (turnTimeLeft === TURN_DURATION) {
                console.log(`ğŸ¯ ì²« í„´ ê²Œì´ì§€ ê³„ì‚° - TURN_DURATION: ${TURN_DURATION}, turnTimeLeft: ${turnTimeLeft}, progress: ${progress}, gaugeWidth: ${gaugeWidth}%`);
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ë‚´ í„´ì¸ì§€ í™•ì¸
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const isMyTurn = (state.currentPlayerId === myPlayerId);
            
            // AI ëª¨ë“œì—ì„œëŠ” í”Œë ˆì´ì–´ 1ì´ í•­ìƒ ë‚´ í„´
            if (multiplayerMode) {
                if (isMyTurn) {
                    // ë‚´ í„´ - íŒŒë€ìƒ‰ ê²Œì´ì§€ (ì™¼ìª½ë¶€í„°)
                    blueGauge.style.width = `${gaugeWidth}%`;
                    redGauge.style.width = '0%';
                } else {
                    // ìƒëŒ€ í„´ - ë¹¨ê°„ìƒ‰ ê²Œì´ì§€ (ì˜¤ë¥¸ìª½ë¶€í„°)
                    blueGauge.style.width = '0%';
                    redGauge.style.width = `${gaugeWidth}%`;
                }
            } else {
                // AI ëª¨ë“œ
                if (state.currentPlayerId === 1) {
                    // ë‚´ í„´ - íŒŒë€ìƒ‰ ê²Œì´ì§€ (ì™¼ìª½ë¶€í„°)
                    blueGauge.style.width = `${gaugeWidth}%`;
                    redGauge.style.width = '0%';
                } else {
                    // AI í„´ - ë¹¨ê°„ìƒ‰ ê²Œì´ì§€ (ì˜¤ë¥¸ìª½ë¶€í„°)
                    blueGauge.style.width = '0%';
                    redGauge.style.width = `${gaugeWidth}%`;
                }
            }
        }
        
        // ì‹œê°ì  í”¼ë“œë°± í•¨ìˆ˜ë“¤
        function showDamageEffect(element, amount) {
            const damageEl = document.createElement('div');
            damageEl.className = 'card-damage';
            damageEl.textContent = `-${amount}`;
            element.appendChild(damageEl);
            
            setTimeout(() => {
                element.removeChild(damageEl);
            }, 1000);
        }
        
        function showHealEffect(element, amount) {
            const healEl = document.createElement('div');
            healEl.className = 'card-heal';
            healEl.textContent = `+${amount}`;
            element.appendChild(healEl);
            
            setTimeout(() => {
                element.removeChild(healEl);
            }, 1000);
        }
        
        function addSuccessAnimation(element) {
            element.classList.add('success-animation');
            setTimeout(() => {
                element.classList.remove('success-animation');
            }, 500);
        }
        
        function addFailureAnimation(element) {
            element.classList.add('failure-animation');
            setTimeout(() => {
                element.classList.remove('failure-animation');
            }, 500);
        }





        // ë””ë²„ê·¸ íŒ¨ë„ í† ê¸€ (Ctrl+D)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                debugPanel.classList.toggle('hidden');
                console.log('ğŸ”§ ë””ë²„ê·¸ íŒ¨ë„ í† ê¸€ë¨');
            }
        });

        // ì¹˜íŠ¸: ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” (Ctrl+Alt+P)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.altKey && e.key === 'p') {
                e.preventDefault();
                if (confirm('ì •ë§ ëª¨ë“  ì„œë²„ì˜ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    console.log('ğŸ§¹ ì¹˜íŠ¸: ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ìš”ì²­');
                    if (socket) {
                        socket.emit('resetAllServerData');
                    }
                }
            }
        });

        // ëœë¤ ì´ë¦„ ìƒì„± í•¨ìˆ˜
        function generateRandomName() {
            const alphabetChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const numericChars = '0123456789';
            let randomName = '';
            
            // ì•ŒíŒŒë²³ 3ê°œ ìƒì„±
            for (let charIndex = 0; charIndex < 3; charIndex++) {
                randomName += alphabetChars.charAt(Math.floor(Math.random() * alphabetChars.length));
            }
            
            // ìˆ«ì 3ê°œ ìƒì„±
            for (let charIndex = 0; charIndex < 3; charIndex++) {
                randomName += numericChars.charAt(Math.floor(Math.random() * numericChars.length));
            }
            
            return randomName;
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ê¸°ë³¸ ì´ë¦„ ì„¤ì •
        function initializePlayerName() {
            let playerName = localStorage.getItem('playerName');
            
            // ì´ë¦„ì´ ì—†ìœ¼ë©´ ëœë¤ ì´ë¦„ ìƒì„±
            if (!playerName) {
                playerName = generateRandomName();
                localStorage.setItem('playerName', playerName);
                console.log(`ğŸ² ëœë¤ ì´ë¦„ ìƒì„±: ${playerName}`);
            }
            
            return playerName;
        }

        // ì¹˜íŠ¸: ìì‹ ì˜ ë°ì´í„°ë§Œ ì´ˆê¸°í™” (Ctrl+P)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && !e.shiftKey && e.key === 'p') {
                e.preventDefault();
                const playerName = localStorage.getItem('playerName') || 'Player';
                if (confirm('ì •ë§ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    console.log('ğŸ§¹ ì¹˜íŠ¸: ê°œì¸ ë°ì´í„° ì´ˆê¸°í™” ìš”ì²­');
                    if (socket) {
                        socket.emit('resetMyData', { playerName: playerName });
                    }
                }
            }
        });
        
        // ë©”ëª¨ íŒ¨ë„ í† ê¸€ (M í‚¤) - ë¹„í™œì„±í™” (í•­ìƒ í‘œì‹œ)
        // document.addEventListener('keydown', (e) => {
        //     if (e.key.toLowerCase() === 'm' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
        //         e.preventDefault();
        //         if (!state.isGameOver && state.isPlayerTurn) {
        //             toggleMemoPanel();
        //         }
        //     }
        // });

        function initGame() {
            console.log('ğŸ® ê²Œì„ ì´ˆê¸°í™” ì‹œì‘');
            let deck = [];
            for (let spellNumber = 1; spellNumber <= GAME_CONFIG.deckStructure.maxSpell; spellNumber++) {
                for (let cardCount = 0; cardCount < GAME_CONFIG.deckStructure.cardsPerSpell(spellNumber); cardCount++) {
                    deck.push(spellNumber);
                }
            }
            console.log('ğŸ“¦ ì´ˆê¸° ë± ìƒì„±:', deck);
            
            for (let currentIndex = deck.length - 1; currentIndex > 0; currentIndex--) {
                const randomIndex = Math.floor(Math.random() * (currentIndex + 1));
                [deck[currentIndex], deck[randomIndex]] = [deck[randomIndex], deck[currentIndex]];
            }
            console.log('ğŸ”„ ë± ì…”í”Œ ì™„ë£Œ');
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ì„ ê²°ì •í•˜ê³  ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
            let firstPlayer;
            if (multiplayerMode && isHost) {
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer}`);
                
                // ìƒëŒ€ë°©ì—ê²Œ ì²« ë²ˆì§¸ í„´ ì •ë³´ ì „ì†¡
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'firstTurn',
                        firstPlayer: firstPlayer
                    }));
                }
            } else if (multiplayerMode && !isHost) {
                // ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦¼
                console.log('â³ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì • ëŒ€ê¸° ì¤‘...');
                return; // í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦° í›„ ë‹¤ì‹œ í˜¸ì¶œë¨
            } else {
                // AI ëª¨ë“œì—ì„œëŠ” ëœë¤ ê²°ì •
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ AI ëª¨ë“œ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer}`);
            }
            
            const aiName = aiDifficulty === 'easy' ? 'ì…ë¬¸ìš© í—ˆìˆ˜ì•„ë¹„' : aiDifficulty === 'normal' ? 'í›ˆë ¨ìš© í—ˆìˆ˜ì•„ë¹„' : 'ê³ ìˆ˜ìš© í—ˆìˆ˜ì•„ë¹„';
            state = {
                players: [
                                    { id: 1, name: 'Player', health: GAME_CONFIG.maxHealth, hand: deck.slice(0, 6).sort((a, b) => a - b), knownSecretStones: [] },
                { id: 2, name: multiplayerMode ? 'Opponent' : aiName, health: GAME_CONFIG.maxHealth, hand: deck.slice(6, 12).sort((a, b) => a - b), knownSecretStones: [] }
                ],
                secretStones: deck.slice(12),
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: firstPlayer,
                lastSuccessfulSpell: 0,
                isPlayerTurn: firstPlayer === 1,
                turnInProgress: false,
                gameLog: [`ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ${firstPlayer === 1 ? playerName : (multiplayerMode ? opponentName : aiName)}ê°€ ë¨¼ì € ì‹œì‘í•©ë‹ˆë‹¤.`],
                isGameOver: false,
                memoNotes: {},
                memoPanelActive: false,
            };
            
            console.log('ğŸ¯ ì´ˆê¸° ê²Œì„ ìƒíƒœ ì„¤ì • ì™„ë£Œ');
            
            createSpellButtons();
            updatePlayerName();
            render();
            updateDebugInfo();
            
            // ë©”ëª¨ íŒ¨ë„ í‘œì‹œ
            showMemoPanel();
            
            // ê²Œì„ ì‹œì‘ ì‚¬ìš´ë“œ
            playGameStartSound();
        }

        // ë„ë§ ì²˜ë¦¬
        async function handleSurrender(surrenderingPlayerId) {
            console.log('ğŸ³ï¸ ìƒëŒ€ë°© ë„ë§ ì²˜ë¦¬');
            
            // ìŠ¹ë¦¬ ì²˜ë¦¬ (ìƒëŒ€ë°©ì´ ë„ë§ì³¤ìœ¼ë¯€ë¡œ ë‚´ê°€ ìŠ¹ë¦¬)
            updateStats(true, true);
            
            // ìŠ¹ë¦¬ì˜ ì¦í‘œ ì¶”ê°€ (ë©€í‹°í”Œë ˆì´ì–´ ìŠ¹ë¦¬)
            TrophySystem.addVictoryTrophy('multiplayer');
            
            let message = 'ìƒëŒ€ê°€ ë„ë§ì³ì„œ ìŠ¹ë¦¬í•˜ì˜€ìŠµë‹ˆë‹¤!';
            message += '\n\nğŸ… ìŠ¹ì  +3';
            
            addLog('ìƒëŒ€ë°©ì´ ë„ë§ì³¤ìŠµë‹ˆë‹¤.');
            addLog('ìŠ¹ë¦¬ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
            state = {
                gameStarted: false,
                isGameOver: true,
                players: [],
                secretStones: [],
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: null,
                isPlayerTurn: false,
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                gameLog: []
            };
            
            // ìŠ¹ë¦¬í•œ í”Œë ˆì´ì–´ì—ê²Œ ë©”ì‹œì§€ í‘œì‹œ
            await showModal('ê²Œì„ ì¢…ë£Œ', message, true);
            
            // íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            showTitleScreen();
        }

        // ìŠ¹ë¦¬ì˜ ì¦í‘œ ì‹œìŠ¤í…œ
        const TrophySystem = {
            // ì¦í‘œ ë°ì´í„° ë¡œë“œ
            loadTrophies() {
                const aiTrophies = localStorage.getItem('aiTrophies') || '0';
                const multiplayerTrophies = localStorage.getItem('multiplayerTrophies') || '0';
                return {
                    ai: Math.max(0, parseInt(aiTrophies)),
                    multiplayer: Math.max(0, parseInt(multiplayerTrophies))
                };
            },
            
            // ì¦í‘œ ë°ì´í„° ì €ì¥
            saveTrophies(trophies) {
                localStorage.setItem('aiTrophies', trophies.ai.toString());
                localStorage.setItem('multiplayerTrophies', trophies.multiplayer.toString());
            },
            
            // ì¦í‘œ ì—…ë°ì´íŠ¸
            updateTrophy(type, change) {
                const trophies = this.loadTrophies();
                trophies[type] = Math.max(0, trophies[type] + change);
                this.saveTrophies(trophies);
                this.displayTrophies(trophies);
                return trophies[type];
            },
            
            // ì¦í‘œ í‘œì‹œ
            displayTrophies(trophies) {
                const aiCount = DOM.get('ai-trophy-count');
                const multiplayerCount = DOM.get('multiplayer-trophy-count');
                
                if (aiCount) aiCount.textContent = `${trophies.ai}ì `;
                if (multiplayerCount) multiplayerCount.textContent = `${trophies.multiplayer}ì `;
            },
            
            // ìŠ¹ë¦¬ ì‹œ ì¦í‘œ ì¶”ê°€
            addVictoryTrophy(type) {
                const newCount = this.updateTrophy(type, 3);
                showToast(`ğŸ‰ ìŠ¹ë¦¬ì˜ ì¦í‘œ +3 íšë“! (${type === 'ai' ? 'ëª¨ì˜ ê²°íˆ¬' : 'ì •ì‹ ê²°íˆ¬'} ì ìˆ˜: ${newCount})`, 'success');
            },
            
            // íŒ¨ë°° ì‹œ ì¦í‘œ ê°ì†Œ
            addDefeatTrophy(type) {
                const newCount = this.updateTrophy(type, -1);
                showToast(`ğŸ’” íŒ¨ë°°ë¡œ ì ìˆ˜ -1... (${type === 'ai' ? 'ëª¨ì˜ ê²°íˆ¬' : 'ì •ì‹ ê²°íˆ¬'} ì ìˆ˜: ${newCount})`, 'warning');
            },
            
            // ì´ˆê¸°í™”
            init() {
                const trophies = this.loadTrophies();
                this.displayTrophies(trophies);
            }
        };

        // í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì •ìœ¼ë¡œ ê²Œì„ ì´ˆê¸°í™”
        function resetGameWithFirstPlayer(firstPlayer) {
            console.log('ğŸ”„ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì •ìœ¼ë¡œ ê²Œì„ ì´ˆê¸°í™”');
            
            // ê²Œì„ ì‹œì‘ ì‹œ íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
            stopTurnTimer();
            resetTurnGauge();
            
            // ì˜¬ë°”ë¥¸ ë± ìƒì„± (1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ, 3ë²ˆì€ 3ê°œ...)
            let deck = [];
            for (let spellNumber = 1; spellNumber <= GAME_CONFIG.deckStructure.maxSpell; spellNumber++) {
                for (let cardCount = 0; cardCount < GAME_CONFIG.deckStructure.cardsPerSpell(spellNumber); cardCount++) {
                    deck.push(spellNumber);
                }
            }
            console.log('ğŸ“¦ ì´ˆê¸° ë± ìƒì„±:', deck);
            
            // ë± ì…”í”Œ
            shuffleArray(deck);
            console.log('ğŸ”„ ë± ì…”í”Œ ì™„ë£Œ');
            
            const playerName = localStorage.getItem('playerName') || 'Player';
            const opponentName = multiplayerMode ? (opponentName || 'Player2') : 'AI';
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            
            state = {
                players: [
                                    { id: 1, name: playerName, health: GAME_CONFIG.maxHealth, hand: deck.slice(0, GAME_CONFIG.maxHandSize).sort((a, b) => a - b), knownSecretStones: [] },
                { id: 2, name: opponentName, health: GAME_CONFIG.maxHealth, hand: deck.slice(GAME_CONFIG.maxHandSize, GAME_CONFIG.maxHandSize * 2).sort((a, b) => a - b), knownSecretStones: [] }
                ],
                secretStones: deck.slice(14),
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: firstPlayer,
                isPlayerTurn: multiplayerMode ? (firstPlayer === myPlayerId) : (firstPlayer === 1),
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                isGameOver: false,
                gameStarted: true,
                gameLog: [Messages.gameStart(firstPlayer === 1 ? playerName : opponentName)]
            };
            
            console.log('ğŸ¯ ê²ŒìŠ¤íŠ¸ ì´ˆê¸° ê²Œì„ ìƒíƒœ:', {
                playerHand: state.players[0].hand,
                opponentHand: state.players[1].hand,
                secretStones: state.secretStones,
                playerHealth: state.players[0].health,
                opponentHealth: state.players[1].health,
                firstPlayer: firstPlayer
            });
            
            createSpellButtons();
            updatePlayerName();
            render();
            updateButtons();
            
            // ë©”ëª¨ íŒ¨ë„ í‘œì‹œ
            showMemoPanel();
            
            // ê²Œì„ ì‹œì‘ ì‚¬ìš´ë“œ
            playGameStartSound();
            
            // ë””ë²„ê·¸: UI ìƒíƒœ í™•ì¸
            console.log('ğŸ® ê²Œì„ UI ë Œë”ë§ ì™„ë£Œ');
            console.log('ğŸ“Š í˜„ì¬ ìƒíƒœ:', {
                isPlayerTurn: state.isPlayerTurn,
                currentPlayerId: state.currentPlayerId,
                gameStarted: state.gameStarted,
                isGameOver: state.isGameOver
            });
            
            // ì²« ë²ˆì§¸ í„´ íƒ€ì´ë¨¸ ì‹œì‘
            setTimeout(() => {
                startTurnTimer();
            }, 1000);
            
            // ê²Œì„ ìƒíƒœ ì•ˆì „ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰
            setTimeout(() => {
                safeRefreshGameState();
            }, 500);
        }

        function updateDebugInfo() {
            if (!debugPanel.classList.contains('hidden')) {
                const player = state.players[0];
                const ai = state.players[1];
                debugInfo.innerHTML = `
                                    <div>í„´: ${state.currentPlayerId === 1 ? state.players[0].name : state.players[1].name}</div>
                <div>${state.players[0].name} ì²´ë ¥: ${player.health} | ${state.players[1].name} ì²´ë ¥: ${ai.health}</div>
                <div>${state.players[0].name} ì†íŒ¨: [${player.hand.join(', ')}]</div>
                    <div>${state.players[1].name} ì†íŒ¨: [${ai.hand.join(', ')}]</div>
                    <div>ë¹„ë°€ì˜ ëŒ: ${state.secretStones.length}ê°œ</div>
                    <div>ì‚¬ìš©í•œ ëŒ: ${state.usedStones.length}ê°œ</div>
                    <div>ë§ˆì§€ë§‰ ì„±ê³µ ì˜ì°½: ${state.lastSuccessfulSpell} ${state.lastSuccessfulSpell > 0 ? `(ì—°ì† ì˜ì°½: ${state.lastSuccessfulSpell}ë²ˆ ì´ìƒ)` : '(ì—°ì† ì˜ì°½ ì—†ìŒ)'}</div>
                    <div>ê²Œì„ ì¢…ë£Œ: ${state.isGameOver}</div>
                `;
            }
        }

        function render() {
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ë Œë”ë§ ì¤‘ë‹¨
            if (!state || !state.players || state.players.length < 2) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            // í”Œë ˆì´ì–´ ê°ì²´ë“¤ì´ ìœ íš¨í•œì§€ ì¶”ê°€ ê²€ì‚¬
            if (!state.players[0] || !state.players[1]) {
                console.log('âš ï¸ í”Œë ˆì´ì–´ ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const player = state.players[0];
            const opponent = state.players[1];
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ í”Œë ˆì´ì–´ 1, ê²ŒìŠ¤íŠ¸ê°€ í”Œë ˆì´ì–´ 2
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const myPlayer = state.players[myPlayerId - 1];
            const opponentPlayer = state.players[2 - myPlayerId]; // ìƒëŒ€ëŠ” ë‚˜ë¨¸ì§€ í”Œë ˆì´ì–´
            
            // í•˜íŠ¸ ë³€í™” ê°ì§€ (í•˜íŠ¸ ì—…ë°ì´íŠ¸ ì „ì—)
            const currentMyHealth = myPlayer.health;
            const currentOpponentHealth = opponentPlayer.health;
            
            console.log(`ğŸ” í•˜íŠ¸ ë³€í™” ì²´í¬ - ë‚´: ${previousMyHealth} â†’ ${currentMyHealth}, ìƒëŒ€: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            
            // í•˜íŠ¸ ë³€í™” ê°ì§€ (ë¡œê¹…ë§Œ)
            if (currentMyHealth < previousMyHealth) {
                console.log(`ğŸ’” ë‚´ í•˜íŠ¸ ì†ì‹¤: ${previousMyHealth} â†’ ${currentMyHealth}`);
            }
            if (currentMyHealth > previousMyHealth) {
                console.log(`ğŸ’š ë‚´ í•˜íŠ¸ íšŒë³µ: ${previousMyHealth} â†’ ${currentMyHealth}`);
            }
            if (currentOpponentHealth < previousOpponentHealth) {
                console.log(`ğŸ’” ìƒëŒ€ í•˜íŠ¸ ì†ì‹¤: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            }
            if (currentOpponentHealth > previousOpponentHealth) {
                console.log(`ğŸ’š ìƒëŒ€ í•˜íŠ¸ íšŒë³µ: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            }
            
            // í˜„ì¬ í•˜íŠ¸ ìƒíƒœ ì €ì¥
            previousMyHealth = currentMyHealth;
            previousOpponentHealth = currentOpponentHealth;
            
            // ì²´ë ¥ í‘œì‹œ ì—…ë°ì´íŠ¸ (íŒŒí‹°í´ ìƒì„± í›„)
            myHealthEl.innerHTML = '<span class="health-heart">â¤ï¸</span>'.repeat(Math.max(0, myPlayer.health));
            opponentHealthEl.innerHTML = '<span class="health-heart">â¤ï¸</span>'.repeat(Math.max(0, opponentPlayer.health));
            
            // ì²´ë ¥ í•˜íŠ¸ì— ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
            const hearts = myHealthEl.querySelectorAll('span');
            hearts.forEach(heart => heart.classList.add('health-heart'));
            
            // ë””ë²„ê·¸: í•˜íŠ¸ ë³€í™” ë¡œê·¸
            console.log(`ğŸ’” í•˜íŠ¸ ë³€í™” ê°ì§€ - ë‚´ í•˜íŠ¸: ${previousMyHealth} â†’ ${currentMyHealth}, ìƒëŒ€ í•˜íŠ¸: ${previousOpponentHealth} â†’ ${currentOpponentHealth}`);
            
            // ë‚´ ì†íŒ¨ (ë’·ë©´) - í•­ìƒ í•˜ë‹¨ì— í‘œì‹œ
            myHandEl.innerHTML = myPlayer.hand.map(() => `<div class="card card-back"></div>`).join('');
            
            // ìƒëŒ€ ì†íŒ¨ (ì•ë©´) - í•­ìƒ ìƒë‹¨ì— í‘œì‹œ, ìƒëŒ€ì˜ íŒ¨ë¥¼ ë³¼ ìˆ˜ ìˆì–´ì•¼ í•¨
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ìƒëŒ€ë°©ì˜ ì‹¤ì œ íŒ¨ë¥¼ í‘œì‹œ
            opponentHandEl.innerHTML = opponentPlayer.hand.map(stone => `
                <div class="card card-front flex flex-col items-center justify-center">
                    <div class="text-2xl mb-1">${getSpellIcon(stone)}</div>
                    <div class="text-sm font-bold">${stone}</div>
                </div>
            `).join('');
            
            secretStonesCountEl.textContent = `${state.secretStones.length}ê°œ`;
            usedStonesCountEl.textContent = `${state.usedStones.length}ê°œ`;
            
            // ê²Œì„ ë¡œê·¸ì— ìŠ¤íƒ€ì¼ë§ ì¶”ê°€
            gameLogEl.innerHTML = state.gameLog.map(log => {
                const isSuccess = log.includes('âœ…');
                const isFailure = log.includes('âŒ');
                const isTurn = log.includes('í„´');
                const isGameEnd = log.includes('ê²Œì„ ì¢…ë£Œ');
                
                let className = '';
                if (isSuccess) className = 'text-green-400';
                else if (isFailure) className = 'text-red-400';
                else if (isTurn) className = 'text-blue-400 font-bold';
                else if (isGameEnd) className = 'text-purple-400 font-bold';
                
                return `<p class="${className}">${log}</p>`;
            }).join('');
            
            // í˜„ì¬ í„´ì— ë”°ë¼ ì˜ì—­ í•˜ì´ë¼ì´íŠ¸ ë° ìƒ‰ìƒ êµ¬ë¶„
            const currentMyPlayerId = isHost ? 1 : 2;
            const isMyTurn = (state.currentPlayerId === currentMyPlayerId);
            
            // ê¸€ë¡œìš° íš¨ê³¼: í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì—ê²Œë§Œ í‘œì‹œ
            myArea.classList.toggle('player-area-glow', isMyTurn && !state.isGameOver);
            opponentArea.classList.toggle('player-area-glow', !isMyTurn && !state.isGameOver);
            opponentArea.classList.toggle('opponent-turn', !isMyTurn && !state.isGameOver);
            
            // í„´ ì¸ë””ì¼€ì´í„°: í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì—ê²Œë§Œ í‘œì‹œ
            const myTurnIndicator = DOM.get('my-turn-indicator');
            const opponentTurnIndicator = DOM.get('opponent-turn-indicator');
            
            if (myTurnIndicator && opponentTurnIndicator) {
                // ë‚´ í„´ ì¸ë””ì¼€ì´í„°: ë‚´ í„´ì¼ ë•Œë§Œ í‘œì‹œ
                myTurnIndicator.classList.toggle('hidden', !isMyTurn || state.isGameOver);
                
                // ìƒëŒ€ í„´ ì¸ë””ì¼€ì´í„°: ìƒëŒ€ í„´ì¼ ë•Œë§Œ í‘œì‹œ (ë¹¨ê°„ìƒ‰)
                opponentTurnIndicator.classList.toggle('hidden', isMyTurn || state.isGameOver);
                opponentTurnIndicator.classList.toggle('opponent-turn', !isMyTurn && !state.isGameOver);
            }
            
            // ë²„íŠ¼ë“¤ì´ í•­ìƒ ë³´ì´ë„ë¡ ê°•ì œ ì„¤ì •
            const spellButtons = spellButtonsContainer.querySelectorAll('button');
            spellButtons.forEach(btn => {
                btn.style.display = 'block';
                btn.style.visibility = 'visible';
            });
            
            updateButtons();
            updateDebugInfo();
            
            // ë©”ëª¨ íŒ¨ë„ì„ í•­ìƒ í‘œì‹œ
            if (state.gameStarted && !state.isGameOver) {
                showMemoPanel();
            }
            
            // ê²Œì„ ìƒíƒœê°€ ì´ìƒí•œ ê²½ìš° ìë™ ë³µêµ¬
            if (multiplayerMode && (!state.players || state.players.length < 2)) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœ ì´ìƒ ê°ì§€, ìë™ ë³µêµ¬ ì‹œë„');
                setTimeout(() => {
                    safeRefreshGameState();
                }, 1000);
            }
            
            // í„´ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë° ë™ê¸°í™”
            if (multiplayerMode && state.players && state.players.length >= 2) {
                const myPlayerId = isHost ? 1 : 2;
                const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                if (state.isPlayerTurn !== shouldBeMyTurn) {
                    console.log(`âš ï¸ í„´ ìƒíƒœ ë¶ˆì¼ì¹˜ ê°ì§€ - ë‚´ í„´: ${state.isPlayerTurn}, ì‹¤ì œ í„´: ${shouldBeMyTurn}`);
                    state.isPlayerTurn = shouldBeMyTurn;
                    console.log(`ğŸ”„ í„´ ìƒíƒœ ìë™ ë™ê¸°í™”: ${state.isPlayerTurn} â†’ ${shouldBeMyTurn}`);
                }
            }
        }

        function createSpellButtons() {
            console.log('ğŸ”˜ ì˜ì°½ ë²„íŠ¼ ìƒì„±');
            spellButtonsContainer.innerHTML = '';
            
            const spellDescriptions = [
                { number: 1, name: 'ìš´ëª… ë³€í™˜', icon: 'ğŸ”®', desc: 'ë¹„ë°€ ì£¼ë¬¸ 3ê°œ ê³µê°œ' },
                { number: 2, name: 'ë§ˆë ¥ ì°©ì·¨', icon: 'ğŸ’«', desc: 'í”¼í•´ 1, íšŒë³µ 1' },
                { number: 3, name: 'ì •ì‹  êµë€', icon: 'ğŸŒ€', desc: 'ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸<br>í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…' },
                { number: 4, name: 'í™”ì—¼ í™”ì‚´', icon: 'ğŸ”¥', desc: 'í”¼í•´ 1' },
                { number: 5, name: 'ìƒëª… ë¬¼ì•½', icon: 'ğŸ§ª', desc: 'íšŒë³µ 1' },
                { number: 6, name: 'ëª…ìƒ', icon: 'ğŸ’¤', desc: 'ë¹„ë°€ ì£¼ë¬¸ 1ê°œ ê³µê°œ' }
            ];
            
            spellDescriptions.forEach(spell => {
                const button = document.createElement('button');
                button.innerHTML = `
                    <div class="text-lg">${spell.icon}</div>
                    <div class="text-xs font-bold">${spell.number}: ${spell.name}</div>
                    <div class="text-xs opacity-75">${spell.desc}</div>
                `;
                button.classList.add('py-3', 'rounded-lg', 'font-bold', 'btn-primary', 'spell-button', 'flex', 'flex-col', 'items-center', 'justify-center', 'h-24');
                button.dataset.spell = spell.number;
                button.addEventListener('click', () => handleSpellCast(spell.number));
                
                // ë²„íŠ¼ì´ í•­ìƒ ë³´ì´ë„ë¡ ê°•ì œ ì„¤ì •
                button.style.display = 'block';
                button.style.visibility = 'visible';
                
                spellButtonsContainer.appendChild(button);
                console.log(`ğŸ”˜ ì˜ì°½ ${spell.number} ë²„íŠ¼ ìƒì„± ì™„ë£Œ`);
            });
            
            createMemoButtons();
        }
        
        function createMemoButtons() {
            console.log('ğŸ“ ë©”ëª¨ ë²„íŠ¼ ìƒì„±');
            const memoButtonsContainer = DOM.get('memo-buttons');
            memoButtonsContainer.innerHTML = '';
            
            const spellDescriptions = [
                { number: 1, name: 'ìš´ëª… ë³€í™˜' },
                { number: 2, name: 'ë§ˆë ¥ ì°©ì·¨' },
                { number: 3, name: 'ì •ì‹  êµë€' },
                { number: 4, name: 'í™”ì—¼ í™”ì‚´' },
                { number: 5, name: 'ìƒëª… ë¬¼ì•½' },
                { number: 6, name: 'ëª…ìƒ' }
            ];
            
            spellDescriptions.forEach(spell => {
                const button = document.createElement('button');
                button.innerHTML = `
                    <div class="text-xs">âŒ</div>
                `;
                button.classList.add('py-1', 'px-2', 'rounded-lg', 'font-bold', 'memo-button', 'flex', 'flex-col', 'items-center', 'justify-center', 'h-8');
                button.dataset.spell = spell.number;
                button.addEventListener('click', () => toggleMemo(spell.number));
                memoButtonsContainer.appendChild(button);
            });
        }
        
        function toggleMemo(spellNumber) {
            if (!state.memoNotes) {
                state.memoNotes = {};
            }
            
            // í† ê¸€: í˜„ì¬ ìƒíƒœì˜ ë°˜ëŒ€ë¡œ ë³€ê²½
            const currentState = state.memoNotes[spellNumber] || false;
            state.memoNotes[spellNumber] = !currentState;
            
            console.log(`ğŸ“ ë©”ëª¨ í† ê¸€: ì˜ì°½ ${spellNumber} - ${state.memoNotes[spellNumber] ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
            
            updateMemoButtons();
            playCardSound();
        }
        
        function updateMemoButtons() {
            const memoButtons = document.querySelectorAll('.memo-button');
            memoButtons.forEach(button => {
                const spellNumber = parseInt(button.dataset.spell);
                const isActive = state.memoNotes && state.memoNotes[spellNumber];
                
                if (isActive) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }
        
        function toggleMemoPanel() {
            const memoButtons = DOM.get('memo-buttons');
            const isVisible = !memoButtons.classList.contains('hidden');
            
            if (isVisible) {
                memoButtons.classList.add('hidden');
                state.memoPanelActive = false;
                console.log('ğŸ“ ë©”ëª¨ íŒ¨ë„ ë¹„í™œì„±í™”');
            } else {
                memoButtons.classList.remove('hidden');
                state.memoPanelActive = true;
                console.log('ğŸ“ ë©”ëª¨ íŒ¨ë„ í™œì„±í™”');
            }
            
            playCardSound();
        }
        
        // ë©”ëª¨ íŒ¨ë„ì„ í•­ìƒ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
        function showMemoPanel() {
            const memoButtons = DOM.get('memo-buttons');
            memoButtons.classList.remove('hidden');
            state.memoPanelActive = true;
            console.log('ğŸ“ ë©”ëª¨ íŒ¨ë„ í•­ìƒ í‘œì‹œ');
        }

        // ê²Œì„ ìƒíƒœ ì•ˆì „ ìƒˆë¡œê³ ì¹¨ í•¨ìˆ˜
        function safeRefreshGameState() {
            try {
                // ê²Œì„ ìƒíƒœ ìœ íš¨ì„± ê²€ì‚¬
                if (!GameConditions.isGameValid()) {
                    console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ - ê¸°ë³¸ ìƒíƒœë¡œ ë³µêµ¬');
                    resetGame();
                    return;
                }
                
                // ì²´ë ¥ ìŒìˆ˜ ë°©ì§€
                state.players.forEach(player => {
                    if (player.health < 0) {
                        console.log(`âš ï¸ í”Œë ˆì´ì–´ ${player.name} ì²´ë ¥ ìŒìˆ˜ ë°©ì§€: ${player.health} â†’ 0`);
                        player.health = 0;
                    }
                });
                
                // í˜„ì¬ ê²Œì„ ìƒíƒœ ë°±ì—…
                const currentState = { ...state };
                const currentPlayerName = localStorage.getItem('playerName') || 'Player';
                
                // ìƒëŒ€ë°© ì´ë¦„ì„ ë” ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°
                let currentOpponentName = 'Player2';
                if (opponentName) {
                    currentOpponentName = opponentName;
                } else if (state.players && state.players.length >= 2) {
                    // ê²Œì„ ìƒíƒœì—ì„œ ìƒëŒ€ë°© ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                    const myPlayerId = isHost ? 1 : 2;
                    const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
                    if (opponentPlayer && opponentPlayer.name) {
                        currentOpponentName = opponentPlayer.name;
                    }
                }
                
                // ê¸°ë³¸ UI ìš”ì†Œë“¤ ê°•ì œ ìƒˆë¡œê³ ì¹¨
                createSpellButtons();
                
                // ë‚´ ì´ë¦„ë§Œ ì—…ë°ì´íŠ¸ (ìƒëŒ€ë°© ì´ë¦„ì€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ)
                const myTitle = DOM.get('my-title');
                if (myTitle) {
                    myTitle.textContent = `ë‚˜ (${currentPlayerName})`;
                }
                
                // ìƒëŒ€ë°© ì´ë¦„ë„ ì•ˆì „í•˜ê²Œ ì—…ë°ì´íŠ¸
                updateOpponentName();
                
                // ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸
                const opponentArea = DOM.get('opponent-area');
                const opponentTitle = opponentArea.querySelector('h2');
                if (opponentTitle) {
                    // í˜„ì¬ í‘œì‹œëœ ì´ë¦„ì´ ìˆìœ¼ë©´ ìœ ì§€, ì—†ìœ¼ë©´ ìƒˆë¡œ ì„¤ì •
                    const currentDisplayName = opponentTitle.textContent;
                    if (currentDisplayName && currentDisplayName !== 'ìƒëŒ€') {
                        // ì´ë¯¸ í‘œì‹œëœ ì´ë¦„ì´ ìˆìœ¼ë©´ ìœ ì§€
                    } else {
                        opponentTitle.textContent = `ìƒëŒ€ (${currentOpponentName})`;
                    }
                }
                
                // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•œì§€ í™•ì¸í•˜ê³  ë³µêµ¬
                if (!GameConditions.isGameValid() || !state.players[0] || !state.players[1]) {
                    // ê¸°ë³¸ ê²Œì„ ìƒíƒœë¡œ ë³µêµ¬
                    if (multiplayerMode) {
                        const myPlayerId = isHost ? 1 : 2;
                        state = {
                            players: [
                                                { id: 1, name: currentPlayerName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] },
                { id: 2, name: currentOpponentName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] }
                            ],
                            secretStones: [],
                            usedStones: [],
                            publiclyRevealedSecretStones: [],
                            currentPlayerId: 1,
                            isPlayerTurn: (myPlayerId === 1),
                            lastSuccessfulSpell: 0,
                            turnInProgress: false,
                            isGameOver: false,
                            gameStarted: true,
                            gameLog: ['ê²Œì„ ìƒíƒœê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.']
                        };
                    }
                } else {
                    // ê²Œì„ ìƒíƒœëŠ” ìœ íš¨í•˜ì§€ë§Œ í„´ ìƒíƒœë¥¼ ì¬í™•ì¸
                    if (multiplayerMode) {
                        const myPlayerId = isHost ? 1 : 2;
                        const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                        if (state.isPlayerTurn !== shouldBeMyTurn) {
                            state.isPlayerTurn = shouldBeMyTurn;
                        }
                    }
                }
                
                // UI ê°•ì œ ìƒˆë¡œê³ ì¹¨
                render();
                updateButtons();
                updateDebugInfo();
                
                // ë©”ëª¨ íŒ¨ë„ í‘œì‹œ
                showMemoPanel();
                
            } catch (error) {
                console.error('âŒ ê²Œì„ ìƒíƒœ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', error);
                addLog('âŒ ê²Œì„ ìƒíƒœ ìƒˆë¡œê³ ì¹¨ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        function updateButtons() {
            const buttons = spellButtonsContainer.querySelectorAll('button');
            const isMyTurn = GameConditions.isMyTurn();
            
            // í„´ ìƒíƒœ ë™ê¸°í™” (ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ)
            if (multiplayerMode && state.isPlayerTurn !== isMyTurn) {
                    console.log(`ğŸ”„ í„´ ìƒíƒœ ë™ê¸°í™”: isPlayerTurn ${state.isPlayerTurn} â†’ ${isMyTurn}`);
                    state.isPlayerTurn = isMyTurn;
            }
            
            // í„´ ì§„í–‰ ìƒíƒœ ê°•ì œ ì´ˆê¸°í™” (ë‚´ í„´ì´ê³  í„´ ì§„í–‰ì¤‘ì´ë©´ ì´ˆê¸°í™”)
            if (isMyTurn && state.turnInProgress) {
                console.log('âš ï¸ í„´ ì§„í–‰ ìƒíƒœ ê°•ì œ ì´ˆê¸°í™”');
                state.turnInProgress = false;
            }
            
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            console.log(`ğŸ® ë²„íŠ¼ ì—…ë°ì´íŠ¸ - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${isMyTurn}, í„´ ì§„í–‰ì¤‘: ${state.turnInProgress}, ê²Œì„ì¢…ë£Œ: ${state.isGameOver}`);
            
            buttons.forEach(btn => {
                const spellNumber = parseInt(btn.dataset.spell);
                const isDisabled = !GameConditions.canPlaySpell() || (state.lastSuccessfulSpell > 0 && spellNumber < state.lastSuccessfulSpell) || spellButtonsDisabled;
                
                // ë²„íŠ¼ì„ ì™„ì „íˆ ìˆ¨ê¸°ì§€ ë§ê³  ë¹„í™œì„±í™”ë§Œ í•˜ê¸°
                btn.disabled = isDisabled;
                
                // ë¹„í™œì„±í™”ëœ ë²„íŠ¼ë„ ì‹œê°ì ìœ¼ë¡œ ë³´ì´ë„ë¡ ìŠ¤íƒ€ì¼ ì¡°ì •
                if (isDisabled) {
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                    // ì—°ì† ì˜ì°½ ê·œì¹™ ìœ„ë°˜ ì‹œ ì¶”ê°€ ì‹œê°ì  í‘œì‹œ
                    if (state.lastSuccessfulSpell > 0 && spellNumber < state.lastSuccessfulSpell) {
                        btn.style.border = '2px solid #dc3545';
                        btn.style.color = '#dc3545';
                        // ì—°ì† ì˜ì°½ ê·œì¹™ ìœ„ë°˜ ì‹œ ì¶”ê°€ í…ìŠ¤íŠ¸ í‘œì‹œ (ë” ê°„ë‹¨í•˜ê²Œ)
                        const descElement = btn.querySelector('.text-xs.opacity-75');
                        if (descElement) {
                            descElement.innerHTML = `${state.lastSuccessfulSpell}ë²ˆ ì´ìƒ`;
                        }
                    } else {
                        btn.style.border = '';
                        btn.style.color = '';
                        // ì›ë˜ ì„¤ëª… ë³µì›
                        const descElement = btn.querySelector('.text-xs.opacity-75');
                        if (descElement) {
                        const spellDescriptions = [
                                { number: 1, desc: 'ë¹„ë°€ ì£¼ë¬¸ 3ê°œ ê³µê°œ' },
                                { number: 2, desc: 'í”¼í•´ 1, íšŒë³µ 1' },
                                { number: 3, desc: 'ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸<br>í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…' },
                                { number: 4, desc: 'í”¼í•´ 1' },
                                { number: 5, desc: 'íšŒë³µ 1' },
                                { number: 6, desc: 'ë¹„ë°€ ì£¼ë¬¸ 1ê°œ ê³µê°œ' }
                            ];
                        const spell = spellDescriptions.find(s => s.number === spellNumber);
                            if (spell) {
                                descElement.innerHTML = spell.desc;
                            }
                        }
                    }
                } else {
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                    btn.style.border = '';
                    btn.style.color = '';
                    // ì›ë˜ ì„¤ëª… ë³µì›
                    const descElement = btn.querySelector('.text-xs.opacity-75');
                    if (descElement) {
                        const spellDescriptions = [
                            { number: 1, desc: 'ë¹„ë°€ ì£¼ë¬¸ 3ê°œ ê³µê°œ' },
                            { number: 2, desc: 'í”¼í•´ 1, íšŒë³µ 1' },
                            { number: 3, desc: 'ê³µê°œë˜ì§€ ì•Šì€ ë¹„ë°€ ì£¼ë¬¸<br>í•˜ë‚˜ë¥¼ ìƒëŒ€ íŒ¨ì— íˆ¬ì…' },
                            { number: 4, desc: 'í”¼í•´ 1' },
                            { number: 5, desc: 'íšŒë³µ 1' },
                            { number: 6, desc: 'ë¹„ë°€ ì£¼ë¬¸ 1ê°œ ê³µê°œ' }
                        ];
                        const spell = spellDescriptions.find(s => s.number === spellNumber);
                        if (spell) {
                            descElement.innerHTML = spell.desc;
                        }
                    }
                }
                
                // ë””ë²„ê·¸ìš©: ë²„íŠ¼ ìƒíƒœ ë¡œê·¸
                console.log(`ğŸ”˜ ì˜ì°½ ${spellNumber} ë²„íŠ¼ - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${isMyTurn}, í„´ ì§„í–‰ì¤‘: ${state.turnInProgress}, ë§ˆì§€ë§‰ ì„±ê³µ: ${state.lastSuccessfulSpell}, ê²Œì„ì¢…ë£Œ: ${state.isGameOver}, ë²„íŠ¼ë¹„í™œì„±í™”: ${spellButtonsDisabled}, ë¹„í™œì„±í™”: ${isDisabled}`);
            });
            
            endTurnBtn.disabled = !isMyTurn || state.turnInProgress || state.isGameOver;
            
            // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ì‹œê°ì ìœ¼ë¡œ ë³´ì´ë„ë¡ ì¡°ì •
            if (endTurnBtn.disabled) {
                endTurnBtn.style.opacity = '0.5';
                endTurnBtn.style.cursor = 'not-allowed';
            } else {
                endTurnBtn.style.opacity = '1';
                endTurnBtn.style.cursor = 'pointer';
            }
            
            console.log(`ğŸ”„ í„´ ì¢…ë£Œ ë²„íŠ¼ - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${isMyTurn}, í„´ ì§„í–‰ì¤‘: ${state.turnInProgress}, ê²Œì„ì¢…ë£Œ: ${state.isGameOver}, ë¹„í™œì„±í™”: ${endTurnBtn.disabled}`);
        }

        async function handleSpellCast(spellNumber) {
            console.log(`ğŸ¯ ì˜ì°½ ì‹œë„: ${spellNumber}ë²ˆ`);
            
            // ì´ë¯¸ ì˜ì°½ ì§„í–‰ ì¤‘ì´ê±°ë‚˜ ë²„íŠ¼ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì¤‘ë‹¨
            if (state.turnInProgress || spellButtonsDisabled) {
                console.log('âŒ ì˜ì°½ ì§„í–‰ ì¤‘ ë˜ëŠ” ë²„íŠ¼ ë¹„í™œì„±í™” - ì¤‘ë³µ í´ë¦­ ë°©ì§€');
                return;
            }
            
            // ì—°ì† ì˜ì°½ ê·œì¹™ ê²€ì¦ (ê°•í™”ëœ ê²€ì¦)
            if (state.lastSuccessfulSpell > 0 && spellNumber < state.lastSuccessfulSpell) {
                console.log(`âŒ ì—°ì† ì˜ì°½ ê·œì¹™ ìœ„ë°˜: ${spellNumber} < ${state.lastSuccessfulSpell}`);
                return;
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜„ì¬ í”Œë ˆì´ì–´ì˜ í„´ì¼ ë•Œë§Œ í™œì„±í™”
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” currentPlayerIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ í„´ íŒë‹¨
            let isMyTurn;
            if (multiplayerMode) {
                isMyTurn = (state.currentPlayerId === myPlayerId);
                // state.isPlayerTurnê³¼ currentPlayerIdê°€ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë™ê¸°í™”
                if (state.isPlayerTurn !== isMyTurn) {
                    state.isPlayerTurn = isMyTurn;
                }
            } else {
                isMyTurn = state.isPlayerTurn;
            }
            
            if (!isMyTurn || state.turnInProgress || state.isGameOver) {
                console.log('âŒ ì˜ì°½ ì‹œë„ ì‹¤íŒ¨ - ì¡°ê±´ ë¶ˆë§Œì¡±');
                return;
            }
            
            // ì£¼ë¬¸ ë²„íŠ¼ ì¦‰ì‹œ ë¹„í™œì„±í™”
            disableSpellButtons();
            state.turnInProgress = true;
            updateButtons();
            
            // í„´ ì¢…ë£Œ ë²„íŠ¼ë„ ë¹„í™œì„±í™”
            endTurnBtn.disabled = true;
            endTurnBtn.style.opacity = '0.5';
            endTurnBtn.style.cursor = 'not-allowed';
            
            // í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ ì°¾ê¸°
            const currentPlayer = state.players.find(p => p.id === state.currentPlayerId);
            
            // í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì˜ íŒ¨ì—ì„œ ì¹´ë“œ ì°¾ê¸°
            const handIndex = currentPlayer.hand.indexOf(spellNumber);
            
            console.log(`ğŸ” ì†íŒ¨ì—ì„œ ${spellNumber} ì°¾ê¸°:`, {
                playerId: currentPlayer.id,
                hand: currentPlayer.hand,
                foundIndex: handIndex,
                hasCard: handIndex > -1
            });
            
            if (handIndex > -1) {
                const castedStone = currentPlayer.hand.splice(handIndex, 1)[0];
                state.usedStones.push(castedStone);
                console.log(`âœ… ì˜ì°½ ì„±ê³µ! ì‚¬ìš©ëœ ì£¼ë¬¸: ${castedStone}`);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    const myPlayerId = isHost ? 1 : 2;
                    dataChannel.send(JSON.stringify({
                        type: 'cardPlayed',
                        card: spellNumber,
                        playerId: myPlayerId,
                        gameState: state
                    }));
                }
                
                // ì„±ê³µ íš¨ê³¼
                playSuccessSound();
                addSuccessAnimation(myArea);
                
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                addLog(Messages.spellSuccess(state.players[myPlayerId - 1].name, spellNumber));
                
                // ë¨¼ì € lastSuccessfulSpell ì—…ë°ì´íŠ¸
                state.lastSuccessfulSpell = spellNumber;
                console.log(`ğŸ“Š ì—°ì† ì˜ì°½ ì—…ë°ì´íŠ¸: ${spellNumber}ë²ˆ (ì´ì œ ${spellNumber}ë²ˆ ì´ìƒë§Œ ì‚¬ìš© ê°€ëŠ¥)`);
                
                render();
                await executeSpellEffect(myPlayerId, spellNumber);
                
                // ì„±ê³µí•œ ê²½ìš° ì—°ì† ì˜ì°½ ê°€ëŠ¥í•˜ë„ë¡ í„´ ìœ ì§€
                state.turnInProgress = false;
                
                // ë²„íŠ¼ ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                updateButtons();
                
                // ì„±ê³µ ì‹œì—ë„ ì•ˆì „ ì‹œê°„ í›„ ë²„íŠ¼ í™œì„±í™”
                setTimeout(() => {
                    enableSpellButtons();
                    // ë²„íŠ¼ í™œì„±í™” í›„ ë‹¤ì‹œ í•œ ë²ˆ ìƒíƒœ í™•ì¸
                    updateButtons();
                }, 500); // 0.5ì´ˆ ì•ˆì „ ì‹œê°„
                
                // ì—°ì† ì˜ì°½ ì‹œ íƒ€ì´ë¨¸ ê³„ì† ìœ ì§€ (ì¬ì‹œì‘í•˜ì§€ ì•ŠìŒ)
                console.log('ğŸ’¡ ì—°ì† ì˜ì°½ ì„±ê³µ - íƒ€ì´ë¨¸ ê³„ì† ìœ ì§€');
                
                // ì—°ì† ì˜ì°½ ì•ˆë‚´ ë©”ì‹œì§€
                                    addLog(`ğŸ’¡ ${spellNumber}ë²ˆ ì´ìƒ ì—°ì† ì˜ì°½ ê°€ëŠ¥`);
                return;
            } else {
                // í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì˜ ì²´ë ¥ ê°ì†Œ
                const currentPlayer = state.players.find(p => p.id === state.currentPlayerId);
                currentPlayer.health--;
                console.log(`âŒ ì˜ì°½ ì‹¤íŒ¨! í”Œë ˆì´ì–´ ${currentPlayer.id} ì²´ë ¥ ê°ì†Œ: ${currentPlayer.health}`);
                
                // ì‹¤íŒ¨ íš¨ê³¼
                playFailureSound();
                addFailureAnimation(myArea);
                showDamageEffect(myArea, 1);
                
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ì‹¤íŒ¨ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'spellFailed',
                        spell: spellNumber,
                        playerId: myPlayerId,
                        gameState: state
                    }));
                }
                
                                    addLog(Messages.spellFailure(state.players[myPlayerId - 1].name, spellNumber));
                render();
                
                // ì²´ë ¥ ê°ì†Œ í›„ ë°”ë¡œ ê²Œì„ ì¢…ë£Œ ì²´í¬
                if (checkGameOver()) return;
                
                // ì‹¤íŒ¨ ì‹œì—ë„ ì•ˆì „ ì‹œê°„ í›„ ë²„íŠ¼ í™œì„±í™”
                setTimeout(() => {
                    enableSpellButtons();
                }, 500); // 0.5ì´ˆ ì•ˆì „ ì‹œê°„
                
                await sleep(1000);
                endTurn();
                return;
            }
        }

        // í„´ ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function switchToNextPlayer() {
            const currentPlayerName = state.currentPlayerId === 1 ? state.players[0].name : (multiplayerMode ? state.players[1].name : 'AI');
            addLog(Messages.turnEnd(currentPlayerName));
            state.lastSuccessfulSpell = 0;
            state.currentPlayerId = state.currentPlayerId === 1 ? 2 : 1;
            
            if (multiplayerMode) {
                const myPlayerId = isHost ? 1 : 2;
                state.isPlayerTurn = (state.currentPlayerId === myPlayerId);
            } else {
                state.isPlayerTurn = !state.isPlayerTurn;
            }
            }
            
        function sendTurnEndToOpponent() {
            if (GameConditions.isMultiplayerConnected()) {
                console.log('ğŸ“¤ í„´ ì¢…ë£Œ ë©”ì‹œì§€ ì „ì†¡');
                dataChannel.send(JSON.stringify({
                    type: 'turnEnd',
                    gameState: state,
                    currentPlayerId: state.currentPlayerId,
                    isPlayerTurn: state.isPlayerTurn
                }));
            }
        }

        function startNextTurn() {
            if (!state.isPlayerTurn && !multiplayerMode) {
                startTurnTimer();
                aiTurn();
            } else if (!state.isPlayerTurn && multiplayerMode) {
                const opponentName = state.players[1].name;
                addLog(Messages.turnStart(opponentName));
                startTurnTimer();
            } else if (state.isPlayerTurn) {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                const myName = state.players[myPlayerId - 1].name;
                addLog(Messages.turnStart(myName));
                startTurnTimer();
                
                if (multiplayerMode) {
                    console.log('ğŸ¯ ë‚´ í„´ ì‹œì‘ - ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
                    setTimeout(() => {
                        safeRefreshGameState();
                    }, 500);
                }
            }
        }

        function endTurn() {
            console.log('ğŸ”„ í„´ ì¢…ë£Œ');
            if (state.isGameOver) return;
            
            if (!GameConditions.isGameValid()) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ í„´ ì¢…ë£Œë¥¼ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            stopTurnTimer();
            switchToNextPlayer();
            sendTurnEndToOpponent();
            
            render();
            updateButtons();
            
            if (checkGameOver()) return;
            startNextTurn();
        }

        // ì£¼ë¬¸ íš¨ê³¼ í•¨ìˆ˜ë“¤
        async function executeMeditation(player, opponent) {
                    console.log('ğŸ§˜ ëª…ìƒ íš¨ê³¼ ì‹¤í–‰');
                    if (state.secretStones.length > 0) {
                        const revealedStone = state.secretStones.splice(0, 1)[0];
                        state.publiclyRevealedSecretStones.push(revealedStone);
                        console.log(`ğŸ§˜ ë¹„ë°€ ì£¼ë¬¸ ì „ì²´ ê³µê°œ: ${revealedStone}`);
                addLog(Messages.meditate(revealedStone));
                        const icon = SpellIcons[revealedStone] || 'â“';
                        await showModal('ëª…ìƒ', `ë¹„ë°€ ì£¼ë¬¸ [${icon}${revealedStone}]${getJosa(revealedStone.toString(), 'ì´/ê°€')} ì „ì²´ ê³µê°œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    } else {
                        const message = 'ëª…ìƒ ì¢…ë£Œ: ë” ì´ìƒ ê³µê°œí•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.';
                        console.log('ğŸ§˜ ë” ì´ìƒ ê³µê°œí•  ë¹„ë°€ ì£¼ë¬¸ ì—†ìŒ');
                        addLog(message);
                        await showModal('ëª…ìƒ', message);
                    }
        }

        function executeHealPotion(player, opponent) {
                    console.log('ğŸ§ª ìƒëª… ë¬¼ì•½ íš¨ê³¼ ì‹¤í–‰');
            if (player.health < GAME_CONFIG.maxHealth) player.health++;
                    console.log(`ğŸ’š ìƒëª… ë¬¼ì•½ íšŒë³µ: ${player.name} ì²´ë ¥ ${player.health}`);
                    playHealSound();
                    showHealEffect(player.id === 1 ? myArea : opponentArea, 1);
            addLog(Messages.heal(player.name, 1));
        }

        function executeFireArrow(player, opponent) {
                    opponent.health--;
                    console.log(`ğŸ”¥ í™”ì—¼ í™”ì‚´: í”¼í•´ 1`);
                    playDamageSound();
                    showDamageEffect(opponent.id === 1 ? myArea : opponentArea, 1);
            addLog(Messages.damage(opponent.name, 1));
        }

        async function executeMindControl(player, opponent, playerId) {
                    console.log('ğŸŒ€ ì •ì‹  êµë€ íš¨ê³¼ ì‹¤í–‰');
                    if (state.secretStones.length > 0) {
                        const spyStone = state.secretStones.splice(0, 1)[0];
                        opponent.hand.push(spyStone);
                        opponent.hand.sort((a, b) => a - b);
                        console.log(`ğŸŒ€ ì •ì‹  êµë€ íˆ¬ì…: ${spyStone}ì„(ë¥¼) ${opponent.name}ì˜ íŒ¨ì— íˆ¬ì…`);
                        playCardSound();
                        
                        const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                addLog(Messages.spy(player.name));
                
                        if (playerId === myPlayerId) {
                            await showModal('ì •ì‹  êµë€', `ë¹„ë°€ ì£¼ë¬¸ í•˜ë‚˜ë¥¼ ìƒëŒ€ì˜ íŒ¨ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
                        } else {
                            await showModal('ì •ì‹  êµë€', `ë¹„ë°€ ì£¼ë¬¸ í•˜ë‚˜ê°€ íŒ¨ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        }
                    } else {
                        console.log('âŒ íˆ¬ì…í•  ë¹„ë°€ ì£¼ë¬¸ ì—†ìŒ');
                        addLog(`ì •ì‹  êµë€ ì¢…ë£Œ: íˆ¬ì…í•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.`);
                        await showModal('ì •ì‹  êµë€', 'íˆ¬ì…í•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
        }

        function executeManaDrain(player, opponent) {
                    opponent.health--;
            if (player.health < GAME_CONFIG.maxHealth) player.health++;
                    console.log(`ğŸ’« ë§ˆë ¥ ì°©ì·¨: ${opponent.name} ì²´ë ¥ ${opponent.health}, ${player.name} ì²´ë ¥ ${player.health}`);
                    playDamageSound();
                    playHealSound();
                    showDamageEffect(opponent.id === 1 ? myArea : opponentArea, 1);
                    showHealEffect(player.id === 1 ? myArea : opponentArea, 1);
            addLog(Messages.damage(opponent.name, 1) + ' + ' + Messages.heal(player.name, 1));
        }

        async function executeDestinyChange(player, opponent) {
                    console.log('ğŸ”® ìš´ëª… ë³€í™˜ íš¨ê³¼ ì‹¤í–‰');
                    const toRevealCount = Math.min(3, state.secretStones.length);
                    if (toRevealCount > 0) {
                        const revealedStones = state.secretStones.splice(0, toRevealCount);
                        state.publiclyRevealedSecretStones.push(...revealedStones);
                        console.log(`ğŸ”® ê³µê°œëœ ì£¼ë¬¸: [${revealedStones.join(', ')}]`);
                addLog(Messages.reveal(revealedStones));
                        
                        // ê³µê°œëœ ì£¼ë¬¸ë“¤ì˜ ì•„ì´ì½˜ê³¼ í•¨ê»˜ íŒì—… í‘œì‹œ
                        const revealedIcons = revealedStones.map(stone => `${SpellIcons[stone] || 'â“'}${stone}`).join(', ');
                        await showModal('ìš´ëª… ë³€í™˜', `ë¹„ë°€ ì£¼ë¬¸ [${revealedIcons}]${getJosa(revealedStones.length.toString(), 'ì´/ê°€')} ê³µê°œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    } else {
                        await showModal('ìš´ëª… ë³€í™˜', 'ê³µê°œí•  ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
        }

        // ì£¼ë¬¸ íš¨ê³¼ ì‹¤í–‰ í•¨ìˆ˜
        async function executeSpellEffect(playerId, spellNumber) {
            console.log(`âœ¨ ì˜ì°½ íš¨ê³¼ ì‹¤í–‰: í”Œë ˆì´ì–´ ${playerId}, ì˜ì°½ ${spellNumber}`);
            
            if (!GameConditions.isGameValid()) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ì˜ì°½ íš¨ê³¼ ì‹¤í–‰ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const player = state.players.find(p => p.id === playerId);
            const opponent = state.players.find(p => p.id !== playerId);
            
            if (!player || !opponent) {
                console.log('âš ï¸ í”Œë ˆì´ì–´ ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ì˜ì°½ íš¨ê³¼ ì‹¤í–‰ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const spellEffects = {
                6: () => executeMeditation(player, opponent),
                5: () => executeHealPotion(player, opponent),
                4: () => executeFireArrow(player, opponent),
                3: () => executeMindControl(player, opponent, playerId),
                2: () => executeManaDrain(player, opponent),
                1: () => executeDestinyChange(player, opponent)
            };
            
            const effect = spellEffects[spellNumber];
            if (effect) {
                await effect();
            }
            
            render();
            await sleep(1000);
            checkGameOver();
            
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            if (state.currentPlayerId === myPlayerId && state.isPlayerTurn) {
                setTimeout(() => {
                    enableSpellButtons();
                }, 500);
            }
        }

        // AI í„´ ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function getAIName() {
            return multiplayerMode ? state.players[1].name : 
                   (aiDifficulty === 'easy' ? 'ì…ë¬¸ìš© í—ˆìˆ˜ì•„ë¹„' : 
                    aiDifficulty === 'normal' ? 'í›ˆë ¨ìš© í—ˆìˆ˜ì•„ë¹„' : 'ê³ ìˆ˜ìš© í—ˆìˆ˜ì•„ë¹„');
        }

        function getCastableSpells(ai) {
            return ai.hand.filter(s => s >= state.lastSuccessfulSpell);
        }

        async function executeAISpell(ai, player, chosenSpell, opponentName) {
                const handIndex = ai.hand.indexOf(chosenSpell);
                const successRate = getAISuccessRate();
            
                if (Math.random() < successRate && handIndex > -1) {
                return await handleAISpellSuccess(ai, chosenSpell, opponentName);
            } else {
                return await handleAISpellFailure(ai, chosenSpell, opponentName);
            }
        }

        async function handleAISpellSuccess(ai, chosenSpell, opponentName) {
            const castedStone = ai.hand.splice(ai.hand.indexOf(chosenSpell), 1)[0];
                    state.usedStones.push(castedStone);
                    console.log(`âœ… ${opponentName} ì˜ì°½ ì„±ê³µ: ${chosenSpell}ë²ˆ (ì‚¬ìš©ëœ ì£¼ë¬¸: ${castedStone})`);
                    
                    playSuccessSound();
                    addSuccessAnimation(opponentArea);
            addLog(Messages.spellSuccess(opponentName, chosenSpell));
                    render();
            
                    await executeSpellEffect(2, chosenSpell);
                    state.lastSuccessfulSpell = chosenSpell;
                    
            if (GameConditions.isMultiplayerConnected()) {
                        dataChannel.send(JSON.stringify({
                            type: 'cardPlayed',
                            card: chosenSpell,
                            playerId: 2,
                            gameState: state
                        }));
                    }
                    
            return true;
        }

        async function handleAISpellFailure(ai, chosenSpell, opponentName) {
                    const currentPlayer = state.players.find(p => p.id === state.currentPlayerId);
                    currentPlayer.health--;
                    console.log(`âŒ ${opponentName} ì˜ì°½ ì‹¤íŒ¨: ${chosenSpell}ë²ˆ (í”Œë ˆì´ì–´ ${currentPlayer.id} ì²´ë ¥: ${currentPlayer.health})`);
                    
                    playFailureSound();
                    addFailureAnimation(opponentArea);
                    showDamageEffect(opponentArea, 1);
            addLog(Messages.spellFailure(opponentName, chosenSpell));
                    render();
                    
            if (GameConditions.isMultiplayerConnected()) {
                        dataChannel.send(JSON.stringify({
                            type: 'spellPlayed',
                            spell: chosenSpell,
                            playerId: 2,
                            gameState: state
                        }));
                    }
                    
            return false;
        }

        function shouldAIContinue(ai, opponentName) {
            const continueTurn = ai.hand.length > 0 && Math.random() < getAIContinueRate();
            console.log(`ğŸ¤– ${opponentName} ì—°ì† ì˜ì°½ ê²°ì •: ${continueTurn ? 'ê³„ì†' : 'ì¤‘ë‹¨'} (í™•ë¥ : ${Math.random()})`);
            if (!continueTurn) {
                addLog(`${opponentName}${getJosa(opponentName, 'ì´/ê°€')} ì—°ì† ì˜ì°½ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.`);
            }
            return continueTurn;
        }

        async function aiTurn() {
            if (!GameConditions.isGameValid()) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ AI í„´ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }
            
            const opponentName = getAIName();
            console.log(`ğŸ¤– ${opponentName} í„´ ì‹œì‘ (ë‚œì´ë„: ${aiDifficulty})`);
            addLog(Messages.turnStart(opponentName));
            state.turnInProgress = true;
            updateButtons();

            let continueTurn = true;
            while(continueTurn && !state.isGameOver) {
                await sleep(1500);
                
                const ai = state.players[1];
                const player = state.players[0];
                const castableSpells = getCastableSpells(ai);
                
                console.log(`ğŸ¤– AI ê°€ëŠ¥í•œ ì˜ì°½: [${castableSpells.join(', ')}] (ë§ˆì§€ë§‰ ì„±ê³µ: ${state.lastSuccessfulSpell})`);

                if (castableSpells.length === 0) {
                    console.log(`ğŸ¤– ${opponentName} ì‹¤í–‰ ê°€ëŠ¥í•œ ì˜ì°½ ì—†ìŒ`);
                    addLog(`${opponentName}${getJosa(opponentName, 'ì´/ê°€')} ì‹œì „í•  ìˆ˜ ìˆëŠ” ì˜ì°½ì´ ì—†ìŠµë‹ˆë‹¤.`);
                    break;
                }

                const chosenSpell = chooseAISpell(castableSpells, ai, player);
                console.log(`ğŸ¤– AI ì„ íƒí•œ ì˜ì°½: ${chosenSpell} (í”Œë ˆì´ì–´ ì²´ë ¥: ${player.health}, AI ì²´ë ¥: ${ai.health})`);
                
                const success = await executeAISpell(ai, player, chosenSpell, opponentName);
                
                if (checkGameOver()) break;
                
                if (success) {
                    continueTurn = shouldAIContinue(ai, opponentName);
                } else {
                    continueTurn = false;
                }
            }
            
            state.turnInProgress = false;
            endTurn();
        }
        
        // AI ì˜ì°½ ì„ íƒ í•¨ìˆ˜ (ë‚œì´ë„ë³„)
        function chooseAISpell(castableSpells, ai, player) {
            const aiStrategies = {
                easy: chooseEasyAISpell,
                normal: chooseNormalAISpell,
                hard: chooseHardAISpell
            };
            
            const strategy = aiStrategies[aiDifficulty] || chooseNormalAISpell;
            return strategy(castableSpells, ai, player);
        }
        
        // ì‰¬ìš´ AI ì˜ì°½ ì„ íƒ
        function chooseEasyAISpell(castableSpells, ai, player) {
            // ëœë¤í•˜ê²Œ ì„ íƒí•˜ê±°ë‚˜ ê°„ë‹¨í•œ ê·œì¹™ë§Œ ì‚¬ìš©
            if (Math.random() < 0.3) {
                return castableSpells[Math.floor(Math.random() * castableSpells.length)];
            }
            
            // ê¸°ë³¸ì ì¸ ê·œì¹™ë§Œ ì ìš©
            if (castableSpells.includes(4) && player.health <= 1) return 4;
            if (castableSpells.includes(5) && ai.health <= 2) return 5;
            
            return Math.max(...castableSpells);
        }
        
        // ë³´í†µ AI ì˜ì°½ ì„ íƒ (ê¸°ì¡´ ë¡œì§)
        function chooseNormalAISpell(castableSpells, ai, player) {
            if (castableSpells.includes(4) && player.health <= (state.lastSuccessfulSpell > 0 ? 2 : 1)) return 4;
            if (castableSpells.includes(2) && player.health <= 1) return 2;
            if (castableSpells.includes(5) && player.health <= 1) return 5;
            if (ai.health <= 2 && castableSpells.includes(1)) return 1;
            if (ai.health <= 2 && castableSpells.includes(2)) return 2;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            return Math.max(...castableSpells);
        }
        
        // ì–´ë ¤ìš´ AI ì˜ì°½ ì„ íƒ
        function chooseHardAISpell(castableSpells, ai, player) {
            // ê³µê²© ìš°ì„  (í”Œë ˆì´ì–´ ì²´ë ¥ì´ ë‚®ì„ ë•Œ)
            if (castableSpells.includes(4) && player.health <= 2) return 4;
            if (castableSpells.includes(2) && player.health <= 2) return 2;
            
            // íšŒë³µ ìš°ì„  (AI ì²´ë ¥ì´ ë‚®ì„ ë•Œ)
            if (ai.health <= 2 && castableSpells.includes(1)) return 1;
            if (ai.health <= 2 && castableSpells.includes(5)) return 5;
            
            // ì „ì„¸ ì—­ì „ (ìƒí™©ì´ ì¢‹ì§€ ì•Šì„ ë•Œ)
            if (ai.health <= 2 && castableSpells.includes(1)) return 1;
            
            // ì •ì°° ì‘ì „ (ì •ë³´ ìˆ˜ì§‘)
            if (castableSpells.includes(6) && state.secretStones.length > 0) return 6;
            
            // ìŠ¤íŒŒì´ íˆ¬ì… (ìƒëŒ€ íŒ¨ êµë€)
            if (castableSpells.includes(3) && state.secretStones.length > 0) return 3;
            
            return Math.max(...castableSpells);
        }
        
        // AI ì„±ê³µë¥  ë°˜í™˜ (ë‚œì´ë„ë³„)
        function getAISuccessRate() {
            return GAME_CONFIG.aiSuccessRate[aiDifficulty] || GAME_CONFIG.aiSuccessRate.normal;
        }
        
        // AI ì—°ì† ì˜ì°½ í™•ë¥  ë°˜í™˜ (ë‚œì´ë„ë³„)
        function getAIContinueRate() {
            return GAME_CONFIG.aiContinueRate[aiDifficulty] || GAME_CONFIG.aiContinueRate.normal;
        }

        function checkGameOver() {
            if (!GameConditions.isGameValid() || !state.players[0] || !state.players[1]) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ê²Œì„ ì¢…ë£Œ ì²´í¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤');
                return false;
            }
            
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const myPlayer = state.players.find(p => p.id === myPlayerId);
            const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
            
            let winner = null;
            
            console.log('ğŸ ê²Œì„ ì¢…ë£Œ ì²´í¬:', {
                myPlayerId: myPlayerId,
                myHealth: myPlayer.health,
                opponentHealth: opponentPlayer.health,
                myHandLength: myPlayer.hand.length,
                opponentHandLength: opponentPlayer.hand.length
            });
            
            // ì²´ë ¥ì´ 0 ì´í•˜ì¸ ê²½ìš°ê°€ ìš°ì„  (íŒ¨ë°° ì¡°ê±´)
            if (myPlayer.health <= 0) {
                winner = opponentPlayer;
            } else if (opponentPlayer.health <= 0) {
                winner = myPlayer;
            } else if (myPlayer.hand.length === 0) {
                // íŒ¨ê°€ ë¹„ì—ˆì§€ë§Œ ì²´ë ¥ì´ ë‚¨ì•„ìˆìœ¼ë©´ ìŠ¹ë¦¬
                winner = myPlayer;
            } else if (opponentPlayer.hand.length === 0) {
                // ìƒëŒ€ íŒ¨ê°€ ë¹„ì—ˆì§€ë§Œ ì²´ë ¥ì´ ë‚¨ì•„ìˆìœ¼ë©´ ìŠ¹ë¦¬
                winner = opponentPlayer;
            }
            
            if (winner && !state.isGameOver) {
                state.isGameOver = true;
                
                // ê²Œì„ ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
                stopTurnTimer();
                resetTurnGauge();
                
                // ìŠ¹ë¦¬/íŒ¨ë°° ë©”ì‹œì§€ ìƒì„±
                const isPlayerWin = winner.id === myPlayerId;
                let message;
                
                if (isPlayerWin) {
                    // ë‚´ê°€ ìŠ¹ë¦¬í•œ ê²½ìš°
                    if (opponentPlayer.health <= 0) {
                        message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!';
                    } else if (myPlayer.hand.length === 0) {
                        message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!';
                    } else {
                        message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ê°€ ë„ë§ì³¤ìŠµë‹ˆë‹¤!';
                    }
                } else {
                    // ë‚´ê°€ íŒ¨ë°°í•œ ê²½ìš°
                    if (myPlayer.health <= 0) {
                        message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìì‹ ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    } else if (opponentPlayer.hand.length === 0) {
                        message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìƒëŒ€ê°€ ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.';
                    } else {
                        message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ë„ë§ì¹˜ê³  ë§ì•˜ìŠµë‹ˆë‹¤.';
                    }
                }
                console.log(`ğŸ† ê²Œì„ ì¢…ë£Œ: ${winner.name} ìŠ¹ë¦¬!`);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ê²Œì„ ì¢…ë£Œ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'gameOver',
                        winner: winner.id,
                        gameState: state
                    }));
                }
                
                // ì „ì  ì—…ë°ì´íŠ¸
                updateStats(isPlayerWin, multiplayerMode);
                
                                // ì—°ìŠ¹ ì²˜ë¦¬ (ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ ì—¬ê¸°ì„œë§Œ ì²˜ë¦¬)
                if (isPlayerWin) {
                    currentWinStreak++;
                    if (currentWinStreak > maxWinStreak) {
                        maxWinStreak = currentWinStreak;
                        localStorage.setItem('maxWinStreak', maxWinStreak.toString());
                    }
                    localStorage.setItem('currentWinStreak', currentWinStreak.toString());
                    
                    // 2ì—°ìŠ¹ ì´ìƒì¼ ë•Œ ì—°ìŠ¹ ë©”ì‹œì§€ ì¶”ê°€
                    if (currentWinStreak >= 2) {
                        message += `\n\n${Messages.streak(currentWinStreak)}`;
                    }
                } else {
                    // íŒ¨ë°° ì‹œ ì—°ìŠ¹ ì´ˆê¸°í™”
                    currentWinStreak = 0;
                    localStorage.setItem('currentWinStreak', '0');
                }
                
                // ìŠ¹ë¦¬ì˜ ì¦í‘œ ì—…ë°ì´íŠ¸
                if (isPlayerWin) {
                    if (multiplayerMode) {
                        TrophySystem.addVictoryTrophy('multiplayer');
                    } else {
                        TrophySystem.addVictoryTrophy('ai');
                    }
                } else {
                    if (multiplayerMode) {
                        TrophySystem.addDefeatTrophy('multiplayer');
                    } else {
                        TrophySystem.addDefeatTrophy('ai');
                    }
                }
                
                // ìŠ¹ì  ë³€í™” ë©”ì‹œì§€ ì¶”ê°€
                const trophyType = multiplayerMode ? 'multiplayer' : 'ai';
                const trophyChange = isPlayerWin ? '+3' : '-1';
                const trophyMessage = `\n\nğŸ… ìŠ¹ì  ${trophyChange}`;
                message += trophyMessage;
                
                // ìŠ¹ë¦¬/íŒ¨ë°° ì‚¬ìš´ë“œ
                playGameOverSound(winner.id === myPlayerId);
                
                showModal('ê²Œì„ ì¢…ë£Œ', message, true);
                addLog(`- ê²Œì„ ì¢…ë£Œ: ${winner.name} ìŠ¹ë¦¬! -`);
                render();
                return true;
            }
            return false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ë””ë²„ê·¸ í•¨ìˆ˜ë“¤
        function showDebugInfo() {
            const player = state.players[0];
            const ai = state.players[1];
            debugInfo.innerHTML = `
                <div>í”Œë ˆì´ì–´ ì²´ë ¥: ${player.health}</div>
                <div>AI ì²´ë ¥: ${ai.health}</div>
                <div>í”Œë ˆì´ì–´ ì†íŒ¨: [${player.hand.join(', ')}]</div>
                <div>AI ì†íŒ¨: [${ai.hand.join(', ')}]</div>
                <div>ë¹„ë°€ ì „ìˆ : ${state.secretStones.length}ê°œ</div>
                <div>ì‚¬ìš©í•œ ì „ìˆ : ${state.usedStones.length}ê°œ</div>
                <div>ë§ˆì§€ë§‰ ì„±ê³µ ì „ëµ: ${state.lastSuccessfulSpell}</div>
                <div>ê²Œì„ ì¢…ë£Œ: ${state.isGameOver}</div>
            `;
        }

        function showPlayerHand() {
            const player = state.players[0];
            showCardListModal('í”Œë ˆì´ì–´ ì†íŒ¨', player.hand, true);
        }

        function showAIHand() {
            const ai = state.players[1];
            showCardListModal('AI ì†íŒ¨', ai.hand, true);
        }

        function showCardListModal(title, cards, showNumbers = false) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">${title}</h3>
                    ${cards.length > 0 ? `
                    <div class="grid grid-cols-4 gap-2 mb-4">
                        ${cards.sort((a, b) => a - b).map((card, index) => `
                            <div class="card card-front flex flex-col items-center justify-center text-sm">
                                <div class="text-lg">${getSpellIcon(card)}</div>
                                <div class="text-xs">${card}</div>
                                ${showNumbers ? `<div class="text-xs opacity-75">#${index + 1}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    ` : `
                        <div class="text-center mb-4 text-gray-400">
                            <div class="text-4xl mb-2">ğŸ“­</div>
                            <p>ì•„ì§ ì‚¬ìš©ëœ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                        </div>
                    `}
                    <button class="w-full py-2 rounded-lg font-bold btn-primary">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showCombinedSecretStonesModal() {
            const revealedStones = state.publiclyRevealedSecretStones;
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-lg w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸ ëª©ë¡</h3>
                    ${revealedStones.length > 0 ? `
                        <div class="grid grid-cols-4 gap-2 mb-4">
                            ${revealedStones.map(stone => `
                                <div class="card card-front flex flex-col items-center justify-center text-sm">
                                    <div class="text-lg">${getSpellIcon(stone)}</div>
                                    <div class="text-xs">${stone}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : `
                        <p class="text-center mb-4 text-gray-400">ì•„ì§ ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                    `}
                    <button class="w-full py-2 rounded-lg font-bold btn-primary">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showCardChoiceModal(title, message, cards, isHand = false) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
                modal.innerHTML = `
                    <div class="modal-content p-6 rounded-lg max-w-lg w-full mx-4">
                        <h3 class="text-xl font-bold mb-2 text-center">${title}</h3>
                        <p class="text-center mb-4">${message}</p>
                        <div class="grid grid-cols-4 gap-2 mb-4">
                            ${cards.map((card, index) => `
                                <div class="card ${isHand ? 'card-front' : 'card-back'} flex flex-col items-center justify-center text-sm cursor-pointer hover:scale-105 transition-transform" data-card="${card}">
                                    <div class="text-lg">${isHand ? getSpellIcon(card) : '?'}</div>
                                    <div class="text-xs">${isHand ? card : 'ìˆ¨ê¹€'}</div>
                                </div>
                            `).join('')}
                        </div>
                        <button class="w-full py-2 rounded-lg font-bold btn-primary">ì·¨ì†Œ</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                playCardSound();
                
                const cardElements = modal.querySelectorAll('[data-card]');
                cardElements.forEach(cardEl => {
                    cardEl.addEventListener('click', () => {
                        const selectedCard = parseInt(cardEl.dataset.card);
                        document.body.removeChild(modal);
                        resolve(selectedCard);
                    });
                });
                
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
            });
        }

        function showChoiceModal(title, message, option1, option2) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
                modal.innerHTML = `
                    <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                        <h3 class="text-xl font-bold mb-2 text-center">${title}</h3>
                        <p class="text-center mb-4">${message}</p>
                        <div class="grid grid-cols-2 gap-4">
                            <button class="py-3 rounded-lg font-bold btn-primary" data-choice="${option1}">${option1}</button>
                            <button class="py-3 rounded-lg font-bold btn-primary" data-choice="${option2}">${option2}</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                playCardSound();
                
                const buttons = modal.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const choice = btn.dataset.choice;
                        document.body.removeChild(modal);
                        resolve(choice);
                    });
                });
            });
        }

        function showModal(title, message, isGameOver = false) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
                modal.innerHTML = `
                    <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                        <h3 class="text-xl font-bold mb-4 text-center">${title}</h3>
                        <p class="text-center mb-4">${message}</p>
                        <button class="w-full py-3 rounded-lg font-bold btn-primary">${isGameOver ? 'íƒ€ì´í‹€ë¡œ ëŒì•„ê°€ê¸°' : 'í™•ì¸'}</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                playCardSound();
                
                modal.querySelector('button').addEventListener('click', () => {
                    if (document.body.contains(modal)) {
                    document.body.removeChild(modal);
                    }
                    if (isGameOver) {
                        setTimeout(() => {
                            showTitleScreen();
                        }, 100);
                    }
                    resolve();
                });
            });
        }

        function resetGame() {
            console.log('ğŸ”„ ê²Œì„ ë¦¬ì…‹');
            
            // ê²Œì„ ì‹œì‘ ì‹œ íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
            stopTurnTimer();
            resetTurnGauge();
            
            // ì˜¬ë°”ë¥¸ ë± ìƒì„± (1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ, 3ë²ˆì€ 3ê°œ...)
            let deck = [];
            for (let spellNumber = 1; spellNumber <= GAME_CONFIG.deckStructure.maxSpell; spellNumber++) {
                for (let cardCount = 0; cardCount < GAME_CONFIG.deckStructure.cardsPerSpell(spellNumber); cardCount++) {
                    deck.push(spellNumber);
                }
            }
            console.log('ğŸ“¦ ì´ˆê¸° ë± ìƒì„±:', deck);
            
            // ë± ì…”í”Œ
            shuffleArray(deck);
            console.log('ğŸ”„ ë± ì…”í”Œ ì™„ë£Œ');
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ì„ ê²°ì •í•˜ê³  ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
            let firstPlayer;
            if (multiplayerMode && isHost) {
                // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” í˜¸ìŠ¤íŠ¸ê°€ í•­ìƒ 1ë²ˆ í”Œë ˆì´ì–´, ì²« í„´ë§Œ ëœë¤ ê²°ì •
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ í˜¸ìŠ¤íŠ¸ê°€ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer} (í˜¸ìŠ¤íŠ¸ëŠ” í•­ìƒ 1ë²ˆ)`);
                
                // ìƒëŒ€ë°©ì—ê²Œ ì²« ë²ˆì§¸ í„´ ì •ë³´ ì „ì†¡
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'firstTurn',
                        firstPlayer: firstPlayer
                    }));
                }
            } else if (multiplayerMode && !isHost) {
                // ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦¼
                console.log('â³ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì • ëŒ€ê¸° ì¤‘...');
                // ê²ŒìŠ¤íŠ¸ë„ ê¸°ë³¸ ê²Œì„ ìƒíƒœëŠ” ì´ˆê¸°í™”í•˜ë˜, ì²« ë²ˆì§¸ í„´ì€ í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ì„ ê¸°ë‹¤ë¦¼
                firstPlayer = 1; // ì„ì‹œê°’, í˜¸ìŠ¤íŠ¸ê°€ ê²°ì •í•œ ê°’ìœ¼ë¡œ ë®ì–´ì”Œì›Œì§
            } else {
                // AI ëª¨ë“œì—ì„œëŠ” ëœë¤ ê²°ì •
                firstPlayer = Math.random() < 0.5 ? 1 : 2;
                console.log(`ğŸ¯ AI ëª¨ë“œ ì²« ë²ˆì§¸ í„´ ê²°ì •: í”Œë ˆì´ì–´ ${firstPlayer}`);
            }
            
            const playerName = localStorage.getItem('playerName') || 'Player';
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            
            state = {
                players: [
                    { id: 1, name: playerName, health: GAME_CONFIG.maxHealth, hand: deck.slice(0, GAME_CONFIG.maxHandSize).sort((a, b) => a - b), knownSecretStones: [] },
                    { id: 2, name: multiplayerMode ? (opponentName || 'Player2') : 'AI', health: GAME_CONFIG.maxHealth, hand: deck.slice(GAME_CONFIG.maxHandSize, GAME_CONFIG.maxHandSize * 2).sort((a, b) => a - b), knownSecretStones: [] }
                ],
                secretStones: deck.slice(14),
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: firstPlayer,
                isPlayerTurn: multiplayerMode ? (firstPlayer === myPlayerId) : (firstPlayer === 1),
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                isGameOver: false,
                gameStarted: true,
                gameLog: [Messages.gameStart(firstPlayer === 1 ? playerName : (multiplayerMode ? (opponentName || 'Player2') : 'AI'))]
            };
            
            console.log(`ğŸ¯ ê²Œì„ ìƒíƒœ ì„¤ì • ì™„ë£Œ - í˜¸ìŠ¤íŠ¸: ${isHost}, ì²« í„´ í”Œë ˆì´ì–´: ${firstPlayer}, ë‚´ í”Œë ˆì´ì–´ ID: ${myPlayerId}, ë‚´ í„´: ${state.isPlayerTurn}`);
            
            console.log('ğŸ¯ ì´ˆê¸° ê²Œì„ ìƒíƒœ:', {
                playerHand: state.players[0].hand,
                aiHand: state.players[1].hand,
                secretStones: state.secretStones,
                totalCards: deck.length
            });
            
            createSpellButtons();
            updatePlayerName();
            render();
            updateButtons();
            
            // ì²« ë²ˆì§¸ í„´ íƒ€ì´ë¨¸ ì‹œì‘ (AI ë˜ëŠ” í”Œë ˆì´ì–´ ëª¨ë‘)
            setTimeout(() => {
                startTurnTimer();
                
                // AIê°€ ë¨¼ì € ì‹œì‘í•˜ëŠ” ê²½ìš° AI í„´ ì‹¤í–‰
                if (!state.isPlayerTurn && !multiplayerMode) {
                    aiTurn();
                }
            }, 1000);
        }

        // ì‚¬ìš´ë“œ íš¨ê³¼ í•¨ìˆ˜ë“¤ (ìƒë‹¨ì—ì„œ í†µí•©ëœ ë²„ì „ ì‚¬ìš©)
        // ì¤‘ë³µ ì œê±°ë¨ - ìƒë‹¨ì˜ playSoundEffect() í•¨ìˆ˜ ì‚¬ìš©

        // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ í•¨ìˆ˜ë“¤
        function addSuccessAnimation(element) {
            element.classList.add('success-animation');
            setTimeout(() => element.classList.remove('success-animation'), 500);
        }

        function addFailureAnimation(element) {
            element.classList.add('failure-animation');
            setTimeout(() => element.classList.remove('failure-animation'), 500);
        }

        function showDamageEffect(element, amount) {
            const damageEl = document.createElement('div');
            damageEl.className = 'card-damage';
            damageEl.textContent = `-${amount}`;
            element.appendChild(damageEl);
            setTimeout(() => element.removeChild(damageEl), 1000);
        }

        function showHealEffect(element, amount) {
            const healEl = document.createElement('div');
            healEl.className = 'card-heal';
            healEl.textContent = `+${amount}`;
            element.appendChild(healEl);
            setTimeout(() => element.removeChild(healEl), 1000);
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function shuffleArray(array) {
            for (let currentIndex = array.length - 1; currentIndex > 0; currentIndex--) {
                const randomIndex = Math.floor(Math.random() * (currentIndex + 1));
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ë§ˆë²• ë²ˆí˜¸ì— ë”°ë¥¸ ì•„ì´ì½˜ ë°˜í™˜ í•¨ìˆ˜
        function getSpellIcon(spellNumber) {
            const spellIcons = {
                1: 'ğŸ”®', // ìš´ëª… ë³€í™˜
                2: 'ğŸ’«', // ë§ˆë ¥ ì°©ì·¨
                3: 'ğŸŒ€', // ì •ì‹  êµë€
                4: 'ğŸ”¥', // í™”ì—¼ í™”ì‚´
                5: 'ğŸ§ª', // ìƒëª… ë¬¼ì•½
                6: 'ğŸ’¤'  // ëª…ìƒ
            };
            return spellIcons[spellNumber] || 'â“';
        }

        // ëª¨ë‹¬ í•¨ìˆ˜ë“¤
        function showCardListModal(title, cards, showNumbers = false) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">${title}</h3>
                    ${cards.length > 0 ? `
                    <div class="grid grid-cols-4 gap-2 mb-4">
                        ${cards.sort((a, b) => a - b).map((card, index) => `
                            <div class="card card-front flex flex-col items-center justify-center text-sm">
                                <div class="text-lg">${getSpellIcon(card)}</div>
                                <div class="text-xs">${card}</div>
                                ${showNumbers ? `<div class="text-xs opacity-75">#${index + 1}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    ` : `
                        <div class="text-center mb-4 text-gray-400">
                            <div class="text-4xl mb-2">ğŸ“­</div>
                            <p>ì•„ì§ ì‚¬ìš©ëœ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                        </div>
                    `}
                    <button class="w-full py-2 rounded-lg font-bold btn-primary">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showCombinedSecretStonesModal() {
            const revealedStones = state.publiclyRevealedSecretStones;
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-lg w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸ ëª©ë¡</h3>
                    ${revealedStones.length > 0 ? `
                        <div class="grid grid-cols-4 gap-2 mb-4">
                            ${revealedStones.sort((a, b) => a - b).map(stone => `
                                <div class="card card-front flex flex-col items-center justify-center text-sm">
                                    <div class="text-lg">${getSpellIcon(stone)}</div>
                                    <div class="text-xs">${stone}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : `
                        <p class="text-center mb-4 text-gray-400">ì•„ì§ ê³µê°œëœ ë¹„ë°€ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                    `}
                    <button class="w-full py-2 rounded-lg font-bold btn-primary">í™•ì¸</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                modal.querySelector('button').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }

        function showDebugInfo() {
            const player = state.players[0];
            const ai = state.players[1];
            debugInfo.innerHTML = `
                <div>í”Œë ˆì´ì–´ ì²´ë ¥: ${player.health}</div>
                <div>AI ì²´ë ¥: ${ai.health}</div>
                <div>í”Œë ˆì´ì–´ ì†íŒ¨: [${player.hand.join(', ')}]</div>
                <div>AI ì†íŒ¨: [${ai.hand.join(', ')}]</div>
                <div>ë¹„ë°€ ì „ìˆ : ${state.secretStones.length}ê°œ</div>
                <div>ì‚¬ìš©í•œ ì „ìˆ : ${state.usedStones.length}ê°œ</div>
                <div>ë§ˆì§€ë§‰ ì„±ê³µ ì „ëµ: ${state.lastSuccessfulSpell}</div>
                <div>ê²Œì„ ì¢…ë£Œ: ${state.isGameOver}</div>
            `;
        }

        function showPlayerHand() {
            const player = state.players[0];
            showCardListModal('í”Œë ˆì´ì–´ ì†íŒ¨', player.hand, true);
        }

        function showAIHand() {
            const ai = state.players[1];
            showCardListModal('AI ì†íŒ¨', ai.hand, true);
        }

        // ê²Œì„ ì„¤ì • ìƒìˆ˜
        const GAME_CONFIG = {
            maxHealth: 3,
            maxHandSize: 7,
            maxLogEntries: 20,
            turnDuration: {
                easy: Infinity,
                normal: 30,
                hard: 20,
                multiplayer: 30
            },
            aiSuccessRate: {
                easy: 0.7,
                normal: 0.95,
                hard: 0.98
            },
            aiContinueRate: {
                easy: 0.3,
                normal: 0.5,
                hard: 0.7
            },
            deckStructure: {
                maxSpell: 6,
                cardsPerSpell: (spell) => spell // 1ë²ˆì€ 1ê°œ, 2ë²ˆì€ 2ê°œ...
            }
        };

        // ì¡°ê±´ë¬¸ ë‹¨ìˆœí™”ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜ë“¤
        const GameConditions = {
            isMultiplayerConnected: () => multiplayerMode && dataChannel && dataChannel.readyState === 'open',
            isGameValid: () => state && state.players && state.players.length >= 2,
            isMyTurn: () => {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                return multiplayerMode ? (state.currentPlayerId === myPlayerId) : state.isPlayerTurn;
            },
            canPlaySpell: () => {
                const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                const isMyTurn = multiplayerMode ? (state.currentPlayerId === myPlayerId) : state.isPlayerTurn;
                return isMyTurn && !state.turnInProgress && !state.isGameOver;
            },
            isGameInProgress: () => multiplayerMode && state.gameStarted && !state.isGameOver
        };

        // ì£¼ë¬¸ ì•„ì´ì½˜ ì •ì˜
        const SpellIcons = {
            1: 'ğŸ”®', // ìš´ëª… ë³€í™˜
            2: 'ğŸ’«', // ë§ˆë ¥ ì°©ì·¨
            3: 'ğŸŒ€', // ì •ì‹  êµë€
            4: 'ğŸ”¥', // í™”ì—¼ í™”ì‚´
            5: 'ğŸ§ª', // ìƒëª… ë¬¼ì•½
            6: 'ğŸ’¤'  // ëª…ìƒ
        };

        // ë©”ì‹œì§€ í…œí”Œë¦¿
        const Messages = {
            spellSuccess: (name, spell) => `âœ… ${name} ${spell}ë²ˆ ì˜ì°½ ì„±ê³µ`,
            spellFailure: (name, spell) => `âŒ ${name} ${spell}ë²ˆ ì˜ì°½ ì‹¤íŒ¨`,
            turnStart: (name) => `ğŸ”„ ${name} í„´ ì‹œì‘`,
            turnEnd: (name) => `â¹ï¸ ${name} í„´ ì¢…ë£Œ`,
            timeOut: () => `â° ì‹œê°„ ì´ˆê³¼`,
            gameStart: (name) => `ğŸ® ${name} ê²Œì„ ì‹œì‘`,
            gameOver: (winner) => `ğŸ† ${winner} ìŠ¹ë¦¬`,
            damage: (name, amount) => `ğŸ’” ${name} ì²´ë ¥ -${amount}`,
            heal: (name, amount) => `ğŸ’š ${name} ì²´ë ¥ +${amount}`,
            reveal: (stones) => `ğŸ”® ë¹„ë°€ ì£¼ë¬¸ ê³µê°œ: ${stones.map(stone => `${SpellIcons[stone] || 'â“'}${stone}`).join(', ')}`,
            spy: (name) => `ğŸŒ€ ${name} ì •ì‹  êµë€`,
            meditate: (stone) => `ğŸ’¤ ëª…ìƒ: ${SpellIcons[stone] || 'â“'}${stone} ê³µê°œ`,
            surrender: (name) => `ğŸ³ï¸ ${name} ë„ë§`,
            streak: (count) => `ğŸ”¥ ${count}ì—°ìŠ¹`
        };

        function addLog(message) {
            console.log(`ğŸ“ ê²Œì„ ë¡œê·¸: ${message}`);
            
            // stateë‚˜ gameLogê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
            if (!state) {
                state = {};
            }
            if (!state.gameLog) {
                state.gameLog = [];
            }
            
            state.gameLog.unshift(message);
            if (state.gameLog.length > GAME_CONFIG.maxLogEntries) state.gameLog.pop();
        }

        // ë„ì›€ë§ íˆ´íŒ í•¨ìˆ˜ë“¤
        function showHelpTooltip() {
            const tooltip = DOM.get('help-tooltip');
            tooltip.classList.remove('hidden');
        }
        
        function hideHelpTooltip() {
            const tooltip = DOM.get('help-tooltip');
            tooltip.classList.add('hidden');
        }
        
        // ë©€í‹°í”Œë ˆì´ì–´ ê´€ë ¨ ë³€ìˆ˜ë“¤
        let multiplayerMode = false;
        let peerConnection = null;
        let dataChannel = null;
        let matchingInterval = null;
        let aiDifficulty = 'normal'; // 'easy', 'normal', 'hard'
        let isHost = false;
        let playerName = '';
        let opponentName = '';
        let myPlayerId = null;
        
        // Socket.IO ì—°ê²°
        let socket = null;
        let serverConnected = false;
        
        // ì „ì  ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function loadStats() {
            const stats = localStorage.getItem('tacticalCardBattleStats');
            if (stats) {
                const parsedStats = JSON.parse(stats);
                
                // ê¸°ì¡´ í˜•ì‹ê³¼ ìƒˆë¡œìš´ í˜•ì‹ í˜¸í™˜ì„± ì²˜ë¦¬
                if (parsedStats.wins !== undefined || parsedStats.losses !== undefined) {
                    console.log('ê¸°ì¡´ í˜•ì‹ ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.');
                    const newStats = {
                        ai: { 
                            wins: parsedStats.wins || 0, 
                            losses: parsedStats.losses || 0 
                        },
                        multiplayer: { wins: 0, losses: 0 }
                    };
                    // ìƒˆë¡œìš´ í˜•ì‹ìœ¼ë¡œ ì €ì¥
                    saveStats(newStats);
                    return newStats;
                }
                
                return parsedStats;
            }
            return { 
                ai: { wins: 0, losses: 0 },
                multiplayer: { wins: 0, losses: 0 }
            };
        }
        
        function saveStats(stats) {
            localStorage.setItem('tacticalCardBattleStats', JSON.stringify(stats));
        }
        
        function updateStats(isWin, isMultiplayer = false) {
            const stats = loadStats();
            const category = isMultiplayer ? 'multiplayer' : 'ai';
            
            if (isWin) {
                stats[category].wins++;
                currentWinStreak++;
                if (currentWinStreak > maxWinStreak) {
                    maxWinStreak = currentWinStreak;
                }
            } else {
                stats[category].losses++;
                currentWinStreak = 0;
            }
            
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
            localStorage.setItem('currentWinStreak', currentWinStreak.toString());
            localStorage.setItem('maxWinStreak', maxWinStreak.toString());
            saveStats(stats);
            
            // ì¦í‘œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const trophies = TrophySystem.loadTrophies();
            const trophyCount = isMultiplayer ? trophies.multiplayer : trophies.ai;
            
            // ì„œë²„ì— ë­í‚¹ ì—…ë°ì´íŠ¸ ìš”ì²­ (ì¦í‘œ ì •ë³´ í¬í•¨)
            const playerName = localStorage.getItem('playerName') || 'Player';
            if (socket) {
                socket.emit('updateRanking', {
                    category: category,
                    playerName: playerName,
                    stats: {
                        trophies: trophyCount,
                        wins: stats[category].wins,
                        losses: stats[category].losses,
                        currentWinStreak: currentWinStreak,
                        maxWinStreak: maxWinStreak
                    }
                });
            }
            
            console.log(`ğŸ“Š ì „ì  ì—…ë°ì´íŠ¸: ${category} - ${playerName} (ì¦í‘œ: ${trophyCount}, ìŠ¹ë¦¬: ${stats[category].wins}, íŒ¨ë°°: ${stats[category].losses})`);
        }
        
        function showRankingModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                    <h3 class="text-xl font-bold mb-4 text-center">ğŸ† ì˜¤ëŠ˜ì˜ ë§ˆë²•ì™•</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="text-lg font-bold mb-3 text-yellow-300 text-center">ğŸ¤– í—ˆìˆ˜ì•„ë¹„ê°€ ì œì¼ ë¬´ì„œì›Œí•˜ëŠ” ì‚¬ëŒë“¤</h4>
                            <div id="ai-ranking" class="space-y-2">
                                <div class="text-center text-gray-400">ë¡œë”© ì¤‘...</div>
                            </div>
                        </div>
                        <div>
                            <h4 class="text-lg font-bold mb-3 text-green-300 text-center">ğŸ‘¥ ë§ˆë²•ì‚¬ ë§ì§± ë­í‚¹</h4>
                            <div id="multiplayer-ranking" class="space-y-2">
                                <div class="text-center text-gray-400">ë¡œë”© ì¤‘...</div>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-center mt-4">
                        <button id="close-ranking-btn" class="px-6 py-2 rounded-lg font-bold btn-secondary">ë‹«ê¸°</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            // ë­í‚¹ ë°ì´í„° ìš”ì²­
            if (socket) {
                socket.emit('getRanking', { category: 'ai' });
                socket.emit('getRanking', { category: 'multiplayer' });
            }
            
            // ë­í‚¹ ë°ì´í„° ìˆ˜ì‹  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            const handleRankingData = (data) => {
                const rankingContainer = DOM.get(`${data.category}-ranking`);
                if (rankingContainer) {
                    if (data.ranking.length === 0) {
                        rankingContainer.innerHTML = '<div class="text-center text-gray-400">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    } else {
                        const rankingHtml = data.ranking.map((player, index) => {
                            const rank = index + 1;
                            const rankIcon = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : `${rank}.`;
                            const trophyIcon = 'ğŸ…';
                            return `
                                <div class="flex items-center justify-between p-3 bg-gray-800 bg-opacity-50 rounded-lg">
                                    <div class="flex items-center space-x-3">
                                        <span class="text-lg">${rankIcon}</span>
                                        <span class="font-bold">${player.name}</span>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-sm text-yellow-400">${trophyIcon} ${player.trophies || 0}ì¦í‘œ</div>
                                        <div class="text-sm text-green-400">${player.wins}ìŠ¹ ${player.losses}íŒ¨</div>
                                        <div class="text-xs text-blue-400">ìµœê³  ${player.maxWinStreak}ì—°ìŠ¹</div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                        rankingContainer.innerHTML = rankingHtml;
                    }
                }
            };
            
            // ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            if (socket) {
                socket.on('rankingData', handleRankingData);
            }
            
            return new Promise(resolve => {
                const closeBtn = modal.querySelector('#close-ranking-btn');
                
                closeBtn.addEventListener('click', () => {
                    if (socket) {
                        socket.off('rankingData', handleRankingData);
                    }
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }
        
        function showProfileModal() {
            const stats = loadStats();
            const aiStats = stats.ai;
            const multiplayerStats = stats.multiplayer;
            
            const aiTotalGames = aiStats.wins + aiStats.losses;
            const multiplayerTotalGames = multiplayerStats.wins + multiplayerStats.losses;
            
            const aiWinRate = aiTotalGames > 0 ? ((aiStats.wins / aiTotalGames) * 100).toFixed(1) : 0;
            const multiplayerWinRate = multiplayerTotalGames > 0 ? ((multiplayerStats.wins / multiplayerTotalGames) * 100).toFixed(1) : 0;
            
            const playerName = localStorage.getItem('playerName') || '';
            
            // ì¦í‘œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const trophies = TrophySystem.loadTrophies();
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-lg w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-center">ë§ˆë²• ì´ë ¥ì„œ</h3>
                    <div class="space-y-4">
                        <div class="text-left">
                            <label class="block text-sm font-bold mb-2">ì§€íŒ¡ì´ ì£¼ì¸ ì´ë¦„</label>
                            <div class="w-full px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white">
                                ${playerName || 'ì´ë¦„ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}
                            </div>
                        </div>
                        <div class="space-y-4">
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-yellow-300">ğŸ¤– í—ˆìˆ˜ì•„ë¹„ í•™ëŒ€ ê¸°ë¡</h4>
                                <div class="grid grid-cols-2 gap-4 mb-2">
                                    <div class="bg-emerald-600 bg-opacity-40 p-3 rounded-lg border border-emerald-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-emerald-100">${aiStats.wins}</div>
                                        <div class="text-xs text-emerald-50 font-semibold">ìŠ¹ë¦¬</div>
                                    </div>
                                    <div class="bg-rose-600 bg-opacity-40 p-3 rounded-lg border border-rose-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-rose-100">${aiStats.losses}</div>
                                        <div class="text-xs text-rose-50 font-semibold">íŒ¨ë°°</div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-cyan-600 bg-opacity-40 p-3 rounded-lg border border-cyan-400 border-opacity-30 shadow-lg">
                                        <div class="text-lg font-bold text-cyan-100">${aiTotalGames}ì „</div>
                                        <div class="text-xs text-cyan-50 font-semibold">ì´ ê²Œì„</div>
                                    </div>
                                    <div class="bg-violet-600 bg-opacity-40 p-3 rounded-lg border border-violet-400 border-opacity-30 shadow-lg">
                                        <div class="text-lg font-bold text-violet-100">${aiWinRate}%</div>
                                        <div class="text-xs text-violet-50 font-semibold">ìŠ¹ë¥ </div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-green-300">ğŸ‘¥ ì •ì‹ ë§ì§± ë°ì´í„°</h4>
                                <div class="grid grid-cols-2 gap-4 mb-2">
                                    <div class="bg-teal-600 bg-opacity-40 p-3 rounded-lg border border-teal-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-teal-100">${multiplayerStats.wins}</div>
                                        <div class="text-xs text-teal-50 font-semibold">ìŠ¹ë¦¬</div>
                                    </div>
                                    <div class="bg-pink-600 bg-opacity-40 p-3 rounded-lg border border-pink-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-pink-100">${multiplayerStats.losses}</div>
                                        <div class="text-xs text-pink-50 font-semibold">íŒ¨ë°°</div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-indigo-600 bg-opacity-40 p-3 rounded-lg border border-indigo-400 border-opacity-30 shadow-lg">
                                        <div class="text-lg font-bold text-indigo-100">${multiplayerTotalGames}ì „</div>
                                        <div class="text-xs text-indigo-50 font-semibold">ì´ ê²Œì„</div>
                                    </div>
                                    <div class="bg-fuchsia-600 bg-opacity-40 p-3 rounded-lg border border-fuchsia-400 border-opacity-30 shadow-lg">
                                        <div class="text-lg font-bold text-fuchsia-100">${multiplayerWinRate}%</div>
                                        <div class="text-xs text-fuchsia-50 font-semibold">ìŠ¹ë¥ </div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-orange-300">ğŸ”¥ ì—°ìŠ¹ ON</h4>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-amber-600 bg-opacity-40 p-3 rounded-lg border border-amber-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-amber-100">${maxWinStreak}ì—°ìŠ¹</div>
                                        <div class="text-xs text-amber-50 font-semibold">ìµœê³  ì—°ìŠ¹</div>
                                    </div>
                                    <div class="bg-lime-600 bg-opacity-40 p-3 rounded-lg border border-lime-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-lime-100">${currentWinStreak}ì—°ìŠ¹</div>
                                        <div class="text-xs text-lime-50 font-semibold">í˜„ì¬ ì—°ìŠ¹</div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <h4 class="text-lg font-bold mb-3 text-yellow-300">ğŸ† ìŠ¹ë¦¬ì˜ ì¦í‘œ</h4>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-yellow-600 bg-opacity-40 p-3 rounded-lg border border-yellow-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-yellow-100">ğŸ… ${trophies.ai}ê°œ</div>
                                        <div class="text-xs text-yellow-50 font-semibold">ëª¨ì˜ ê²°íˆ¬ ì ìˆ˜</div>
                                    </div>
                                    <div class="bg-red-600 bg-opacity-40 p-3 rounded-lg border border-red-400 border-opacity-30 shadow-lg">
                                        <div class="text-xl font-bold text-red-100">ğŸ… ${trophies.multiplayer}ê°œ</div>
                                        <div class="text-xs text-red-50 font-semibold">ì •ì‹ ê²°íˆ¬ ì ìˆ˜</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-center mt-4">
                        <button id="close-profile-btn" class="px-6 py-3 rounded-lg font-bold btn-secondary">ë‹«ê¸°</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                const closeBtn = modal.querySelector('#close-profile-btn');
                
                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve();
                });
            });
        }
        
        // ì¡°ì‚¬ ì²˜ë¦¬ í•¨ìˆ˜
        function getJosa(name, josa) {
            const lastName = name.charAt(name.length - 1);
            const hasBatchim = (lastName.charCodeAt(0) - 44032) % 28 !== 0;
            
            switch(josa) {
                case 'ì€/ëŠ”':
                    return hasBatchim ? 'ì€' : 'ëŠ”';
                case 'ì´/ê°€':
                    return hasBatchim ? 'ì´' : 'ê°€';
                case 'ì„/ë¥¼':
                    return hasBatchim ? 'ì„' : 'ë¥¼';
                case 'ì˜':
                    return 'ì˜';
                default:
                    return '';
            }
        }

        function updatePlayerName() {
            const playerName = localStorage.getItem('playerName') || 'Player';
            const myTitle = DOM.get('my-title');
            if (myTitle) {
                myTitle.textContent = `ë‚˜ (${playerName})`;
            }
        }
        
        function updateOpponentName() {
            const opponentArea = DOM.get('opponent-area');
            const opponentTitle = opponentArea.querySelector('h2');
            if (opponentTitle) {
                let opponentDisplayName;
                let opponentTitleClass = 'text-xl font-bold text-green-300';
                
                if (multiplayerMode) {
                    // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ: ì‹¤ì œ ìœ ì €
                    displayName = opponentName || 'Player';
                } else {
                    // ì‹±ê¸€í”Œë ˆì´ì–´ ëª¨ë“œ: AI
                    // AI ë‚œì´ë„ë³„ ì´ë¦„ê³¼ ìƒ‰ìƒ ì„¤ì •
                    switch(aiDifficulty) {
                        case 'easy':
                            displayName = 'ì…ë¬¸ìš© í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-green-300';
                            break;
                        case 'normal':
                            displayName = 'í›ˆë ¨ìš© í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-yellow-300';
                            break;
                        case 'hard':
                            displayName = 'ê³ ìˆ˜ìš© í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-red-300';
                            break;
                        default:
                            displayName = 'ê³ ìˆ˜ìš© í—ˆìˆ˜ì•„ë¹„';
                            titleClass = 'text-xl font-bold text-red-300';
                    }
                }
                
                opponentTitle.textContent = `ìƒëŒ€ (${displayName})`;
                opponentTitle.className = titleClass;
                console.log('ğŸ‘¤ ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸:', displayName, 'ëª¨ë“œ:', multiplayerMode ? 'ë©€í‹°í”Œë ˆì´ì–´' : 'ì‹±ê¸€í”Œë ˆì´ì–´');
            }
        }
        
        function showSurrenderConfirmModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 flex items-center justify-center z-50 modal-bg';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg max-w-md w-full mx-4">
                    <div class="text-center">
                        <div class="text-4xl mb-4">âš ï¸</div>
                                                                <h3 class="text-xl font-bold mb-4">ë„ë§</h3>
                        <p class="text-gray-300 mb-6">ì •ë§ ë„ë§ì¹˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
                        <div class="flex space-x-3">
                            <button id="confirm-surrender-btn" class="flex-1 py-3 rounded-lg font-bold bg-red-600 hover:bg-red-700 text-white">ë„¤..</button>
                            <button id="cancel-surrender-btn" class="flex-1 py-3 rounded-lg font-bold btn-primary">ì•„ë‹ˆ</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playCardSound();
            
            return new Promise(resolve => {
                const confirmBtn = modal.querySelector('#confirm-surrender-btn');
                const cancelBtn = modal.querySelector('#cancel-surrender-btn');
                
                confirmBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(true);
                });
                
                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(false);
                });
            });
        }
        


        // Socket.IO ì—°ê²° ì´ˆê¸°í™”
        function initializeSocketIO() {
            if (socket) {
                socket.disconnect();
            }
            
            // Socket.IO ì—°ê²° (ê°œì„ ëœ ì„¤ì •)
            socket = io('https://tactical-card-battle.onrender.com', {
                transports: ['websocket', 'polling'],
                timeout: 60000,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            socket.on('connect', () => {
                console.log('ğŸ”Œ Socket.IO ì—°ê²° ì„±ê³µ');
                serverConnected = true;
            });
            
            socket.on('disconnect', () => {
                console.log('ğŸ”Œ Socket.IO ì—°ê²° í•´ì œ');
                serverConnected = false;
                addLog('ğŸ”Œ ì„œë²„ì™€ì˜ ì—°ê²°ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            });
            
            // ì—°ê²° ì¬ì‹œë„
            socket.on('reconnect', (attemptNumber) => {
                console.log(`ğŸ”„ Socket.IO ì¬ì—°ê²° ì„±ê³µ (ì‹œë„ ${attemptNumber})`);
                serverConnected = true;
                addLog('ğŸ”„ ì„œë²„ì™€ì˜ ì—°ê²°ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
            });
            
            socket.on('reconnect_attempt', (attemptNumber) => {
                console.log(`ğŸ”„ Socket.IO ì¬ì—°ê²° ì‹œë„ ${attemptNumber}`);
            });
            
            socket.on('reconnect_failed', () => {
                console.log('âŒ Socket.IO ì¬ì—°ê²° ì‹¤íŒ¨');
                addLog('âŒ ì„œë²„ ì¬ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            });
            
            socket.on('serverStats', (stats) => {
                console.log('ğŸ“Š ì„œë²„ ìƒíƒœ:', stats);
            });
            
            socket.on('waitingForMatch', (data) => {
                console.log('â³ ë§¤ì¹­ ëŒ€ê¸° ì¤‘:', data);
                updateMatchingMessage(data.message);
            });
            
            socket.on('matchFound', (data) => {
                console.log('âœ… ë§¤ì¹­ ì„±ê³µ:', data);
                opponentName = data.opponent.name;
                isHost = data.isHost;
                
                // ìƒëŒ€ë°© ì´ë¦„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                updateOpponentName();
                
                // ë§¤ì¹­ ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
            const matchingModal = DOM.get('matching-modal');
                matchingModal.classList.add('hidden');
                
                // WebRTC ì—°ê²° ì‹œì‘
                initializeWebRTC(data.opponent.id);
            });
            
            socket.on('opponentDisconnected', (data) => {
                console.log('âŒ ìƒëŒ€ë°© ì—°ê²° í•´ì œ:', data);
                addLog('ìƒëŒ€ë°©ì´ ì—°ê²°ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤.');
                setTimeout(() => {
                    showTitleScreen();
                }, 2000);
            });
            
            // WebRTC ì‹œê·¸ë„ë§ ì´ë²¤íŠ¸
            socket.on('offer', (data) => {
                console.log('ğŸ“¥ Offer ìˆ˜ì‹ :', data);
                handleOffer(data.from, data.offer);
            });
            
            socket.on('answer', (data) => {
                console.log('ğŸ“¥ Answer ìˆ˜ì‹ :', data);
                handleAnswer(data.from, data.answer);
            });
            
            socket.on('iceCandidate', (data) => {
                console.log('ğŸ“¥ ICE Candidate ìˆ˜ì‹ :', data);
                handleIceCandidate(data.from, data.candidate);
            });
            
            // ì„œë²„ ì—ëŸ¬ ì²˜ë¦¬
            socket.on('error', (error) => {
                console.error('âŒ ì„œë²„ ì—ëŸ¬:', error);
                addLog(`âŒ ì„œë²„ ì˜¤ë¥˜: ${error.message}`);
                
                // ì—°ê²° ì¬ì‹œë„
                if (error.context === 'offer' || error.context === 'answer') {
                    setTimeout(() => {
                        console.log('ğŸ”„ WebRTC ì—°ê²° ì¬ì‹œë„...');
                        if (peerConnection) {
                            peerConnection.close();
                            peerConnection = null;
                        }
                        initializeWebRTC(opponentId);
                    }, 2000);
                }
            });
            
            // ê²Œì„ ìƒíƒœ ë³µêµ¬
            socket.on('gameStateRecovery', (data) => {
                console.log('ğŸ”„ ê²Œì„ ìƒíƒœ ë³µêµ¬ ìˆ˜ì‹ :', data);
                if (data.gameState) {
                    state = data.gameState;
                    render();
                    updateButtons();
                    addLog('ğŸ”„ ê²Œì„ ìƒíƒœê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            });

            // ì¹˜íŠ¸: ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ
            socket.on('serverDataReset', (data) => {
                console.log('ğŸ§¹ ëª¨ë“  ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ:', data);
                showToast('ëª¨ë“  ì„œë²„ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
            });

            // ì¹˜íŠ¸: ê°œì¸ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ
            socket.on('myDataReset', (data) => {
                console.log('ğŸ§¹ ê°œì¸ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ:', data);
                showToast(`${data.playerName}ì˜ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
            });
        }
        
        // ë§¤ì¹­ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        function updateMatchingMessage(message) {
            const matchingModal = document.getElementById('matching-modal');
            const messageEl = matchingModal.querySelector('p');
            if (messageEl) {
                messageEl.textContent = message;
            }
        }
        
        // ë©€í‹°í”Œë ˆì´ì–´ ê´€ë ¨ í•¨ìˆ˜ë“¤
        function startMatching() {
            console.log('ğŸ” WebRTC ë©€í‹°í”Œë ˆì´ì–´ ë§¤ì¹­ ì‹œì‘');
            playerName = localStorage.getItem('playerName') || 'Player';
            
            // Socket.IO ì—°ê²° ì´ˆê¸°í™”
            initializeSocketIO();
            
            const matchingModal = DOM.get('matching-modal');
            matchingModal.classList.remove('hidden');
            
            // ëœë¤ ë§¤ì¹­ ë©”ì‹œì§€ í‘œì‹œ
            const matchingMessages = [
                'ê²°íˆ¬í•  ë§ˆë²•ì‚¬ë¥¼ ì†Œí™˜ ì¤‘...',
                'ë§ì§± ëœ° ë§ˆë²•ì‚¬ë¥¼ íƒìƒ‰ ì¤‘...',
                'ìƒëŒ€ ë§ˆë²•ì‚¬ ì¶”ì  ì¤‘...',
                'ëˆ„ê°€ ì£¼ë¬¸ ë¨¼ì € ì™¸ì¹˜ë‚˜ ë³´ì...',
                'ì˜¤ëŠ˜ ìš´ ì—†ì„ ì‚¬ëŒì„ ê³ ë¥´ëŠ” ì¤‘...'
            ];
            const randomMessage = matchingMessages[Math.floor(Math.random() * matchingMessages.length)];
            DOM.get('matching-message').textContent = randomMessage;
            
            // ë§¤ì¹­ ìš”ì²­
            socket.emit('requestMatch', { playerName: playerName });
        }
        
        function cancelMatching() {
            console.log('âŒ ë§¤ì¹­ ì·¨ì†Œ');
            const matchingModal = DOM.get('matching-modal');
            matchingModal.classList.add('hidden');
            
            // Socket.IO ì—°ê²° í•´ì œ
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            
            // WebRTC ì—°ê²° í•´ì œ
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            showTitleScreen();
        }
        
        function startMultiplayerGame() {
            console.log('ğŸ® WebRTC ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ì‹œì‘');
            multiplayerMode = true;
            
            // ë§¤ì¹­ ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
            const matchingModal = DOM.get('matching-modal');
            matchingModal.classList.add('hidden');
            
            // ê²Œì„ í™”ë©´ í‘œì‹œ í™•ì‹¤íˆ í•˜ê¸° (ê°•ì œë¡œ í‘œì‹œ)
            titleScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            // ì¶”ê°€ í™•ì¸: ê²Œì„ í™”ë©´ì´ ì‹¤ì œë¡œ í‘œì‹œë˜ì—ˆëŠ”ì§€ í™•ì¸
            setTimeout(() => {
                if (gameScreen.classList.contains('hidden')) {
                    console.log('âš ï¸ ê²Œì„ í™”ë©´ì´ ì—¬ì „íˆ ìˆ¨ê²¨ì ¸ ìˆìŒ - ê°•ì œ í‘œì‹œ');
                    titleScreen.classList.add('hidden');
                    gameScreen.classList.remove('hidden');
                }
            }, 100);
            
            // í”Œë ˆì´ì–´ ì´ë¦„ ì—…ë°ì´íŠ¸
            updatePlayerName();
            
            // ìƒëŒ€ë°© ì •ë³´ í‘œì‹œ (ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
            updateOpponentName();
            
            // ì–‘ìª½ ëª¨ë‘ ê¸°ë³¸ ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            console.log('ğŸ”„ ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”');
            state = {
                players: [
                    { id: 1, name: playerName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] },
                    { id: 2, name: opponentName || 'Player2', health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] }
                ],
                secretStones: [],
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: 1, // í˜¸ìŠ¤íŠ¸ê°€ í•­ìƒ 1ë²ˆ í”Œë ˆì´ì–´, ì²« í„´ì€ resetGameì—ì„œ ê²°ì •
                isPlayerTurn: true, // í˜¸ìŠ¤íŠ¸ê°€ ì²« í„´ ì‹œì‘ (resetGameì—ì„œ ì¬ì„¤ì •ë¨)
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                isGameOver: false,
                gameStarted: true,
                gameLog: ['ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.']
            };
            
            // ê¸°ë³¸ UI ë Œë”ë§
            createSpellButtons();
            // ê²Œì„ ì‹œì‘ ì‹œ ì£¼ë¬¸ ë²„íŠ¼ í™œì„±í™”
            spellButtonsDisabled = false;
            render();
            updateButtons();
            
            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° ê²Œì„ ì´ˆê¸°í™” ë° ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
            if (isHost) {
                console.log('ğŸ¯ í˜¸ìŠ¤íŠ¸: ê²Œì„ ì´ˆê¸°í™” ì‹œì‘');
                resetGame();
                
                            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° ê²Œì„ ì´ˆê¸°í™” í›„ íƒ€ì´ë¨¸ ì‹œì‘ (í˜¸ìŠ¤íŠ¸ê°€ ì²« í„´ì¼ ë•Œë§Œ)
            if (isHost && state.currentPlayerId === 1) {
                console.log('â° í˜¸ìŠ¤íŠ¸: ì²« í„´ íƒ€ì´ë¨¸ ì‹œì‘');
                startTurnTimer();
            } else if (isHost && state.currentPlayerId === 2) {
                console.log('â° í˜¸ìŠ¤íŠ¸: ìƒëŒ€ í„´ ì‹œì‘ - íƒ€ì´ë¨¸ ì‹œì‘');
                startTurnTimer();
            }
                
                // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° ì´ˆê¸° ê²Œì„ ìƒíƒœë¥¼ ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
                setTimeout(() => {
                    if (dataChannel && dataChannel.readyState === 'open') {
                        console.log('ğŸ“¤ ì´ˆê¸° ê²Œì„ ìƒíƒœ ì „ì†¡');
                        dataChannel.send(JSON.stringify({
                            type: 'gameState',
                            state: state
                        }));
                    } else {
                        console.log('âš ï¸ ë°ì´í„° ì±„ë„ì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ - ì¬ì‹œë„ ì˜ˆì •');
                        // ë°ì´í„° ì±„ë„ì´ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìœ¼ë©´ 1ì´ˆ í›„ ì¬ì‹œë„
                        setTimeout(() => {
                            if (dataChannel && dataChannel.readyState === 'open') {
                                console.log('ğŸ“¤ ì´ˆê¸° ê²Œì„ ìƒíƒœ ì „ì†¡ (ì¬ì‹œë„)');
                                dataChannel.send(JSON.stringify({
                                    type: 'gameState',
                                    state: state
                                }));
                            }
                        }, 1000);
                    }
                }, 500); // 0.5ì´ˆ í›„ ì „ì†¡
            } else {
                console.log('â³ ê²ŒìŠ¤íŠ¸: í˜¸ìŠ¤íŠ¸ì˜ ê²Œì„ ìƒíƒœ ëŒ€ê¸° ì¤‘...');
                addLog('í˜¸ìŠ¤íŠ¸ì˜ ê²Œì„ ì´ˆê¸°í™”ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...');
                
                // ê²ŒìŠ¤íŠ¸ë„ íƒ€ì„ì•„ì›ƒ ì„¤ì •
                setTimeout(() => {
                    if (!state.players || state.players[0].hand.length === 0) {
                        console.log('âš ï¸ í˜¸ìŠ¤íŠ¸ë¡œë¶€í„° ê²Œì„ ìƒíƒœë¥¼ ë°›ì§€ ëª»í•¨ - ìë™ ë³µêµ¬ ì‹œë„');
                        addLog('í˜¸ìŠ¤íŠ¸ ì‘ë‹µì´ ì—†ì–´ ìë™ìœ¼ë¡œ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.');
                        resetGame();
                    }
                }, 5000); // 5ì´ˆ í›„ íƒ€ì„ì•„ì›ƒ
            }
        }

        // WebRTC ì´ˆê¸°í™”
        function initializeWebRTC(opponentId) {
            console.log('ğŸŒ WebRTC ì—°ê²° ì‹œë„ ì¤‘...');
            
            // STUN ì„œë²„ ì„¤ì •
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(configuration);
            
            // ë°ì´í„° ì±„ë„ ìƒì„± (í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš°)
            if (isHost) {
                dataChannel = peerConnection.createDataChannel('gameData');
                setupDataChannel(dataChannel);
            }

            // ë°ì´í„° ì±„ë„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel(dataChannel);
            };

            // ICE í›„ë³´ ì´ë²¤íŠ¸
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('ğŸ“¤ ICE candidate ì „ì†¡:', event.candidate);
                    socket.emit('iceCandidate', {
                        target: opponentId,
                        candidate: event.candidate
                    });
                }
            };

            // ì—°ê²° ìƒíƒœ ë³€ê²½
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    console.log('WebRTC ì—°ê²° ì„±ê³µ!');
                    // í˜¸ìŠ¤íŠ¸ë§Œ ì—¬ê¸°ì„œ ê²Œì„ ì‹œì‘ (ê²ŒìŠ¤íŠ¸ëŠ” ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ë¥¼ ë°›ì„ ë•Œ ì‹œì‘)
                    if (isHost) {
                        startMultiplayerGame();
                    }
                } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    console.log('WebRTC ì—°ê²° ì‹¤íŒ¨ ë˜ëŠ” ì—°ê²° í•´ì œ');
                }
            };

            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° Offer ìƒì„±
            if (isHost) {
                createOffer(opponentId);
            }
        }
        
        // Offer ìƒì„± ë° ì „ì†¡
        async function createOffer(opponentId) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. Offer ìƒì„±ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                console.log('ğŸ“¤ Offer ìƒì„± ë° ì „ì†¡');
                socket.emit('offer', {
                    target: opponentId,
                    offer: offer
                });
            } catch (error) {
                console.error('Offer ìƒì„± ì‹¤íŒ¨:', error);
            }
        }
        
        // Offer ì²˜ë¦¬
        async function handleOffer(from, offer) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. Offer ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                console.log('ğŸ“¤ Answer ìƒì„± ë° ì „ì†¡');
                socket.emit('answer', {
                    target: from,
                    answer: answer
                });
            } catch (error) {
                console.error('Offer ì²˜ë¦¬ ì‹¤íŒ¨:', error);
            }
        }
        
        // Answer ì²˜ë¦¬
        async function handleAnswer(from, answer) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. Answer ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('ğŸ“¥ Answer ì²˜ë¦¬ ì™„ë£Œ');
            } catch (error) {
                console.error('Answer ì²˜ë¦¬ ì‹¤íŒ¨:', error);
            }
        }
        
        // ICE Candidate ì²˜ë¦¬
        async function handleIceCandidate(from, candidate) {
            try {
                if (!peerConnection) {
                    console.log('âš ï¸ peerConnectionì´ nullì…ë‹ˆë‹¤. ICE Candidate ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('ğŸ“¥ ICE Candidate ì²˜ë¦¬ ì™„ë£Œ');
            } catch (error) {
                console.error('ICE Candidate ì²˜ë¦¬ ì‹¤íŒ¨:', error);
            }
        }

        // ë°ì´í„° ì±„ë„ ì„¤ì •
        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('ë°ì´í„° ì±„ë„ ì—´ë¦¼');
                // ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ì „ì†¡
                if (isHost) {
                    console.log('ğŸ“¤ ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ì „ì†¡');
                    channel.send(JSON.stringify({
                        type: 'gameStart',
                        hostName: playerName,
                        guestName: opponentName || 'Player2'
                    }));
                }
            };

            channel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('ğŸ“¥ ê²Œì„ ë©”ì‹œì§€ ìˆ˜ì‹ :', message.type);
                    handleGameMessage(message);
                } catch (error) {
                    console.error('ê²Œì„ ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', error);
                    // íŒŒì‹± ì˜¤ë¥˜ ì‹œ ê²Œì„ ìƒíƒœ ë³µêµ¬
                    setTimeout(() => {
                        safeRefreshGameState();
                    }, 1000);
                }
            };

            channel.onclose = () => {
                console.log('ë°ì´í„° ì±„ë„ ë‹«í˜');
            };
        }

        // ê²Œì„ ë©”ì‹œì§€ ì²˜ë¦¬
        function handleGameMessage(message) {
            console.log('ğŸ“¨ ë°›ì€ ë©”ì‹œì§€:', message);
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ìƒíƒœë¡œ ì´ˆê¸°í™”
            if (!state || !state.players || state.players.length < 2 || !state.players[0] || !state.players[1]) {
                console.log('âš ï¸ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•Šì•„ ê¸°ë³¸ ìƒíƒœë¡œ ì´ˆê¸°í™”');
                const currentPlayerName = localStorage.getItem('playerName') || 'Player';
                state = {
                    players: [
                                        { id: 1, name: currentPlayerName, health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] },
                { id: 2, name: opponentName || 'Player2', health: GAME_CONFIG.maxHealth, hand: [], knownSecretStones: [] }
                    ],
                    secretStones: [],
                    usedStones: [],
                    publiclyRevealedSecretStones: [],
                    currentPlayerId: 1,
                    isPlayerTurn: false,
                    lastSuccessfulSpell: 0,
                    turnInProgress: false,
                    isGameOver: false,
                    gameStarted: true,
                    gameLog: ['ê²Œì„ ìƒíƒœê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.']
                };
                // ê²Œì„ ìƒíƒœ ë³µêµ¬ ì‹œ ì£¼ë¬¸ ë²„íŠ¼ ì¬í™œì„±í™”
                spellButtonsDisabled = false;
                console.log('âœ… ê²Œì„ ìƒíƒœ ë³µêµ¬ ì™„ë£Œ:', state);
            }
            
            switch (message.type) {
                case 'gameStart':
                    opponentName = isHost ? message.guestName : message.hostName;
                    // ê²ŒìŠ¤íŠ¸ì¸ ê²½ìš°ì—ë§Œ startMultiplayerGame í˜¸ì¶œ (í˜¸ìŠ¤íŠ¸ëŠ” ì´ë¯¸ í˜¸ì¶œë¨)
                    if (!isHost) {
                        console.log('ğŸ® ê²ŒìŠ¤íŠ¸: ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ìˆ˜ì‹  - ê²Œì„ ì‹œì‘');
                        startMultiplayerGame();
                    } else {
                        console.log('ğŸ® í˜¸ìŠ¤íŠ¸: ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ ìˆ˜ì‹  - ê²Œì„ í™”ë©´ í™•ì¸');
                        // í˜¸ìŠ¤íŠ¸ë„ ê²Œì„ í™”ë©´ì´ ì œëŒ€ë¡œ í‘œì‹œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³  ê°•ì œ í‘œì‹œ
                        if (gameScreen.classList.contains('hidden')) {
                            console.log('âš ï¸ í˜¸ìŠ¤íŠ¸: ê²Œì„ í™”ë©´ì´ ìˆ¨ê²¨ì ¸ ìˆìŒ - ê°•ì œ í‘œì‹œ');
                            titleScreen.classList.add('hidden');
                            gameScreen.classList.remove('hidden');
                        }
                        // í˜¸ìŠ¤íŠ¸ë„ ê²Œì„ í™”ë©´ì´ í‘œì‹œë˜ì—ˆëŠ”ì§€ ë‹¤ì‹œ í•œë²ˆ í™•ì¸
                        setTimeout(() => {
                            if (gameScreen.classList.contains('hidden')) {
                                console.log('âš ï¸ í˜¸ìŠ¤íŠ¸: ê²Œì„ í™”ë©´ì´ ì—¬ì „íˆ ìˆ¨ê²¨ì ¸ ìˆìŒ - ìµœì¢… ê°•ì œ í‘œì‹œ');
                                titleScreen.classList.add('hidden');
                                gameScreen.classList.remove('hidden');
                            }
                        }, 50);
                    }
                    break;
                case 'firstTurn':
                    console.log(`ğŸ¯ í˜¸ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ í„´ ê²°ì • ìˆ˜ì‹ : í”Œë ˆì´ì–´ ${message.firstPlayer}`);
                    // í˜¸ìŠ¤íŠ¸ì˜ ê²°ì •ìœ¼ë¡œ ê²Œì„ ì´ˆê¸°í™”
                    resetGameWithFirstPlayer(message.firstPlayer);
                    break;
                case 'gameState':
                    console.log('ğŸ“¥ ê²Œì„ ìƒíƒœ ìˆ˜ì‹ ');
                    if (message.state) {
                        updateGameState(message.state);
                        
                        // ê²ŒìŠ¤íŠ¸ê°€ í˜¸ìŠ¤íŠ¸ì˜ ê²Œì„ ìƒíƒœë¥¼ ë°›ì•˜ì„ ë•Œ íƒ€ì´ë¨¸ ì‹œì‘
                        if (!isHost) {
                            console.log(`â° ê²ŒìŠ¤íŠ¸: í˜¸ìŠ¤íŠ¸ ê²Œì„ ìƒíƒœ ìˆ˜ì‹  - ì²« í„´ í”Œë ˆì´ì–´: ${message.state.currentPlayerId}`);
                            setTimeout(() => {
                                startTurnTimer();
                            }, 100); // ì•½ê°„ì˜ ì§€ì—° í›„ íƒ€ì´ë¨¸ ì‹œì‘
                        }
                    }
                    break;
                case 'cardPlayed':
                    handleCardPlayed(message.card, message.playerId, message.gameState);
                    break;
                case 'turnEnd':
                    console.log('ğŸ“¥ í„´ ì¢…ë£Œ ë©”ì‹œì§€ ìˆ˜ì‹ ');
                    handleTurnEnd(message.gameState);
                    break;
                case 'gameOver':
                    handleGameOver(message.winner, message.gameState);
                    break;
                case 'surrender':
                    handleSurrender(message.surrenderingPlayerId);
                    break;
            }
        }



        // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateGameState(newState) {
            console.log('ğŸ”„ ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸');
            
            // ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•œì§€ í™•ì¸
            if (!newState || !newState.players || newState.players.length < 2) {
                console.log('âš ï¸ ë°›ì€ ê²Œì„ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ');
                return;
            }
            
            state = newState;
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ í„´ ìƒíƒœ ë™ê¸°í™”
            if (multiplayerMode) {
                const myPlayerId = isHost ? 1 : 2;
                const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                if (state.isPlayerTurn !== shouldBeMyTurn) {
                    state.isPlayerTurn = shouldBeMyTurn;
                }
            }
            
            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹œ ì£¼ë¬¸ ë²„íŠ¼ ì¬í™œì„±í™”
            spellButtonsDisabled = false;
            
            render();
            updateButtons();
            
            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ íƒ€ì´ë¨¸ ì‹œì‘
            if (isHost) {
                console.log(`â° í˜¸ìŠ¤íŠ¸: ê²Œì„ ìƒíƒœ ìˆ˜ì‹  í›„ íƒ€ì´ë¨¸ ì‹œì‘ - ì²« í„´ í”Œë ˆì´ì–´: ${state.currentPlayerId}`);
                setTimeout(() => {
                    startTurnTimer();
                }, 100); // ì•½ê°„ì˜ ì§€ì—° í›„ íƒ€ì´ë¨¸ ì‹œì‘
            }
            
            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ ë¡œê·¸
            console.log('âœ… ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
        }

                    // ì£¼ë¬¸ í”Œë ˆì´ ì²˜ë¦¬
        function handleCardPlayed(card, playerId, gameState = null) {
            console.log(`ğŸ¯ ì£¼ë¬¸ í”Œë ˆì´ ì²˜ë¦¬: ${card}, í”Œë ˆì´ì–´ ${playerId}`);
            
            if (gameState) {
                // ìƒëŒ€ë°©ì´ ë³´ë‚¸ ê²Œì„ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                state = gameState;
                console.log('ğŸ”„ ê²Œì„ ìƒíƒœ ë™ê¸°í™”ë¨');
                
                // ìƒëŒ€ë°©ì˜ ì£¼ë¬¸ í”Œë ˆì´ íš¨ê³¼ ì‹¤í–‰
                const player = state.players.find(p => p.id === playerId);
                const opponent = state.players.find(p => p.id !== playerId);
                
                // ì£¼ë¬¸ íš¨ê³¼ ì‹¤í–‰ (ìƒëŒ€ë°©ì´ í”Œë ˆì´í•œ ì£¼ë¬¸)
                executeSpellEffect(playerId, card);
            } else {
                // ì£¼ë¬¸ íš¨ê³¼ ì ìš©
                const player = state.players.find(p => p.id === playerId);
                const opponent = state.players.find(p => p.id !== playerId);
                
                applyCardEffect(card, player, opponent);
            }
            render();
        }

        // í„´ ì¢…ë£Œ ì²˜ë¦¬
        function handleTurnEnd(gameState = null) {
            console.log('ğŸ”„ í„´ ì¢…ë£Œ ì²˜ë¦¬');
            
            if (gameState) {
                // ìƒëŒ€ë°©ì´ ë³´ë‚¸ ê²Œì„ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                state = gameState;
                console.log('ğŸ”„ í„´ ì¢…ë£Œ ì‹œ ê²Œì„ ìƒíƒœ ë™ê¸°í™”ë¨');
                
                // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” currentPlayerIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ isPlayerTurn ì¬ì„¤ì •
                if (multiplayerMode) {
                    const myPlayerId = isHost ? 1 : 2;
                    const shouldBeMyTurn = (state.currentPlayerId === myPlayerId);
                    state.isPlayerTurn = shouldBeMyTurn;
                    console.log(`ğŸ® í„´ ë™ê¸°í™” - ë‚´ í”Œë ˆì´ì–´ID: ${myPlayerId}, í˜„ì¬ í”Œë ˆì´ì–´ID: ${state.currentPlayerId}, ë‚´ í„´: ${shouldBeMyTurn}`);
                }
                
                // í„´ ì „í™˜ í›„ í˜„ì¬ í”Œë ˆì´ì–´ í„´ ì‹œì‘ ë¡œê·¸
                const currentPlayerName = state.currentPlayerId === 1 ? state.players[0].name : state.players[1].name;
                addLog(Messages.turnStart(currentPlayerName));
                
                // íƒ€ì´ë¨¸ ì‹œì‘
                setTimeout(() => {
                    startTurnTimer();
                }, 500);
                
                // í„´ì„ ë°›ì€ í”Œë ˆì´ì–´ì˜ ê²½ìš° ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰
                if (multiplayerMode && state.isPlayerTurn) {
                    console.log('ğŸ¯ ë‚´ í„´ ì‹œì‘ - ìë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
                    setTimeout(() => {
                        safeRefreshGameState();
                    }, 500);
                }
            } else {
                state.isPlayerTurn = !state.isPlayerTurn;
                state.currentPlayerId = state.currentPlayerId === 1 ? 2 : 1;
                
                // AI ëª¨ë“œì—ì„œë„ íƒ€ì´ë¨¸ ì‹œì‘
                setTimeout(() => {
                    startTurnTimer();
                }, 500);
            }
            render();
            updateButtons(); // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ ì¶”ê°€
        }

        // ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬
        function handleGameOver(winner, gameState = null) {
            console.log('ğŸ† ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬');
            
            if (gameState) {
                // ìƒëŒ€ë°©ì´ ë³´ë‚¸ ê²Œì„ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
                state = gameState;
                console.log('ğŸ”„ ê²Œì„ ì¢…ë£Œ ì‹œ ê²Œì„ ìƒíƒœ ë™ê¸°í™”ë¨');
            } else {
                state.isGameOver = true;
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ í˜„ì¬ í”Œë ˆì´ì–´ ID ê³„ì‚°
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
            const isPlayerWin = winner === myPlayerId;
            
            // ì „ì  ì—…ë°ì´íŠ¸
            updateStats(isPlayerWin, true);
            
            // ìŠ¹ë¦¬/íŒ¨ë°° ë©”ì‹œì§€ ìƒì„±
            const winnerPlayer = state.players.find(p => p.id === winner);
            if (!winnerPlayer) {
                console.error('âŒ ìŠ¹ë¦¬ í”Œë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', winner);
                return;
            }
            
            let message;
            if (isPlayerWin) {
                // ìŠ¹ë¦¬í•œ ê²½ìš°
                const myPlayer = state.players.find(p => p.id === myPlayerId);
                const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
                
                if (!myPlayer || !opponentPlayer) {
                    console.error('âŒ í”Œë ˆì´ì–´ ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', { myPlayerId, myPlayer, opponentPlayer });
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (opponentPlayer.health <= 0) {
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!';
                } else if (myPlayer.hand.length === 0) {
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!';
                } else {
                    message = 'ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ìƒëŒ€ê°€ ë„ë§ì³¤ìŠµë‹ˆë‹¤!';
                }
            } else {
                // íŒ¨ë°°í•œ ê²½ìš°
                const myPlayer = state.players.find(p => p.id === myPlayerId);
                const opponentPlayer = state.players.find(p => p.id !== myPlayerId);
                
                if (!myPlayer || !opponentPlayer) {
                    console.error('âŒ í”Œë ˆì´ì–´ ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', { myPlayerId, myPlayer, opponentPlayer });
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (myPlayer.health <= 0) {
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìì‹ ì˜ ì²´ë ¥ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (opponentPlayer.hand.length === 0) {
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ìƒëŒ€ê°€ ëª¨ë“  ë§ˆë²• ì£¼ë¬¸ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.';
                } else {
                    message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ë„ë§ì¹˜ê³  ë§ì•˜ìŠµë‹ˆë‹¤.';
                }
            }
            
            // ì—°ìŠ¹ ì²˜ë¦¬ (ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ checkGameOverì—ì„œë§Œ ì²˜ë¦¬)
            if (isPlayerWin) {
                // 2ì—°ìŠ¹ ì´ìƒì¼ ë•Œ ì—°ìŠ¹ ë©”ì‹œì§€ ì¶”ê°€
                if (currentWinStreak >= 2) {
                    message += `\n\n${Messages.streak(currentWinStreak)}`;
                }
            }
            
            // ìŠ¹ë¦¬/íŒ¨ë°° ì‚¬ìš´ë“œ
            playGameOverSound(isPlayerWin);
            
            // ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ í‘œì‹œ
            showModal('ê²Œì„ ì¢…ë£Œ', message, true);
            addLog(`- ê²Œì„ ì¢…ë£Œ: ${winnerPlayer.name} ìŠ¹ë¦¬! -`);
            render();
        }
        
        function startAIGame() {
            console.log(`ğŸ¤– AI ê²Œì„ ì‹œì‘ (ë‚œì´ë„: ${aiDifficulty})`);
            multiplayerMode = false;
            titleScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            resetGame();
            
            // AI ì •ë³´ í‘œì‹œ (ë‚œì´ë„ë³„)
            const aiName = aiDifficulty === 'easy' ? 'ì…ë¬¸ìš© í—ˆìˆ˜ì•„ë¹„' : aiDifficulty === 'normal' ? 'í›ˆë ¨ìš© í—ˆìˆ˜ì•„ë¹„' : 'ê³ ìˆ˜ìš© í—ˆìˆ˜ì•„ë¹„';
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” ì‹œ AI ì´ë¦„ ì„¤ì •
            if (state.players && state.players[1]) {
                state.players[1].name = aiName;
            }
            
            // AI ë‚œì´ë„ë³„ ì‹œê°„ ì œí•œ ì„¤ì •
            setTurnDurationByDifficulty();
            
            // ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸
            updateOpponentName();
        }
        
        // AI ë‚œì´ë„ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
        function showAIDifficultyModal() {
            const modal = DOM.get('ai-difficulty-modal');
            modal.classList.remove('hidden');
            playCardSound();
        }
        
        // AI ë‚œì´ë„ ì„ íƒ ì²˜ë¦¬
        function selectAIDifficulty(difficulty) {
            aiDifficulty = difficulty;
            console.log(`ğŸ¤– AI ë‚œì´ë„ ì„ íƒ: ${difficulty}`);
            
            const modal = DOM.get('ai-difficulty-modal');
            modal.classList.add('hidden');
            
            startAIGame();
        }
        
        // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
        function showToast(message, duration = 3000) {
            const toast = DOM.get('toast');
            const toastMessage = DOM.get('toast-message');
            
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            
            setTimeout(() => {
                toast.classList.add('hidden');
            }, duration);
        }
        
        // íƒ€ì´í‹€ í™”ë©´ í‘œì‹œ í•¨ìˆ˜
        function showTitleScreen() {
            // ê²Œì„ ì‹œì‘ ì¤‘ì—ëŠ” íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ì§€ ì•Šë„ë¡ ë³´í˜¸
            if (GameConditions.isGameInProgress()) {
                console.log('âš ï¸ ê²Œì„ ì§„í–‰ ì¤‘ - íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ì§€ ì•ŠìŒ');
                return;
            }
            
            console.log('ğŸ  íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°');
            gameScreen.classList.add('hidden');
            titleScreen.classList.remove('hidden');
            
            // íƒ€ì´ë¨¸ ì •ì§€ ë° ê²Œì´ì§€ ì´ˆê¸°í™”
            stopTurnTimer();
            resetTurnGauge();
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
            state = {
                gameStarted: false,
                isGameOver: true,
                players: [],
                secretStones: [],
                usedStones: [],
                publiclyRevealedSecretStones: [],
                currentPlayerId: null,
                isPlayerTurn: false,
                lastSuccessfulSpell: 0,
                turnInProgress: false,
                gameLog: []
            };
            
            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ ì´ˆê¸°í™”
            multiplayerMode = false;
            peerConnection = null;
            dataChannel = null;
            isHost = false;
            opponentName = '';
            myPlayerId = null;
            
            // ê¸°ë³¸ ì´ë¦„ ì´ˆê¸°í™” (ì²« ë°©ë¬¸ ì‹œ ëœë¤ ì´ë¦„ ìƒì„±)
            initializePlayerName();
            
            // 3ì´ˆê°„ ë²„íŠ¼ ë¹„í™œì„±í™”
            disableTitleButtons();
        }
        
        // íƒ€ì´í‹€ í™”ë©´ ë²„íŠ¼ ë¹„í™œì„±í™”
        function disableTitleButtons() {
            const buttons = titleScreen.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
            
            // 1ì´ˆ í›„ ë²„íŠ¼ í™œì„±í™”
            setTimeout(() => {
                enableTitleButtons();
            }, 1000);
        }
        
        // íƒ€ì´í‹€ í™”ë©´ ë²„íŠ¼ í™œì„±í™”
        function enableTitleButtons() {
            const buttons = titleScreen.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            });
        }
        
        // ë„ë§ í•¨ìˆ˜
        async function surrenderGame() {
            const confirmed = await showSurrenderConfirmModal();
            if (confirmed) {
                // íŒ¨ë°° ì²˜ë¦¬
                updateStats(false, multiplayerMode);
                
                // ìŠ¹ì  ê°ì†Œ ì²˜ë¦¬
                if (multiplayerMode) {
                    TrophySystem.addDefeatTrophy('multiplayer');
                } else {
                    TrophySystem.addDefeatTrophy('ai');
                }
                
                addLog('ê²°íˆ¬ë¥¼ ë„ë§ì³¤ìŠµë‹ˆë‹¤.');
                addLog('íŒ¨ë°°ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œ ìƒëŒ€ë°©ì—ê²Œ ë„ë§ ë©”ì‹œì§€ ì „ì†¡
                if (multiplayerMode && dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'surrender',
                        surrenderingPlayerId: 1
                    }));
                }
                
                // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
                state = {
                    gameStarted: false,
                    isGameOver: true,
                    players: [],
                    secretStones: [],
                    usedStones: [],
                    publiclyRevealedSecretStones: [],
                    currentPlayerId: null,
                    isPlayerTurn: false,
                    lastSuccessfulSpell: 0,
                    turnInProgress: false,
                    gameLog: []
                };
                
                // ë„ë§í•œ í”Œë ˆì´ì–´ì—ê²Œ ë©”ì‹œì§€ í‘œì‹œ (ìŠ¹ì  ê°ì†Œ í¬í•¨)
                let message = 'íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.. ë„ë§ì¹˜ê³  ë§ì•˜ìŠµë‹ˆë‹¤.';
                message += '\n\nğŸ… ìŠ¹ì  -1';
                await showModal('ê²Œì„ ì¢…ë£Œ', message, true);
                
                // ë°”ë¡œ íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                showTitleScreen();
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        DOM.get('ai-battle-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            showAIDifficultyModal();
        });
        DOM.get('multiplayer-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            startMatching();
        });
        DOM.get('cancel-matching-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            cancelMatching();
        });
        
        // AI ë‚œì´ë„ ì„ íƒ ë²„íŠ¼ë“¤
        DOM.get('easy-ai-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            selectAIDifficulty('easy');
        });
        DOM.get('normal-ai-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            selectAIDifficulty('normal');
        });
        DOM.get('hard-ai-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            selectAIDifficulty('hard');
        });
        DOM.get('cancel-difficulty-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            DOM.get('ai-difficulty-modal').classList.add('hidden');
        });

        endTurnBtn.addEventListener('click', () => {
            console.log('ğŸ”„ í„´ ì¢…ë£Œ ë²„íŠ¼ í´ë¦­');
            if (GameConditions.canPlaySpell()) {
            const myPlayerId = multiplayerMode ? (isHost ? 1 : 2) : 1;
                addLog(`- ${state.players[myPlayerId - 1].name}${getJosa(state.players[myPlayerId - 1].name, 'ì´/ê°€')} í„´ì„ ìˆ˜ë™ìœ¼ë¡œ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤.`);
                endTurn();
            }
        });
        
        // ë„ë§ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('surrender-btn').addEventListener('click', surrenderGame);
        
        // ë‚´ ì •ë³´ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('profile-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            showProfileModal();
        });
        
        // ë­í‚¹ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('ranking-btn').addEventListener('click', (e) => {
            if (e.target.disabled) {
                showToast('ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.');
                return;
            }
            showRankingModal();
        });
        
        // ì´ë¦„ ì…ë ¥ ë° ì €ì¥ ê¸°ëŠ¥
        const playerNameInput = DOM.get('player-name-input');
        const saveNameBtn = DOM.get('save-name-btn');
        const nameSaveStatus = DOM.get('name-save-status');
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ í˜„ì¬ ì´ë¦„ ì„¤ì •
        const currentName = localStorage.getItem('playerName') || '';
        playerNameInput.value = currentName;
        updateNameSaveStatus();
        
        // ì´ë¦„ ì…ë ¥ ì‹œ ì €ì¥ ìƒíƒœ ì—…ë°ì´íŠ¸
        playerNameInput.addEventListener('input', updateNameSaveStatus);
        
        // ì €ì¥ ë²„íŠ¼ í´ë¦­
        saveNameBtn.addEventListener('click', () => {
            const newName = playerNameInput.value.trim();
            if (newName) {
                localStorage.setItem('playerName', newName);
                console.log(`ğŸ‘¤ í”Œë ˆì´ì–´ ì´ë¦„ ì €ì¥: ${newName}`);
                updatePlayerName();
                showNameSaveSuccess();
            } else {
                showToast('ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            }
        });
        
        // ì´ë¦„ ì €ì¥ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateNameSaveStatus() {
            const currentName = localStorage.getItem('playerName') || '';
            const inputName = playerNameInput.value.trim();
            
            if (inputName === currentName && inputName !== '') {
                saveNameBtn.disabled = true;
                saveNameBtn.style.opacity = '0.5';
                saveNameBtn.style.cursor = 'not-allowed';
                nameSaveStatus.classList.remove('hidden');
            } else {
                saveNameBtn.disabled = false;
                saveNameBtn.style.opacity = '1';
                saveNameBtn.style.cursor = 'pointer';
                nameSaveStatus.classList.add('hidden');
            }
        }
        
        // ì´ë¦„ ì €ì¥ ì„±ê³µ í‘œì‹œ
        function showNameSaveSuccess() {
            nameSaveStatus.classList.remove('hidden');
            setTimeout(() => {
                nameSaveStatus.classList.add('hidden');
            }, 2000);
        }

        usedStonesPile.addEventListener('click', () => {
            playCardSound();
                            showCardListModal('ì‚¬ìš©í•œ ì£¼ë¬¸ ëª©ë¡', state.usedStones);
        });
        
        secretStonesPile.addEventListener('click', () => {
            playCardSound();
            showCombinedSecretStonesModal();
        });

        // ë””ë²„ê·¸ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        DOM.get('debug-show-state').addEventListener('click', showDebugInfo);
        DOM.get('debug-show-player-hand').addEventListener('click', showPlayerHand);
        DOM.get('debug-show-ai-hand').addEventListener('click', showAIHand);
        DOM.get('debug-reset-game').addEventListener('click', resetGame);
        DOM.get('debug-player-win').addEventListener('click', () => {
            state.players[1].health = 0;
            checkGameOver();
        });
        DOM.get('debug-ai-win').addEventListener('click', () => {
            state.players[0].health = 0;
            checkGameOver();
        });
        DOM.get('debug-add-player-health').addEventListener('click', () => {
            if (state.players[0].health < 5) state.players[0].health++;
            render();
        });
        DOM.get('debug-add-ai-health').addEventListener('click', () => {
            if (state.players[1].health < 5) state.players[1].health++;
            render();
        });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ê¸°ë³¸ ì´ë¦„ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ í˜ì´ì§€ ë¡œë“œ - ê¸°ë³¸ ì´ë¦„ ì´ˆê¸°í™”');
            DOM.init(); // DOM ìºì‹œ ì´ˆê¸°í™”
            TrophySystem.init(); // ì¦í‘œ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            initializePlayerName();
        });

    </script>
</body>
</html>
 